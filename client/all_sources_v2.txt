===== ./tsconfig.node.json =====
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

===== ./index.html =====
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>HRmageddon - Tactical Office Warfare</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

===== ./tailwind.config.js =====
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    './index.html',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}



===== ./tsconfig.app.json =====
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

===== ./README.md =====
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      ...tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      ...tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      ...tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

===== ./public/data/game_config.json =====
{
    "game_version": "0.1.0",
    "draft_config": {
      "starting_funds": 1000,
      "timer_seconds": 60,
      "picks_per_player": 5
    },
    "gameplay_rules": {
      "max_team_size": 4,
      "turn_limit": 50
    }
  }
===== ./public/data/attack_patterns.json =====
{
    "attack_patterns": [
      {
        "key": "single_target_melee",
        "type": "directional",
        "pattern": [
          [0, 1],
          [0, 2]
        ]
      },
      {
        "key": "single_target_ranged",
        "type": "directional",
        "pattern": [
          [0, 0, 0, 0, 0],
          [0, 0, 1, 0, 0],
          [0, 0, 2, 0, 0],
          [0, 0, 1, 0, 0],
          [0, 0, 0, 0, 0]
        ]
      },
      {
        "key": "self_target",
        "type": "centered",
        "pattern": [
          [2]
        ]
      },
      {
        "key": "all_allies",
        "type": "global",
        "pattern": [
          [1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1],
          [1, 1, 2, 1, 1],
          [1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1]
        ]
      },
      {
        "key": "all_enemies",
        "type": "global",
        "pattern": [
          [1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1],
          [1, 1, 2, 1, 1],
          [1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1]
        ]
      },
      {
        "key": "forward_cone",
        "type": "directional",
        "pattern": [
          [0, 0, 1, 1, 0, 0],
          [0, 1, 1, 1, 0, 0],
          [2, 1, 1, 0, 0, 0],
          [0, 1, 1, 1, 0, 0],
          [0, 0, 1, 1, 0, 0]
        ]
      },
      {
        "key": "centered_cross_burst",
        "type": "centered",
        "pattern": [
          [0, 0, 1, 0, 0],
          [0, 0, 1, 0, 0],
          [1, 1, 2, 1, 1],
          [0, 0, 1, 0, 0],
          [0, 0, 1, 0, 0]
        ]
      },
      {
        "key": "firewall_line",
        "type": "directional",
        "pattern": [
          [0, 0, 0],
          [1, 1, 1],
          [0, 2, 0]
        ]
      }
    ]
  }
===== ./public/data/status_effects.json =====
{
    "status_effects": [
      {
        "key": "on_deadline",
        "name": "On Deadline",
        "description": "Increased focus and productivity.",
        "type": "buff",
        "duration_in_turns": 2,
        "modifiers": {
          "stat": "attack_power",
          "operation": "multiply",
          "value": 1.2
        },
        "visual_effect": "deadline_glow"
      },
      {
        "key": "exhausted",
        "name": "Exhausted",
        "description": "Reduced effectiveness from overwork.",
        "type": "debuff",
        "duration_in_turns": 1,
        "modifiers": {
          "stat": "actions_remaining",
          "operation": "subtract",
          "value": 1
        },
        "visual_effect": "exhausted_aura"
      },
      {
        "key": "written_up",
        "name": "Written Up",
        "description": "Formal reprimand reduces morale.",
        "type": "debuff",
        "duration_in_turns": 2,
        "modifiers": {
          "stat": "attack_power",
          "operation": "multiply",
          "value": 0.8
        },
        "visual_effect": "paper_trail"
      },
      {
        "key": "harassed",
        "name": "Harassed",
        "description": "Prevents capturing cubicles.",
        "type": "debuff",
        "duration_in_turns": 2,
        "modifiers": {
          "stat": "can_capture",
          "operation": "set",
          "value": false
        },
        "visual_effect": "harass_aura"
      },
      {
        "key": "confused",
        "name": "Confused",
        "description": "Reduces accuracy and effectiveness.",
        "type": "debuff",
        "duration_in_turns": 2,
        "modifiers": {
          "stat": "attack_power",
          "operation": "multiply",
          "value": 0.7
        },
        "visual_effect": "confusion_swirl"
      },
      {
        "key": "focused",
        "name": "Focused",
        "description": "Increased concentration and accuracy.",
        "type": "buff",
        "duration_in_turns": 2,
        "modifiers": {
          "stat": "attack_power",
          "operation": "multiply",
          "value": 1.3
        },
        "visual_effect": "focus_aura"
      },
      {
        "key": "stunned",
        "name": "Stunned",
        "description": "Cannot take actions this turn.",
        "type": "debuff",
        "duration_in_turns": 1,
        "modifiers": {
          "stat": "can_act",
          "operation": "set",
          "value": false
        },
        "visual_effect": "stun_stars"
      },
      {
        "key": "shielded",
        "name": "Shielded",
        "description": "Reduces incoming damage.",
        "type": "buff",
        "duration_in_turns": 2,
        "modifiers": {
          "stat": "defense",
          "operation": "multiply",
          "value": 1.5
        },
        "visual_effect": "shield_aura"
      },
      {
        "key": "inspired",
        "name": "Inspired",
        "description": "Motivated by leadership.",
        "type": "buff",
        "duration_in_turns": 2,
        "modifiers": {
          "stat": "attack_power",
          "operation": "multiply",
          "value": 1.25
        },
        "visual_effect": "inspiration_glow"
      },
      {
        "key": "slow",
        "name": "Slowed",
        "description": "Reduces target's speed.",
        "type": "debuff",
        "duration_in_turns": 2,
        "modifiers": {
          "stat": "speed",
          "operation": "multiply",
          "value": 0.5
        },
        "visual_effect": "slow_aura"
      },
      {
        "key": "fire",
        "name": "On Fire",
        "description": "Deals damage each turn.",
        "type": "debuff",
        "duration_in_turns": 2,
        "tick_effect": {
          "type": "damage",
          "value": 10
        },
        "visual_effect": "flames_particle"
      },
      {
        "key": "freeze",
        "name": "Frozen",
        "description": "Target cannot take action.",
        "type": "debuff",
        "duration_in_turns": 1,
        "modifiers": {
          "stat": "can_act",
          "operation": "set",
          "value": false
        },
        "visual_effect": "ice_block"
      },
      {
        "key": "increase_speed",
        "name": "Hasted",
        "description": "Increases target's speed.",
        "type": "buff",
        "duration_in_turns": 3,
        "modifiers": {
          "stat": "speed",
          "operation": "multiply",
          "value": 1.2
        },
        "visual_effect": "speed_lines"
      },
      {
        "key": "bleeding",
        "name": "Bleeding",
        "description": "Takes damage over time.",
        "type": "debuff",
        "duration_in_turns": 3,
        "tick_effect": {
          "type": "damage",
          "value": 5
        },
        "visual_effect": "blood_drops"
      }
    ]
  }
===== ./public/data/employees.json =====
{
    "employees": [
      {
        "id": 1,
        "key": "salesman",
        "name": "Slick Salesman",
        "cost": 150,
        "stats": {
          "health": 100,
          "attack_power": 20,
          "defense": 10,
          "speed": 5
        },
        "attack": {
          "type": "melee",
          "range": 1,
          "description": "Aggressive Pitch",
          "status_effect": {
            "type": "slow",
            "chance": 0.25,
            "duration": 2,
            "magnitude": 0.5
          }
        },
        "ability_keys": ["harass"]
      },
      {
        "id": 2,
        "key": "secretary",
        "name": "Executive Secretary",
        "cost": 120,
        "stats": {
          "health": 80,
          "attack_power": 5,
          "defense": 15,
          "speed": 6
        },
        "attack": {
          "type": "ranged",
          "range": 4,
          "description": "Paper Cut Barrage",
          "status_effect": {
            "type": "none"
          }
        },
        "ability_keys": ["urgent_memo"]
      },
      {
        "id": 3,
        "key": "manager",
        "name": "Middle Manager",
        "cost": 250,
        "stats": {
          "health": 150,
          "attack_power": 35,
          "defense": 20,
          "speed": 4
        },
        "attack": {
          "type": "melee",
          "range": 1,
          "description": "Synergize",
          "status_effect": {
            "type": "fire",
            "chance": 0.15,
            "duration": 2,
            "damage_per_turn": 10
          }
        },
        "ability_keys": ["pink_slip"]
      },
      {
        "id": 4,
        "key": "it_guy",
        "name": "IT Guy",
        "cost": 180,
        "stats": {
          "health": 90,
          "attack_power": 25,
          "defense": 12,
          "speed": 5
        },
        "attack": {
          "type": "ranged",
          "range": 5,
          "description": "Firewall",
          "status_effect": {
            "type": "freeze",
            "chance": 0.20,
            "duration": 1
          }
        },
        "ability_keys": ["hack_system"]
      }
    ]
  }
===== ./public/data/abilities.json =====
{
    "abilities": [
      {
        "key": "fetch_coffee",
        "name": "Fetch Coffee",
        "description": "Grant \"On Deadline\" to an adjacent ally",
        "cooldown_turns": 1,
        "range_pattern_key": "single_target_melee",
        "effects": [
          {
            "type": "apply_status_effect",
            "target": "ally",
            "status_key": "on_deadline",
            "chance": 1.0
          }
        ]
      },
      {
        "key": "overtime",
        "name": "Overtime",
        "description": "Gain +1 action but become Exhausted next turn",
        "cooldown_turns": 2,
        "range_pattern_key": "self_target",
        "effects": [
          {
            "type": "action_bonus",
            "value": 1
          },
          {
            "type": "apply_status_effect",
            "target": "self",
            "status_key": "exhausted",
            "chance": 1.0
          }
        ]
      },
      {
        "key": "file_it",
        "name": "File It",
        "description": "Apply \"Written Up\" to target",
        "cooldown_turns": 2,
        "range_pattern_key": "single_target_ranged",
        "effects": [
          {
            "type": "apply_status_effect",
            "target": "enemy",
            "status_key": "written_up",
            "chance": 1.0
          }
        ]
      },
      {
        "key": "harass",
        "name": "Harass",
        "description": "Apply \"Harassed\" status preventing capture",
        "cooldown_turns": 1,
        "range_pattern_key": "single_target_ranged",
        "effects": [
          {
            "type": "apply_status_effect",
            "target": "enemy",
            "status_key": "harassed",
            "chance": 1.0
          }
        ]
      },
      {
        "key": "pink_slip",
        "name": "Pink Slip",
        "description": "Execute an adjacent enemy at âM-^I¤2 HP",
        "cooldown_turns": -1,
        "range_pattern_key": "single_target_melee",
        "effects": [
          {
            "type": "damage",
            "target": "enemy",
            "value": 999,
            "damage_type": "execution"
          }
        ]
      },
      {
        "key": "mediation",
        "name": "Mediation",
        "description": "Cleanse status and heal 1 HP",
        "cooldown_turns": 2,
        "range_pattern_key": "single_target_melee",
        "effects": [
          {
            "type": "heal",
            "target": "ally",
            "value": 1
          },
          {
            "type": "cleanse_status",
            "target": "ally"
          }
        ]
      },
      {
        "key": "hack_system",
        "name": "Hack System",
        "description": "Apply \"Confused\" status to enemy",
        "cooldown_turns": 2,
        "range_pattern_key": "single_target_ranged",
        "effects": [
          {
            "type": "apply_status_effect",
            "target": "enemy",
            "status_key": "confused",
            "chance": 1.0
          }
        ]
      },
      {
        "key": "tech_support",
        "name": "Tech Support",
        "description": "Remove negative status from ally",
        "cooldown_turns": 2,
        "range_pattern_key": "single_target_ranged",
        "effects": [
          {
            "type": "cleanse_status",
            "target": "ally"
          }
        ]
      },
      {
        "key": "audit",
        "name": "Audit",
        "description": "Apply \"Focused\" status to self",
        "cooldown_turns": 2,
        "range_pattern_key": "self_target",
        "effects": [
          {
            "type": "apply_status_effect",
            "target": "self",
            "status_key": "focused",
            "chance": 1.0
          }
        ]
      },
      {
        "key": "creative_accounting",
        "name": "Creative Accounting",
        "description": "Gain +1 action this turn",
        "cooldown_turns": 3,
        "range_pattern_key": "self_target",
        "effects": [
          {
            "type": "action_bonus",
            "value": 1
          }
        ]
      },
      {
        "key": "legal_threat",
        "name": "Legal Threat",
        "description": "Apply \"Stunned\" status to enemy",
        "cooldown_turns": 3,
        "range_pattern_key": "single_target_ranged",
        "effects": [
          {
            "type": "apply_status_effect",
            "target": "enemy",
            "status_key": "stunned",
            "chance": 1.0
          }
        ]
      },
      {
        "key": "contract_negotiation",
        "name": "Contract Negotiation",
        "description": "Apply \"Shielded\" status to ally",
        "cooldown_turns": 2,
        "range_pattern_key": "single_target_ranged",
        "effects": [
          {
            "type": "apply_status_effect",
            "target": "ally",
            "status_key": "shielded",
            "chance": 1.0
          }
        ]
      },
      {
        "key": "executive_order",
        "name": "Executive Order",
        "description": "Apply \"Inspired\" to all allies",
        "cooldown_turns": 4,
        "range_pattern_key": "all_allies",
        "effects": [
          {
            "type": "apply_status_effect",
            "target": "all_allies",
            "status_key": "inspired",
            "chance": 1.0
          }
        ]
      },
      {
        "key": "corporate_restructuring",
        "name": "Corporate Restructuring",
        "description": "Deal 2 damage to all enemies in range",
        "cooldown_turns": 4,
        "range_pattern_key": "all_enemies",
        "effects": [
          {
            "type": "damage",
            "target": "all_enemies",
            "value": 2,
            "damage_type": "corporate"
          }
        ]
      },
      {
        "key": "paperclip_storm",
        "name": "Paperclip Storm",
        "description": "Launch a storm of paperclips in a cone direction",
        "cooldown_turns": 3,
        "range_pattern_key": "forward_cone",
        "effects": [
          {
            "type": "damage",
            "target": "enemy",
            "value": 1,
            "damage_type": "physical"
          }
        ]
      },
      {
        "key": "thousand_papercuts",
        "name": "A Thousand Papercuts",
        "description": "Unleashes a cone of sharp paper, dealing initial damage and causing targets to bleed.",
        "cooldown_turns": 3,
        "range_pattern_key": "forward_cone",
        "effects": [
          {
            "type": "damage",
            "target": "enemy",
            "value": 15,
            "damage_type": "physical"
          },
          {
            "type": "apply_status_effect",
            "target": "enemy",
            "status_key": "bleeding",
            "chance": 1.0
          }
        ]
      },
      {
        "key": "urgent_memo",
        "name": "Urgent Memo",
        "description": "Boosts an ally's speed, granting them extra movement.",
        "cooldown_turns": 2,
        "range_pattern_key": "centered_cross_burst",
        "effects": [
          {
            "type": "apply_status_effect",
            "target": "ally",
            "status_key": "increase_speed",
            "chance": 1.0
          }
        ]
      },
      {
        "key": "firewall",
        "name": "Firewall",
        "description": "Creates a wall of fire that burns any who pass through it.",
        "cooldown_turns": 4,
        "range_pattern_key": "firewall_line",
        "effects": [
          {
            "type": "create_tile_hazard",
            "hazard_details": {
              "name": "Burning Ground",
              "duration_in_turns": 3,
              "visual_effect": "ground_flames",
              "on_turn_end": {
                "type": "damage",
                "value": 20,
                "damage_type": "fire"
              },
              "on_enter": {
                "type": "apply_status_effect",
                "status_key": "fire",
                "chance": 1.0
              }
            }
          }
        ]
      }
    ]
  }
===== ./public/assets/tilemaps/OfficeLayout16x12.json =====
{ "compressionlevel":-1,
 "height":12,
 "infinite":false,
 "layers":[
        {
         "data":[599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599,
            599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599,
            599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599,
            599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599,
            599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599,
            599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599,
            599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599,
            599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599,
            599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599,
            599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599,
            599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599,
            599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599],
         "height":12,
         "id":1,
         "name":"Background",
         "opacity":1,
         "type":"tilelayer",
         "visible":true,
         "width":16,
         "x":0,
         "y":0
        }, 
        {
         "data":[315, 319, 319, 319, 319, 319, 319, 319, 319, 319, 319, 319, 319, 319, 319, 320,
            347, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 289, 292, 293, 294, 448,
            347, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 321, 324, 325, 326, 448,
            347, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 448,
            347, 0, 0, 0, 195, 200, 0, 0, 0, 0, 195, 200, 0, 0, 0, 448,
            347, 0, 0, 0, 227, 232, 0, 0, 0, 0, 227, 232, 0, 0, 0, 448,
            347, 0, 0, 0, 0, 0, 0, 195, 200, 0, 0, 0, 0, 0, 0, 448,
            347, 0, 0, 0, 0, 0, 0, 227, 232, 0, 0, 0, 0, 0, 0, 448,
            347, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 448,
            347, 289, 290, 291, 294, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 448,
            347, 321, 322, 323, 326, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 448,
            475, 476, 476, 476, 476, 476, 476, 476, 476, 476, 476, 476, 476, 476, 476, 480],
         "height":12,
         "id":2,
         "name":"Foreground",
         "opacity":1,
         "type":"tilelayer",
         "visible":true,
         "width":16,
         "x":0,
         "y":0
        }, 
        {
         "data":[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 472, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 472, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 472, 0, 0, 0,
            0, 0, 0, 0, 472, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 472, 0, 0, 0, 0, 0, 0, 0, 472, 0, 0, 0, 0, 472, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 472, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
         "height":12,
         "id":3,
         "name":"CapturePoints",
         "opacity":1,
         "type":"tilelayer",
         "visible":true,
         "width":16,
         "x":0,
         "y":0
        }, 
        {
         "data":[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 595, 595, 595, 595, 595, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 595, 595, 595, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563, 563, 563, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563, 563, 563, 563, 563, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
         "height":12,
         "id":4,
         "name":"StartingPoints",
         "opacity":1,
         "type":"tilelayer",
         "visible":true,
         "width":16,
         "x":0,
         "y":0
        }],
 "nextlayerid":5,
 "nextobjectid":1,
 "orientation":"orthogonal",
 "renderorder":"right-down",
 "tiledversion":"1.11.2",
 "tileheight":16,
 "tilesets":[
        {
         "columns":32,
         "firstgid":1,
         "image":"inside.png",
         "imageheight":336,
         "imagewidth":512,
         "margin":0,
         "name":"OfficeLayout",
         "spacing":0,
         "tilecount":672,
         "tileheight":16,
         "tilewidth":16
        }],
 "tilewidth":16,
 "type":"map",
 "version":"1.10",
 "width":16
}
===== ./package.json =====
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:run": "vitest run",
    "test:strict": "node scripts/test-strict.js",
    "test:all": "npm run test:strict && npm run test:run"
  },
  "dependencies": {
    "phaser": "^3.90.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "shared": "file:../shared",
    "zustand": "^5.0.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.32.0",
    "@types/react": "^19.1.9",
    "@types/react-dom": "^19.1.7",
    "@vitejs/plugin-react": "^4.7.0",
    "@vitest/ui": "^3.2.4",
    "autoprefixer": "10.4.20",
    "eslint": "^9.32.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "jsdom": "^26.1.0",
    "postcss": "8.4.49",
    "tailwindcss": "3.4.14",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.39.0",
    "vite": "^7.1.0",
    "vitest": "^3.2.4"
  }
}

===== ./scripts/test-strict.js =====
#!/usr/bin/env node

/**
 * Strict TypeScript Testing Script
 * 
 * This script runs comprehensive TypeScript checks to catch errors early:
 * 1. TypeScript compilation with strict mode
 * 2. ESLint with strict rules
 * 3. Import/export validation
 * 4. Type checking across all files
 */

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

console.log('ðM-^_M-^TM-^M Running Strict TypeScript Tests...\n');

// Colors for output
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  reset: '\x1b[0m',
  bold: '\x1b[1m'
};

function log(color, message) {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function runCommand(command, description) {
  try {
    log('blue', `ðM-^_M-^SM-^K ${description}...`);
    const result = execSync(command, { 
      cwd: process.cwd(),
      stdio: 'pipe',
      encoding: 'utf8'
    });
    log('green', `âM-^\M-^E ${description} - PASSED`);
    return { success: true, output: result };
  } catch (error) {
    log('red', `âM-^]M-^L ${description} - FAILED`);
    console.log(error.stdout || error.stderr);
    return { success: false, error: error.message };
  }
}

// Test 1: TypeScript Compilation (Strict Mode)
log('bold', '1. TypeScript Compilation (Strict Mode)');
const tsResult = runCommand(
  'npx tsc --noEmit --strict --noImplicitAny --noImplicitReturns --noImplicitThis --noUnusedLocals --noUnusedParameters',
  'TypeScript strict compilation'
);

// Test 2: ESLint with Strict Rules
log('bold', '\n2. ESLint with Strict Rules');
const eslintResult = runCommand(
  'npx eslint src --ext .ts,.tsx --max-warnings 0',
  'ESLint strict linting'
);

// Test 3: Import/Export Validation
log('bold', '\n3. Import/Export Validation');
const importResult = runCommand(
  'npx tsc --noEmit --skipLibCheck --isolatedModules',
  'Import/Export validation'
);

// Test 4: Type Checking Across All Files
log('bold', '\n4. Type Checking Across All Files');
const typeCheckResult = runCommand(
  'npx tsc --noEmit --skipLibCheck --strictNullChecks --strictFunctionTypes',
  'Comprehensive type checking'
);

// Test 5: Build Test
log('bold', '\n5. Build Test');
const buildResult = runCommand(
  'npm run build',
  'Production build test'
);

// Summary
log('bold', '\nðM-^_M-^SM-^J Test Summary:');
const tests = [
  { name: 'TypeScript Strict', result: tsResult },
  { name: 'ESLint Strict', result: eslintResult },
  { name: 'Import/Export', result: importResult },
  { name: 'Type Checking', result: typeCheckResult },
  { name: 'Build Test', result: buildResult }
];

let passed = 0;
let failed = 0;

tests.forEach(test => {
  if (test.result.success) {
    log('green', `âM-^\M-^E ${test.name}: PASSED`);
    passed++;
  } else {
    log('red', `âM-^]M-^L ${test.name}: FAILED`);
    failed++;
  }
});

log('bold', `\nðM-^_M-^N¯ Results: ${passed} passed, ${failed} failed`);

if (failed > 0) {
  log('red', '\nâM-^]M-^L Some tests failed. Please fix the issues before committing.');
  process.exit(1);
} else {
  log('green', '\nðM-^_M-^NM-^I All tests passed! Code is ready for commit.');
  process.exit(0);
}

===== ./tsconfig.json =====
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

===== ./eslint.config.js =====
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { globalIgnores } from 'eslint/config'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
  {
    files: ['**/*.test.ts', '**/*.test.tsx'],
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
    },
  },
])

===== ./vite.config.ts =====
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5178,
    strictPort: true,
  }
})

===== ./vitest.config.ts =====
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./src/test/setup.ts'],
    testTimeout: 30000,
    hookTimeout: 30000,
  }
})

===== ./postcss.config.js =====
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



===== ./src/App.tsx =====
import './index.css'
import { useState, useEffect } from 'react'
import { GameView } from './components/GameView'
import { GameHUD } from './components/GameHUD'
import { MainMenu } from './components/MainMenu'
import { DraftScreen } from './components/DraftScreen'
import { LoadingScreen } from './components/LoadingScreen'
import { TileSizeTestPage } from './components/test/TileSizeTestPage'
import { useGameStore } from './stores/gameStore'
import { usePlayerStore } from './stores/playerStore'
import { GamePhase } from 'shared'

export default function App() {
  const { gameMode, returnToMenu } = useGameStore()
  const { phase, winner } = usePlayerStore()
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    // Simulate initial loading time
    const timer = setTimeout(() => {
      setIsLoading(false)
    }, 1000)

    return () => clearTimeout(timer)
  }, [])

  const handleLoadingComplete = () => {
    setIsLoading(false)
  }

  // Show loading screen first
  if (isLoading) {
    return <LoadingScreen onLoadingComplete={handleLoadingComplete} minDisplayTime={2000} />
  }

  // Show main menu if not in a game
  if (gameMode === 'menu') {
    return <MainMenu />
  }

  // Show test page if in test mode
  if (gameMode === 'test') {
    return <TileSizeTestPage />
  }

  return (
    <div className="min-h-screen bg-slate-900 text-slate-100">
      {/* Header - Responsive with mobile optimizations */}
      <header className="px-4 py-3 border-b border-slate-800 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
        <h1 className="text-xl font-semibold text-center sm:text-left">HRmageddon</h1>
        <div className="flex flex-col sm:flex-row items-center gap-3 sm:gap-4">
          <div className="text-sm opacity-75 text-center sm:text-left">
            {gameMode === 'ai' ? 'Player vs AI' : 'Multiplayer'}
          </div>
          <button
            onClick={returnToMenu}
            className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm transition-colors w-full sm:w-auto"
          >
            Main Menu
          </button>
        </div>
      </header>

      <main className="p-2 sm:p-4">
        {phase === GamePhase.DRAFT ? (
          <DraftScreen />
        ) : phase === GamePhase.GAME_OVER ? (
          <div className="w-full max-w-2xl mx-auto text-center">
            <div className="bg-slate-800 rounded-lg border border-slate-700 p-6 sm:p-8">
              <h2 className="text-2xl sm:text-3xl font-bold mb-4">
                Game Over!
              </h2>
              <div className="text-lg sm:text-xl mb-6">
                {winner?.id === 'player1' ? (
                  <span className="text-blue-400">Blue Team Wins! ðM-^_M-^NM-^I</span>
                ) : winner?.id === 'player2' ? (
                  <span className="text-red-400">Red Team Wins! ðM-^_M-^NM-^I</span>
                ) : (
                  <span>Unknown Winner</span>
                )}
              </div>
              <button
                onClick={returnToMenu}
                className="px-6 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg text-lg font-semibold transition-colors w-full sm:w-auto"
              >
                Return to Main Menu
              </button>
            </div>
          </div>
        ) : (
          /* Game Layout - Mobile-first responsive design */
          <div className="w-full">
            {/* Mobile Layout: Stacked (Game Board on top, UI below) */}
            <div className="flex flex-col lg:hidden gap-4">
              {/* Game Board - Full width on mobile */}
              <div className="w-full flex justify-center">
                <GameView />
              </div>
              
              {/* Mobile GameHUD - Will be converted to bottom sheet */}
              <div className="w-full bg-slate-800 rounded-lg border border-slate-700 p-4">
                <GameHUD />
              </div>
            </div>
            
            {/* Desktop Layout: Flash Game Style (Game Board prioritized, integrated control panel) */}
            <div className="hidden lg:flex h-[calc(100vh-120px)] bg-slate-900 rounded-lg border-2 border-slate-700 overflow-hidden">
              {/* Left: Expanded Game Board - Scales with available space */}
              <div className="flex-1 p-4 flex items-center justify-center min-w-0">
                <GameView />
              </div>
              
              {/* Right: Unified Control Panel - Flash Game Style */}
              <div className="w-80 xl:w-96 bg-slate-800 border-l-2 border-slate-700 flex flex-col">
                <GameHUD />
              </div>
            </div>
          </div>
        )}
      </main>
    </div>
  )
}

===== ./src/main.tsx =====
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

===== ./src/test/setup.ts =====
// Test setup file for Vitest
import { vi } from 'vitest'

// Mock Phaser for tests
vi.mock('phaser', () => ({
  default: {
    Game: vi.fn(),
    Scene: vi.fn(),
    GameObjects: {
      Rectangle: vi.fn(),
      Text: vi.fn(),
      Image: vi.fn(),
      Sprite: vi.fn(),
      Container: vi.fn()
    },
    Input: {
      Keyboard: {
        KeyCodes: {
          SPACE: 32,
          ENTER: 13,
          ESC: 27
        }
      }
    },
    Scale: {
      FIT: 'FIT',
      RESIZE: 'RESIZE'
    }
  }
}))

// Mock React components that might cause issues in tests
vi.mock('react', async () => {
  const actual = await vi.importActual('react')
  return {
    ...actual,
    useEffect: vi.fn(),
    useState: vi.fn(),
    useCallback: vi.fn(),
    useMemo: vi.fn()
  }
})

// Global test utilities
global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}))

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(), // deprecated
    removeListener: vi.fn(), // deprecated
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
})

===== ./src/config/uiConfig.ts =====
// ===== UI CONFIGURATION =====
export const UI_CONFIG = {
  // Menu Positioning
  MENU: {
    WIDTH: 350,
    HEIGHT: 400,
    OFFSET_X: 50,
    OFFSET_Y: 50,
    MIN_MARGIN: 20,
  },
  // Colors (Tailwind-style for easy swapping)
  COLORS: {
    BACKGROUND: 'bg-stone-100',
    BORDER: 'border-stone-300',
    TEXT: {
      PRIMARY: 'text-stone-800',
      SECONDARY: 'text-stone-600',
      WARNING: 'text-amber-600',
      ERROR: 'text-red-600',
      SUCCESS: 'text-green-600',
      ACCENT: 'text-amber-600',
    },
    BUTTONS: {
      MOVE: {
        AVAILABLE: 'bg-stone-600 hover:bg-stone-700 border-stone-500 text-white',
        DISABLED: 'bg-stone-200 border-stone-300 text-stone-400',
      },
      ATTACK: {
        AVAILABLE: 'bg-red-600 hover:bg-red-700 border-red-500 text-white',
        DISABLED: 'bg-stone-200 border-stone-300 text-stone-400',
      },
      ABILITY: {
        AVAILABLE: 'bg-amber-600 hover:bg-amber-700 border-amber-500 text-white',
        DISABLED: 'bg-stone-200 border-stone-300 text-stone-400',
      },
      CLOSE: 'bg-stone-500 hover:bg-stone-600 border-stone-400 text-white',
    },
    STATUS_BADGES: {
      READY: 'bg-green-600 text-white',
      UNAVAILABLE: 'bg-red-600 text-white',
    }
  },
  // Text Content
  TEXT: {
    HEADERS: {
      ACTIONS: 'Actions',
      ACTION_MODE_WARNING: 'ðM-^_M-^N¯ Action mode active - complete your action before selecting other units',
    },
    BUTTONS: {
      MOVE: 'Move Employee',
      ATTACK: 'Attack',
      CLOSE: 'Close',
    },
    STATUS: {
      READY: 'READY',
      UNAVAILABLE: 'UNAVAILABLE',
    }
  },
  // Animation & Timing
  ANIMATION: {
    BUTTON_PRESS_SCALE: 0.95,
    BUTTON_PRESS_DURATION: 150,
    TRANSITION_DURATION: 'duration-200',
  },
  // Action Menu Configuration
  ACTION_MENU: {
    STYLE: {
      BACKGROUND: 'bg-yellow-200',
      BORDER: 'border-2 border-black',
      TEXT: 'text-black',
      HOVER: 'hover:bg-yellow-300',
      END_BUTTON: 'bg-pink-200 hover:bg-pink-300',
      SEPARATOR: 'border-black',
    },
    POSITIONING: {
      OFFSET: 20,
      MARGIN: 10,
      MIN_WIDTH: 140,
    },
    FONT: {
      FAMILY: 'serif',
      SIZE: '14px',
    }
  }
}
// ===== END CONFIGURATION =====

===== ./src/config/hudConfig.ts =====
// ===== HUD CONFIGURATION =====
export const HUD_CONFIG = {
  // Panel Positioning & Sizing
  PANELS: {
    STATUS: {
      POSITION: 'fixed top-4 left-4',
      WIDTH: 'w-80',
      MAX_HEIGHT: 'max-h-[calc(100vh-2rem)]',
    },
    UNIT_INFO: {
      POSITION: 'fixed top-4 right-4',
      WIDTH: 'w-80',
      MAX_HEIGHT: 'max-h-[calc(100vh-2rem)]',
    }
  },
  // Colors
  COLORS: {
    PANELS: {
      BACKGROUND: 'bg-stone-50/95',
      BORDER: 'border-stone-300',
      BACKDROP: 'backdrop-blur-sm',
    },
    TEXT: {
      PRIMARY: 'text-stone-800',
      SECONDARY: 'text-stone-600',
      ACCENT: 'text-amber-600',
      SUCCESS: 'text-green-600',
      WARNING: 'text-amber-600',
      ERROR: 'text-red-600',
    },
    TEAMS: {
      PLAYER1: {
        BACKGROUND: 'bg-amber-50/80',
        BORDER: 'border-amber-300',
        TEXT: 'text-amber-700',
      },
      PLAYER2: {
        BACKGROUND: 'bg-stone-100/80',
        BORDER: 'border-stone-300',
        TEXT: 'text-stone-700',
      }
    },
    BUTTONS: {
      END_TURN: 'bg-green-600 hover:bg-green-700 text-white',
      CANCEL: 'bg-stone-500 hover:bg-stone-600 text-white',
    },
    ACTION_MODES: {
      MOVE: {
        BACKGROUND: 'bg-stone-100/80',
        BORDER: 'border-stone-400',
        TEXT: 'text-stone-700',
      },
      ATTACK: {
        BACKGROUND: 'bg-red-50/80',
        BORDER: 'border-red-300',
        TEXT: 'text-red-700',
      },
      ABILITY: {
        BACKGROUND: 'bg-amber-50/80',
        BORDER: 'border-amber-300',
        TEXT: 'text-amber-700',
      }
    }
  },
  // Feedback Messages
  FEEDBACK: {
    DURATION: 2000, // ms
    POSITION: 'fixed top-20 left-1/2 transform -translate-x-1/2 z-50',
  },
  // Text Content
  TEXT: {
    TURN_INDICATOR: {
      YOUR_TURN: 'Your Turn (Gold)',
      AI_TURN: 'AI Turn (Navy)',
    },
    UNIT_STATUS: {
      CONTROLLING: 'ðM-^_M-^N® Controlling',
      VIEWING: 'ðM-^_M-^SM-^V Viewing Only',
    },
    ACTION_MODES: {
      MOVE: 'ðM-^_M-^Z¶ Move Mode Active',
      ATTACK: 'ðM-^_M-^N¯ Attack Mode Active',
      ABILITY: 'âM-^Z¡ Ability Mode Active',
    }
  }
}
// ===== END CONFIGURATION =====

===== ./src/App.css =====
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

===== ./src/stores/actionHandlers.ts =====
import { useGameStore } from './gameStore'
import { useUIStore } from './uiStore'
import { useUnitStore } from './unitStore'
import { useBoardStore } from './boardStore'
import { getAbilityById, getValidTargets } from '../game/core/abilities'
import { dataManager } from '../game/data/DataManager'
import { type Unit, type Coordinate } from 'shared'

/**
 * Action handlers that coordinate between UI store and game store
 * This creates a clean separation between UI state and game logic
 */

// Helper function to get range tiles from attack pattern
function getRangeTilesFromPattern(unit: Unit, patternKey: string): Coordinate[] {
  const attackPattern = dataManager.getAttackPattern(patternKey)
  if (!attackPattern) return []
  
  const rangeTiles: Coordinate[] = []
  const patternCenterX = Math.floor(attackPattern.pattern[0].length / 2)
  const patternCenterY = Math.floor(attackPattern.pattern.length / 2)
  
  for (let row = 0; row < attackPattern.pattern.length; row++) {
    for (let col = 0; col < attackPattern.pattern[row].length; col++) {
      const patternValue = attackPattern.pattern[row][col]
      if (patternValue === 1 || patternValue === 2) { // 1 = range, 2 = center
        const relativeX = col - patternCenterX
        const relativeY = row - patternCenterY
        const targetX = unit.position.x + relativeX
        const targetY = unit.position.y + relativeY
        
        // Check if tile is within board bounds
        const boardState = useBoardStore.getState()
        if (targetX >= 0 && targetX < boardState.board[0].length && 
            targetY >= 0 && targetY < boardState.board.length) {
          rangeTiles.push({ x: targetX, y: targetY })
        }
      }
    }
  }
  
  return rangeTiles
}

export const actionHandlers = {
  /**
   * Enter move mode - calculate possible moves and highlight them
   */
  enterMoveMode: (unit: Unit) => {
    const gameStore = useGameStore.getState()
    const uiStore = useUIStore.getState()
    
    // Calculate possible moves
    const moves = gameStore.calculatePossibleMoves(unit)
    
    // Create highlights map
    const highlights = new Map<string, string>()
    moves.forEach(move => highlights.set(`${move.x},${move.y}`, 'movement'))
    
    // Update UI state
    uiStore.setActionMode('move')
    uiStore.setHighlightedTiles(highlights)
    
    console.log('Entered move mode:', { unitId: unit.id, moveCount: moves.length })
  },

  /**
   * Enter attack mode - calculate possible targets and highlight them
   */
  enterAttackMode: (unit: Unit) => {
    const gameStore = useGameStore.getState()
    const uiStore = useUIStore.getState()
    
    // Calculate possible targets
    const targets = gameStore.calculatePossibleTargets(unit)
    
    // Determine attack pattern based on unit's attack range
    let patternKey = 'single_target_melee' // Default
    if (unit.attackRange > 1) {
      patternKey = 'single_target_ranged'
    }
    
    // Get range pattern for attack based on unit's actual range
    const rangeTiles = getRangeTilesFromPattern(unit, patternKey)
    
    // Create highlights map with both range and target highlights
    const highlights = new Map<string, string>()
    
    // Add range highlights (light blue/gray)
    rangeTiles.forEach(tile => highlights.set(`${tile.x},${tile.y}`, 'range'))
    
    // Add target highlights (red) for valid targets
    targets.forEach(target => highlights.set(`${target.x},${target.y}`, 'target'))
    
    // Update UI state
    uiStore.setActionMode('attack')
    uiStore.setHighlightedTiles(highlights)
    
    console.log('Entered attack mode:', { unitId: unit.id, attackRange: unit.attackRange, patternKey, targetCount: targets.length, rangeCount: rangeTiles.length })
  },

  /**
   * Enter ability mode - calculate valid targets and highlight them
   */
  enterAbilityMode: (unit: Unit, abilityId: string) => {
    const uiStore = useUIStore.getState()
    
    try {
      const ability = getAbilityById(abilityId, unit)
      
      // Check if this is a directional ability
      if (ability.requiresDirection) {
        uiStore.setAbilityAwaitingDirection(abilityId)
        uiStore.setActionMode('ability')
        uiStore.setSelectedAbility(abilityId)
        console.log('Entered directional ability mode:', { abilityId, unitId: unit.id })
        return
      }
      
      // Calculate valid targets for the ability
      const unitState = useUnitStore.getState()
      const boardState = useBoardStore.getState()
      const validTargets = getValidTargets(unit, ability, boardState.board, unitState.units)
      
      // Get range pattern for ability
      const rangeTiles = getRangeTilesFromPattern(unit, ability.range_pattern_key || 'single_target_melee')
      
      // Create highlights map with both range and target highlights
      const highlights = new Map<string, string>()
      
      // Add range highlights (light blue/gray)
      rangeTiles.forEach(tile => highlights.set(`${tile.x},${tile.y}`, 'range'))
      
      // Add target highlights (purple) for valid targets
      validTargets.forEach(target => {
        if ('x' in target) {
          highlights.set(`${target.x},${target.y}`, 'target')
        } else {
          highlights.set(`${target.position.x},${target.position.y}`, 'target')
        }
      })
      
      // Update UI state
      uiStore.setActionMode('ability')
      uiStore.setSelectedAbility(abilityId)
      uiStore.setHighlightedTiles(highlights)
      
      console.log('Entered ability mode:', { abilityId, unitId: unit.id, targetCount: validTargets.length, rangeCount: rangeTiles.length })
    } catch (error) {
      console.error('Failed to enter ability mode:', error)
      // FUTURE STEP: We could add UI feedback here, e.g., uiStore.setErrorMessage(error.message)
      return // Stop the action
    }
  },

  /**
   * Execute a move action
   */
  executeMove: (unit: Unit, target: Coordinate) => {
    const gameStore = useGameStore.getState()
    const uiStore = useUIStore.getState()
    
    // Execute the move
    gameStore.moveUnit(unit.id, target)
    
    // Clear action mode
    uiStore.clearActionMode()
    
    console.log('Executed move:', { unitId: unit.id, target })
  },

  /**
   * Execute an attack action
   */
  executeAttack: (attacker: Unit, target: Unit) => {
    const gameStore = useGameStore.getState()
    const uiStore = useUIStore.getState()
    
    // Execute the attack
    gameStore.attackTarget(attacker.id, target.id)
    
    // Clear action mode
    uiStore.clearActionMode()
    
    console.log('Executed attack:', { attackerId: attacker.id, targetId: target.id })
  },

  /**
   * Execute an ability action
   */
  executeAbility: (unit: Unit, abilityId: string, target?: Unit | Coordinate) => {
    const gameStore = useGameStore.getState()
    const uiStore = useUIStore.getState()
    
    // Execute the ability
    gameStore.useAbility(unit.id, abilityId, target)
    
    // Clear action mode
    uiStore.clearActionMode()
    
    console.log('Executed ability:', { unitId: unit.id, abilityId, target })
  },

  /**
   * Cancel current action
   */
  cancelAction: () => {
    const uiStore = useUIStore.getState()
    uiStore.clearActionMode()
    console.log('Cancelled action')
  }
}

===== ./src/stores/unitStore.ts =====
import { create } from 'zustand'
import { type Unit, type Coordinate } from 'shared'

interface UnitStore {
  // State - Single Source of Truth for Units
  units: Unit[]
  selectedUnit: Unit | undefined

  // Actions
  setUnits: (units: Unit[]) => void
  selectUnit: (unit: Unit | null) => void
  updateUnit: (unitId: string, updates: Partial<Unit>) => void
  removeUnit: (unitId: string) => void
  resetAllUnitActions: (playerId: string) => void
  
  // Queries
  getUnitById: (unitId: string) => Unit | undefined
  getUnitAt: (coord: Coordinate) => Unit | undefined
  getUnitsByPlayer: (playerId: string) => Unit[]
  getEnemyUnits: (playerId: string) => Unit[]
  getUnitsInRange: (position: Coordinate, range: number) => Unit[]
}

export const useUnitStore = create<UnitStore>((set, get) => ({
  // Initial state
  units: [],
  selectedUnit: undefined,

  // Actions
  setUnits: (units) => {
    set({ units })
  },

  selectUnit: (unit) => {
    set({ selectedUnit: unit || undefined })
  },

  updateUnit: (unitId, updates) => {
    set((state) => {
      const newUnits = state.units.map((unit) =>
        unit.id === unitId ? { ...unit, ...updates } : unit
      )

      const newSelectedUnit = state.selectedUnit?.id === unitId
        ? { ...state.selectedUnit, ...updates }
        : state.selectedUnit

      console.log('unitStore: updateUnit called.', { unitId, updates, newSelectedUnitActions: newSelectedUnit?.actionsRemaining })

      return {
        units: newUnits,
        selectedUnit: newSelectedUnit,
      }
    })
  },

  removeUnit: (unitId) => {
    set((state) => ({
      units: state.units.filter((unit) => unit.id !== unitId),
      // Clear selectedUnit if it's the one being removed
      selectedUnit: state.selectedUnit?.id === unitId 
        ? undefined 
        : state.selectedUnit
    }))
  },

  resetAllUnitActions: (playerId) => {
    set((state) => ({
      units: state.units.map((unit) =>
        unit.playerId === playerId
          ? {
              ...unit,
              actionsRemaining: unit.maxActions,
              hasMoved: false,
              hasAttacked: false,
              movementUsed: 0,
              remainingMovement: unit.moveRange
            }
          : unit
      )
    }))
  },

  // Queries
  getUnitById: (unitId) => {
    return get().units.find((unit) => unit.id === unitId)
  },

  getUnitAt: (coord) => {
    return get().units.find((unit) => 
      unit.position.x === coord.x && unit.position.y === coord.y
    )
  },

  getUnitsByPlayer: (playerId) => {
    return get().units.filter((unit) => unit.playerId === playerId)
  },

  getEnemyUnits: (playerId) => {
    return get().units.filter((unit) => unit.playerId !== playerId)
  },

  getUnitsInRange: (position, range) => {
    return get().units.filter((unit) => {
      const distance = Math.abs(unit.position.x - position.x) + 
                     Math.abs(unit.position.y - position.y)
      return distance <= range
    })
  }
}))

===== ./src/stores/gameStore.ts =====
import { create } from 'zustand'
import {
  GamePhase,
  type Unit,
  type Coordinate,
  type Tile,
  TileType,
  UnitType,
  type DraftState,
  StatusType,
} from 'shared'
import { AIController } from '../game/ai/ai.ts'
import { generateAIDraft } from '../game/ai/aiDraft.ts'
import { canUseAbility, getValidTargets, getAbilityById } from '../game/core/abilities.ts'
import { mapRegistry } from '../game/map/MapRegistry'
import { MAPS } from '../game/map/registry'
import { calculatePossibleMoves as calcMoves, isValidMove as isValidMoveUtil, getDistance, getDirection } from '../game/core/movement'
import { calculatePossibleTargets as calcTargets, isValidAttack as isValidAttackUtil, calculateDamage } from '../game/core/combat'
import { checkVictoryConditions as checkVictory } from '../game/core/victory'
import { useUnitStore } from './unitStore'
import { useBoardStore } from './boardStore'
import { usePlayerStore } from './playerStore'
import { useUIStore } from './uiStore'
import { dataManager } from '../game/data/DataManager'
import { actionHandlers } from './actionHandlers'

// Type for window.gameScene
interface GameScene {
  tileToWorld: (x: number, y: number) => { x: number; y: number }
}

// Extended window interface
interface ExtendedWindow extends Window {
  gameScene?: GameScene
}

// Helper functions for memoization


function getCachedPossibleMoves(unit: Unit, cache: MemoizationCache, calculateFn: () => Coordinate[]): Coordinate[] {
  const key = `${unit.id}-${unit.position.x}-${unit.position.y}-${unit.actionsRemaining}-${unit.hasMoved}`
  
  if (!cache.possibleMoves.has(key)) {
    const moves = calculateFn()
    cache.possibleMoves.set(key, moves)
  }
  
  return cache.possibleMoves.get(key)!
}

function getCachedPossibleTargets(unit: Unit, cache: MemoizationCache, calculateFn: () => Coordinate[]): Coordinate[] {
  const key = `${unit.id}-${unit.position.x}-${unit.position.y}-${unit.actionsRemaining}-${unit.hasAttacked}`
  
  if (!cache.possibleTargets.has(key)) {
    const targets = calculateFn()
    cache.possibleTargets.set(key, targets)
  }
  
  return cache.possibleTargets.get(key)!
}

function clearMemoizationCache(cache: MemoizationCache) {
  cache.possibleMoves.clear()
  cache.possibleTargets.clear()
  cache.cubicleCount = null
  cache.cubiclePositions = null
  cache.lastBoardHash = null
}


type GameMode = 'menu' | 'ai' | 'multiplayer' | 'test'

// Memoization cache for expensive calculations
interface MemoizationCache {
  possibleMoves: Map<string, Coordinate[]>
  possibleTargets: Map<string, Coordinate[]>
  cubicleCount: number | null
  cubiclePositions: Coordinate[] | null
  lastBoardHash: string | null
}

type GameStore = {
  // Orchestrator-specific state only
  gameMode: GameMode
  draftState: DraftState
  pendingCubicleCaptures: Map<string, { unitId: string; coord: Coordinate; playerId: string }>
  memoCache: MemoizationCache

  // Orchestrator actions
  setGameMode: (mode: GameMode) => void
  enterTestMode: () => void
  initializeGame: () => void
  initializeDraft: () => void
  addUnitToDraft: (employeeKey: string) => void
  removeUnitFromDraft: (index: number) => void
  confirmDraft: () => void
  selectUnit: (unit: Unit | undefined | null) => void
  selectTile: (coord: Coordinate) => void
  moveUnit: (unitId: string, to: Coordinate) => void
  attackTarget: (attackerId: string, targetId: string) => void
  captureCubicle: (unitId: string, coord: Coordinate) => void
  endTurn: () => void
  executeAITurn: () => void
  returnToMenu: () => void

  // Pure utility functions (delegated to core modules)
  getUnitAt: (coord: Coordinate) => Unit | undefined
  getTileAt: (coord: Coordinate) => Tile | undefined
  calculatePossibleMoves: (unit: Unit) => Coordinate[]
  calculatePossibleTargets: (unit: Unit) => Coordinate[]
  isValidMove: (unit: Unit, to: Coordinate) => boolean
  isValidAttack: (attacker: Unit, target: Unit) => boolean
  checkVictoryConditions: () => void
  
  // Ability system methods
  useAbility: (unitId: string, abilityId: string, target?: Unit | Coordinate) => void
  getAbilityTargets: (unitId: string, abilityId: string) => (Unit | Coordinate)[]
  canUseAbility: (unitId: string, abilityId: string) => boolean
  
  // Helper functions for smart action availability
  canUnitMove: (unit: Unit) => boolean
  canUnitAttack: (unit: Unit) => boolean
  getEnemiesInRange: (unit: Unit) => Unit[]
  getRemainingMovement: (unit: Unit) => number
  canSelectUnit: (unit: Unit, currentlySelected?: Unit) => boolean
  shouldExecuteActionInsteadOfSelect: (unit: Unit, currentlySelected?: Unit) => boolean
  shouldExecuteMoveInsteadOfSelect: (unit: Unit, currentlySelected?: Unit) => boolean
  isValidAttackTarget: (attacker: Unit, target: Unit) => boolean
}

export const useGameStore = create<GameStore>((set, get) => {
  return {
  // Orchestrator-specific state only
  gameMode: 'menu',
  draftState: {
    playerBudget: 200,
    maxHeadcount: 6,
    selectedUnits: [],
    aiUnits: [],
  },
  pendingCubicleCaptures: new Map(),
  memoCache: {
    possibleMoves: new Map(),
    possibleTargets: new Map(),
    cubicleCount: null,
    cubiclePositions: null,
    lastBoardHash: null
  },

  setGameMode: (mode) => {
    set({ gameMode: mode })
  },

  enterTestMode: () => {
    set({ gameMode: 'test' })
  },

  returnToMenu: () => {
    // Reset orchestrator state
    set({
      gameMode: 'menu',
      pendingCubicleCaptures: new Map(),
      draftState: {
        playerBudget: 200,
        maxHeadcount: 6,
        selectedUnits: [],
        aiUnits: [],
      },
    })
    
    // Reset all slice stores
    useUnitStore.getState().setUnits([])
    useUnitStore.getState().selectUnit(null)
    useBoardStore.getState().setBoard([])
    usePlayerStore.getState().setPlayers([])
    usePlayerStore.getState().setCurrentPlayerId('')
    usePlayerStore.getState().setTurnNumber(1)
    usePlayerStore.getState().setPhase(GamePhase.SETUP)
    // Don't set winner to undefined, just clear it
    // usePlayerStore.getState().setWinner(undefined)
    useUIStore.getState().clearActionMode()
  },

  initializeGame: () => {
    // Initialize board and players through slice stores
    useBoardStore.getState().createBoard()
    usePlayerStore.getState().initializePlayers()
    
    // Get starting positions from the MapRegistry
    const getMapStartingPositions = (teamId: string): Coordinate[] => {
      try {
        const startingPositions = mapRegistry.getStartingPositions('OfficeLayout')
        if (!startingPositions) {
          console.warn('Starting positions not available in MapRegistry, using fallback positions')
          return getFallbackStartPositions(teamId)
        }
        
        if (teamId === 'player1') {
          return startingPositions.goldTeam?.map((pos: { x: number; y: number }) => ({ x: pos.x, y: pos.y })) || []
        } else {
          return startingPositions.navyTeam?.map((pos: { x: number; y: number }) => ({ x: pos.x, y: pos.y })) || []
        }
      } catch (error) {
        console.warn('Error getting map starting positions from MapRegistry, using fallback:', error)
        return getFallbackStartPositions(teamId)
      }
    }
    
    // Fallback starting positions if map data isn't available
    const getFallbackStartPositions = (teamId: string): Coordinate[] => {
      const mapSpec = MAPS['OfficeLayout']
      const boardWidth = mapSpec.width
      const boardHeight = mapSpec.height
      
      if (teamId === 'player1') {
        return [
          { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0 },
          { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 },
        ]
      } else {
        return [
          { x: boardWidth - 1, y: boardHeight - 1 }, 
          { x: boardWidth - 2, y: boardHeight - 1 }, 
          { x: boardWidth - 3, y: boardHeight - 1 },
          { x: boardWidth - 1, y: boardHeight - 2 }, 
          { x: boardWidth - 2, y: boardHeight - 2 }, 
          { x: boardWidth - 3, y: boardHeight - 2 },
        ]
      }
    }
    
    // Create units using map starting positions
    const playerPositions = getMapStartingPositions('player1')
    const aiPositions = getMapStartingPositions('player2')
    
    // Create units using DataManager
    const units: Unit[] = []
    
    // Get employee data from DataManager
    const internEmployee = dataManager.getEmployee('salesman') // Using salesman as intern for now
    const secretaryEmployee = dataManager.getEmployee('secretary')
    
    if (internEmployee && secretaryEmployee) {
      // Player units (Gold team)
      units.push(
        dataManager.createUnitFromEmployee(
          internEmployee, 
          'blue-intern-1', 
          'player1', 
          playerPositions[0] || { x: 0, y: 1 }
        )
      )
      units.push(
        dataManager.createUnitFromEmployee(
          secretaryEmployee, 
          'blue-secretary-1', 
          'player1', 
          playerPositions[1] || { x: 1, y: 1 }
        )
      )
      
      // AI units (Navy team)
      units.push(
        dataManager.createUnitFromEmployee(
          internEmployee, 
          'red-intern-1', 
          'player2', 
          aiPositions[0] || { x: 7, y: 8 }
        )
      )
      units.push(
        dataManager.createUnitFromEmployee(
          secretaryEmployee, 
          'red-secretary-1', 
          'player2', 
          aiPositions[1] || { x: 6, y: 8 }
        )
      )
    } else {
      console.error('Failed to load employee data from DataManager')
      // Fallback to basic units if data loading failed
      units.push({
        id: 'blue-intern-1',
        playerId: 'player1',
        type: UnitType.INTERN,
        position: playerPositions[0] || { x: 0, y: 1 },
        hp: 2,
        maxHp: 2,
        moveRange: 3,
        attackRange: 1,
        attackDamage: 1,
        actionsRemaining: 2,
        maxActions: 2,
        status: [],
        cost: 2,
        hasMoved: false,
        hasAttacked: false,
        abilities: [],
        abilityCooldowns: {},
        movementUsed: 0,
        remainingMovement: 3,
        direction: 'down',
      })
    }

    // Set units through unit store
    useUnitStore.getState().setUnits(units)
    
    // Clear memoization cache
    clearMemoizationCache(get().memoCache)
  },

  initializeDraft: () => {
    const config = dataManager.getConfig()
    const budget = config.draft_config?.starting_funds || 1000
    const maxHeadcount = config.gameplay_rules?.max_team_size || 4
    
    const aiUnits = generateAIDraft(budget, maxHeadcount)
    set((state) => ({
      draftState: {
        ...state.draftState,
        playerBudget: budget,
        maxHeadcount,
        aiUnits,
      }
    }))
    usePlayerStore.getState().setPhase(GamePhase.DRAFT)
  },

  addUnitToDraft: (employeeKey) => {
    const state = get()
    const employee = dataManager.getEmployee(employeeKey)
    if (!employee) {
      console.error(`Employee not found: ${employeeKey}`)
      return
    }
    
    const cost = employee.cost
    const currentCost = state.draftState.selectedUnits.reduce((sum, unit) => {
      const unitEmployee = dataManager.getEmployee(unit.employeeKey)
      return sum + (unitEmployee?.cost || 0)
    }, 0)
    
    if (state.draftState.selectedUnits.length >= state.draftState.maxHeadcount) return
    if (currentCost + cost > state.draftState.playerBudget) return
    
    set((state) => ({
      draftState: {
        ...state.draftState,
        selectedUnits: [...state.draftState.selectedUnits, { employeeKey }]
      }
    }))
  },

  removeUnitFromDraft: (index) => {
    set((state) => ({
      draftState: {
        ...state.draftState,
        selectedUnits: state.draftState.selectedUnits.filter((_, i) => i !== index)
      }
    }))
  },

  confirmDraft: () => {
    const state = get()
    if (state.draftState.selectedUnits.length === 0) return
    
    // Get starting positions from the MapRegistry
    const getMapStartingPositions = (teamId: string): Coordinate[] => {
      try {
        const startingPositions = mapRegistry.getStartingPositions('OfficeLayout')
        if (!startingPositions) {
          console.warn('Starting positions not available in MapRegistry, using fallback positions')
          return getFallbackStartPositions(teamId)
        }
        
        if (teamId === 'player1') {
          return startingPositions.goldTeam?.map((pos: { x: number; y: number }) => ({ x: pos.x, y: pos.y })) || []
        } else {
          return startingPositions.navyTeam?.map((pos: { x: number; y: number }) => ({ x: pos.x, y: pos.y })) || []
        }
      } catch (error) {
        console.warn('Error getting map starting positions from MapRegistry, using fallback:', error)
        return getFallbackStartPositions(teamId)
      }
    }
    
    // Fallback starting positions if map data isn't available
    const getFallbackStartPositions = (teamId: string): Coordinate[] => {
      const mapSpec = MAPS['OfficeLayout']
      const boardWidth = mapSpec.width
      const boardHeight = mapSpec.height
      
      if (teamId === 'player1') {
        return [
          { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0 },
          { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 },
        ]
      } else {
        return [
          { x: boardWidth - 1, y: boardHeight - 1 }, 
          { x: boardWidth - 2, y: boardHeight - 1 }, 
          { x: boardWidth - 3, y: boardHeight - 1 },
          { x: boardWidth - 1, y: boardHeight - 2 }, 
          { x: boardWidth - 2, y: boardHeight - 2 }, 
          { x: boardWidth - 3, y: boardHeight - 2 },
        ]
      }
    }
    
    // Create units from draft selections
    const playerPositions = getMapStartingPositions('player1')
    const aiPositions = getMapStartingPositions('player2')
    
    const playerUnits: Unit[] = state.draftState.selectedUnits.map((draftUnit, index) => {
      const employee = dataManager.getEmployee(draftUnit.employeeKey)
      if (!employee) {
        console.error(`Employee not found: ${draftUnit.employeeKey}`)
        // Fallback to basic unit
      return {
          id: `player1-${draftUnit.employeeKey}-${index}`,
        playerId: 'player1',
          type: UnitType.INTERN,
        position: playerPositions[index] || { x: 0, y: 0 },
          hp: 2,
          maxHp: 2,
          moveRange: 3,
          attackRange: 1,
          attackDamage: 1,
          actionsRemaining: 2,
          maxActions: 2,
        status: [],
        hasMoved: false,
        hasAttacked: false,
          cost: 2,
          abilities: [],
        abilityCooldowns: {},
        movementUsed: 0,
          remainingMovement: 3,
          direction: 'down',
        }
      }
      
      return dataManager.createUnitFromEmployee(
        employee,
        `player1-${draftUnit.employeeKey}-${index}`,
        'player1',
        playerPositions[index] || { x: 0, y: 0 }
      )
    })
    
    const aiUnits: Unit[] = state.draftState.aiUnits.map((draftUnit, index) => {
      const employee = dataManager.getEmployee(draftUnit.employeeKey)
      if (!employee) {
        console.error(`Employee not found: ${draftUnit.employeeKey}`)
        // Fallback to basic unit
      return {
          id: `player2-${draftUnit.employeeKey}-${index}`,
        playerId: 'player2',
          type: UnitType.INTERN,
        position: aiPositions[index] || { x: 7, y: 9 },
          hp: 2,
          maxHp: 2,
          moveRange: 3,
          attackRange: 1,
          attackDamage: 1,
          actionsRemaining: 2,
          maxActions: 2,
        status: [],
        hasMoved: false,
        hasAttacked: false,
          cost: 2,
          abilities: [],
        abilityCooldowns: {},
        movementUsed: 0,
          remainingMovement: 3,
          direction: 'down',
        }
      }
      
      return dataManager.createUnitFromEmployee(
        employee,
        `player2-${draftUnit.employeeKey}-${index}`,
        'player2',
        aiPositions[index] || { x: 7, y: 9 }
      )
    })
    
    // Initialize the game with drafted units
    useBoardStore.getState().createBoard()
    usePlayerStore.getState().initializePlayers()
    useUnitStore.getState().setUnits([...playerUnits, ...aiUnits])
    
    // Set game mode to 'ai' after draft confirmation
    set({ gameMode: 'ai' })
    
    // Clear memoization cache
    clearMemoizationCache(get().memoCache)
  },

  selectUnit: (unit) => {
    const unitStore = useUnitStore.getState()
    const uiStore = useUIStore.getState()
    const playerStore = usePlayerStore.getState()

    if (!unit) {
      unitStore.selectUnit(null)
      uiStore.clearActionMode() // Use clearActionMode for a full reset
      return
    }

    // --- START OF CRITICAL FIX ---

    // Select the unit in the unitStore
    unitStore.selectUnit(unit)
    uiStore.clearHighlights()

    // Check if the selected unit can be controlled
    const isPlayerUnit = unit.playerId === playerStore.currentPlayerId
    const canControl = isPlayerUnit && unit.actionsRemaining > 0

    if (canControl) {
      // If it can be controlled, tell the GameScene to position the action menu
      if (typeof window !== 'undefined' && (window as ExtendedWindow).gameScene) {
        console.log(`Setting action menu position for unit: ${unit.id}`)
        const scene = (window as ExtendedWindow).gameScene!
        const screenPos = scene.tileToWorld(unit.position.x, unit.position.y)
        uiStore.setActionMenu(screenPos)
      }
    } else {
      // If the unit can't be controlled (e.g., an enemy unit or no actions left), ensure the menu is hidden.
      uiStore.setActionMenu(null)
    }
    // --- END OF CRITICAL FIX ---
  },

  selectTile: (coord) => {
    const unitStore = useUnitStore.getState()
    const unitAtCoord = unitStore.getUnitAt(coord)

    if (unitAtCoord) {
      // If a tile with a unit is clicked, defer to the selectUnit logic.
      get().selectUnit(unitAtCoord)
    } else {
      // If an empty tile is clicked, deselect the current unit.
      console.log('Empty tile clicked, deselecting unit.')
      get().selectUnit(null)
    }
  },

  moveUnit: (unitId, to) => {
    // Get current state from slice stores
    const unitStore = useUnitStore.getState()
    const boardStore = useBoardStore.getState()
    const uiStore = useUIStore.getState()
    
    const unit = unitStore.getUnitById(unitId)
    if (!unit || !get().isValidMove(unit, to)) return

    // Calculate the distance of this move
    const moveDistance = getDistance(unit.position, to)
    const newRemainingMovement = unit.remainingMovement - moveDistance
    
    console.log('Moving unit:', {
      unitId,
      from: unit.position,
      to,
      moveDistance,
      remainingMovement: unit.remainingMovement,
      newRemainingMovement,
      actionsRemaining: unit.actionsRemaining
    })

    // Update unit position and movement
    const updates: Partial<Unit> = { 
      position: to,
      remainingMovement: newRemainingMovement
    }
    
    // Only consume an action point if movement is exhausted
    if (newRemainingMovement <= 0) {
      updates.actionsRemaining = unit.actionsRemaining - 1
      updates.hasMoved = true
    }
    
    unitStore.updateUnit(unitId, updates)

    // --- START OF CRITICAL FIX ---
    const finalUnitState = useUnitStore.getState().getUnitById(unitId)
    if (finalUnitState && finalUnitState.actionsRemaining <= 0) {
      console.log(`Unit ${unitId} has no actions left. Deselecting.`)
      useUnitStore.getState().selectUnit(null)
    }
    // --- END OF CRITICAL FIX ---

      // Clear memoization cache when units move
    clearMemoizationCache(get().memoCache)

      // Check if the unit landed on a cubicle for potential capture
    const targetTile = boardStore.getTileAt(to)
      if (targetTile && targetTile.type === TileType.CUBICLE) {
        console.log('Unit landed on cubicle:', {
          unitId,
          unitPlayer: unit.playerId,
          tilePosition: to,
          tileOwner: targetTile.owner,
          tileType: targetTile.type
        })
        
        // If the cubicle is not owned by this unit's player, add to pending captures
        if (targetTile.owner !== unit.playerId) {
          const captureKey = `${to.x},${to.y}`
        set((state) => {
          const updatedPendingCaptures = new Map(state.pendingCubicleCaptures)
          updatedPendingCaptures.set(captureKey, {
            unitId,
            coord: to,
            playerId: unit.playerId
          })
          return { pendingCubicleCaptures: updatedPendingCaptures }
          })
          
          console.log('Added to pending captures:', {
            captureKey,
          pendingCapturesCount: get().pendingCubicleCaptures.size
        })
      }
    }

    // Get updated unit for selection logic
    const updatedUnit = unitStore.getUnitById(unitId)
    const shouldKeepSelected = updatedUnit && updatedUnit.actionsRemaining > 0
    
    if (shouldKeepSelected) {
      unitStore.selectUnit(updatedUnit)
    } else {
      unitStore.selectUnit(null)
    }

    // Clear UI highlights
    uiStore.clearHighlights()

      // Emit action completed event for UI cleanup
      if (typeof window !== 'undefined') {
        const event = new CustomEvent('actionCompleted', {
        detail: { actionType: 'move', unitId, remainingActions: updatedUnit?.actionsRemaining || 0 }
        })
        window.dispatchEvent(event)
      }
  },

  attackTarget: (attackerId, targetId) => {
    // Get current state from slice stores
    const unitStore = useUnitStore.getState()
    const uiStore = useUIStore.getState()
    
    const attacker = unitStore.getUnitById(attackerId)
    const target = unitStore.getUnitById(targetId)
    
    if (!attacker || !target || !get().isValidAttack(attacker, target)) return

    // Calculate direction from attacker to target
    const direction = getDirection(attacker.position, target.position)
    const damage = calculateDamage(attacker, target)

    // Update attacker with new direction
    unitStore.updateUnit(attackerId, { 
      actionsRemaining: attacker.actionsRemaining - 1, 
      hasAttacked: true,
      direction: direction
    })

    // Update target
    const newHp = Math.max(0, target.hp - damage)
    if (newHp > 0) {
      unitStore.updateUnit(targetId, { hp: newHp })
    } else {
      unitStore.removeUnit(targetId)
    }

    // --- START OF CRITICAL FIX ---
    const finalAttackerState = useUnitStore.getState().getUnitById(attackerId)
    if (finalAttackerState && finalAttackerState.actionsRemaining <= 0) {
      console.log(`Unit ${attackerId} has no actions left. Deselecting.`)
      useUnitStore.getState().selectUnit(null)
    }
    // --- END OF CRITICAL FIX ---

    // Clear memoization cache
    clearMemoizationCache(get().memoCache)

    // Get updated attacker for highlights
    const updatedAttacker = unitStore.getUnitById(attackerId)
    if (updatedAttacker) {
      const moves = get().calculatePossibleMoves(updatedAttacker)
      const targets = get().calculatePossibleTargets(updatedAttacker)
      
      const highlights = new Map<string, string>()
      moves.forEach((m) => highlights.set(`${m.x},${m.y}`, 'movement'))
      targets.forEach((t) => highlights.set(`${t.x},${t.y}`, 'attack'))
      
      uiStore.setHighlightedTiles(highlights)
    }

      // Emit action completed event
      if (typeof window !== 'undefined') {
        const event = new CustomEvent('actionCompleted', {
        detail: { actionType: 'attack', unitId: attackerId, remainingActions: updatedAttacker?.actionsRemaining || 0 }
        })
        window.dispatchEvent(event)
      }
  },

  captureCubicle: (unitId, coord) => {
    console.log('captureCubicle called with:', { unitId, coord })
    
    const unitStore = useUnitStore.getState()
    const boardStore = useBoardStore.getState()
    const playerStore = usePlayerStore.getState()
    const uiStore = useUIStore.getState()
    
    const unit = unitStore.getUnitById(unitId)
      if (!unit || unit.actionsRemaining === 0) {
        console.log('Cannot capture: unit not found or no actions remaining', { unit, actionsRemaining: unit?.actionsRemaining })
      return
      }

    const tile = boardStore.getTileAt(coord)
      if (!tile || tile.type !== TileType.CUBICLE) {
        console.log('Cannot capture: not a cubicle tile', { tile, coord })
      return
      }

      if (tile.owner === unit.playerId) {
        console.log('Cannot capture: already owned by this player', { tileOwner: tile.owner, unitPlayer: unit.playerId })
      return
      }

      console.log('Capturing cubicle:', {
        unitId,
        unitPlayer: unit.playerId,
        coord,
        currentOwner: tile.owner,
        tileType: tile.type
      })

    // Update board tile ownership
    boardStore.updateTileOwner(coord, unit.playerId)

    // Update unit actions
    unitStore.updateUnit(unitId, { actionsRemaining: unit.actionsRemaining - 1 })

    // Update player cubicle count and income
    const cubicleCount = boardStore.getCubicleTilesByOwner(unit.playerId).length
      console.log('Updated cubicle count for player', unit.playerId, ':', cubicleCount)

    // Update player data
    const players = playerStore.players.map((p) =>
        p.id === unit.playerId ? { ...p, controlledCubicles: cubicleCount, income: cubicleCount } : p
      )
    playerStore.setPlayers(players)

    // Clear selection and highlights
    unitStore.selectUnit(null)
    uiStore.clearHighlights()

    console.log('Cubicle capture completed')
  },

  endTurn: () => {
    const unitStore = useUnitStore.getState()
    const boardStore = useBoardStore.getState()
    const playerStore = usePlayerStore.getState()
    const uiStore = useUIStore.getState()
    
    const currentPlayerIndex = playerStore.players.findIndex((p) => p.id === playerStore.currentPlayerId)
    const nextPlayerIndex = (currentPlayerIndex + 1) % playerStore.players.length
    const nextPlayer = playerStore.players[nextPlayerIndex]

      // Process pending cubicle captures before ending turn
    const updatedPendingCaptures = new Map(get().pendingCubicleCaptures)
      
      console.log('Processing pending cubicle captures:', {
      count: get().pendingCubicleCaptures.size,
      captures: Array.from(get().pendingCubicleCaptures.entries())
      })
      
      // Process each pending capture
    for (const [captureKey, capture] of get().pendingCubicleCaptures) {
        const { unitId, coord, playerId } = capture
        
        // Verify the unit is still at the capture location
      const unit = unitStore.getUnitById(unitId)
        if (unit && unit.position.x === coord.x && unit.position.y === coord.y) {
          // Execute the capture
        const tile = boardStore.getTileAt(coord)
          if (tile && tile.type === TileType.CUBICLE && tile.owner !== playerId) {
            console.log('Executing pending capture:', { unitId, coord, playerId })
            
            // Update the board
          boardStore.updateTileOwner(coord, playerId)
            
            // Remove from pending captures
            updatedPendingCaptures.delete(captureKey)
          }
        } else {
          // Unit is no longer at the capture location, remove from pending
          console.log('Unit no longer at capture location, removing pending capture:', { unitId, coord })
          updatedPendingCaptures.delete(captureKey)
        }
      }
      
      // Update player cubicle counts and income
      const cubicleCounts = new Map<string, number>()
    boardStore.board.flat().forEach(tile => {
        if (tile.type === TileType.CUBICLE && tile.owner) {
          cubicleCounts.set(tile.owner, (cubicleCounts.get(tile.owner) || 0) + 1)
        }
      })
      
    const updatedPlayers = playerStore.players.map(p => ({
        ...p,
        controlledCubicles: cubicleCounts.get(p.id) || 0,
        income: cubicleCounts.get(p.id) || 0
      }))

    // Reset actions for next player's units
    unitStore.resetAllUnitActions(nextPlayer.id)

    // Add income to budget if starting new round
      if (nextPlayerIndex === 0) {
      const playersWithIncome = updatedPlayers.map((p) => ({ ...p, budget: p.budget + p.income }))
      playerStore.setPlayers(playersWithIncome)
    } else {
      playerStore.setPlayers(updatedPlayers)
    }

    // Update orchestrator state
    set({
      pendingCubicleCaptures: updatedPendingCaptures
    })

    // Move to next turn
    playerStore.nextTurn()

    // Clear selection and highlights
    unitStore.selectUnit(null)
    uiStore.clearHighlights()

      console.log('Turn ended, new state:', {
        nextPlayer: nextPlayer.id,
        pendingCapturesRemaining: updatedPendingCaptures.size,
        cubicleCounts: Array.from(cubicleCounts.entries())
      })

      // IMPORTANT: Trigger AI turn if next player is AI
      if (nextPlayer.id === 'player2') {
        setTimeout(() => {
          get().executeAITurn()
        }, 500) // Small delay for visual feedback
      }
  },

  // Add new function to execute AI turn
  executeAITurn: () => {
    const playerStore = usePlayerStore.getState()
    const unitStore = useUnitStore.getState()
    
    if (playerStore.currentPlayerId !== 'player2') return
    
    console.log('AI Turn starting...', {
      currentPlayer: playerStore.currentPlayerId,
      aiUnits: unitStore.getUnitsByPlayer('player2'),
      playerUnits: unitStore.getUnitsByPlayer('player1')
    })
    
    // Create AI controller instance
    const aiController = new AIController('normal')
    
    // Get current game state and let AI make decisions with action callbacks
    aiController.takeTurn({
      id: 'local-game',
      units: unitStore.units,
      board: useBoardStore.getState().board,
      players: playerStore.players,
      currentPlayerId: playerStore.currentPlayerId,
      turnNumber: playerStore.turnNumber,
      phase: playerStore.phase,
      selectedUnit: unitStore.selectedUnit,
      winner: playerStore.winner?.id
    }, {
      moveUnit: (unitId: string, to: Coordinate) => {
        console.log('AI moving unit', unitId, 'to', to)
        get().moveUnit(unitId, to)
        // Check victory conditions after each action
        get().checkVictoryConditions()
      },
      attackTarget: (attackerId: string, targetId: string) => {
        console.log('AI attacking', attackerId, '->', targetId)
        get().attackTarget(attackerId, targetId)
        // Check victory conditions after each action
        get().checkVictoryConditions()
      },
      captureCubicle: (unitId: string, coord: Coordinate) => {
        console.log('AI capturing cubicle', unitId, 'at', coord)
        get().captureCubicle(unitId, coord)
        // Check victory conditions after each action
        get().checkVictoryConditions()
      },
      useAbility: (unitId: string, abilityId: string, target?: Unit | Coordinate) => {
        console.log('AI using ability', unitId, abilityId, 'on', target)
        get().useAbility(unitId, abilityId, target)
        // Check victory conditions after each action
        get().checkVictoryConditions()
      },
      endTurn: () => {
        // Check victory conditions one final time before ending turn
        get().checkVictoryConditions()
        get().endTurn()
      },
    }, () => ({
      id: 'local-game',
      units: useUnitStore.getState().units,
      board: useBoardStore.getState().board,
      players: usePlayerStore.getState().players,
      currentPlayerId: usePlayerStore.getState().currentPlayerId,
      turnNumber: usePlayerStore.getState().turnNumber,
      phase: usePlayerStore.getState().phase,
      selectedUnit: useUnitStore.getState().selectedUnit,
      winner: usePlayerStore.getState().winner?.id
    })) // Pass a function that returns fresh state
  },

  // Debug function to log current board state
  logBoardState: () => {
    const boardStore = useBoardStore.getState()
    const cubicles = boardStore.getCubicleTiles()
    const ownedCubicles = cubicles.filter(t => t.owner)
    
    console.log('Current Board State:', {
      totalTiles: boardStore.board.length * boardStore.board[0].length,
      cubicles: cubicles.length,
      ownedCubicles: ownedCubicles.length,
      cubicleDetails: cubicles.map(t => ({
        position: { x: t.x, y: t.y },
        owner: t.owner,
        type: t.type
      })),
      pendingCaptures: get().pendingCubicleCaptures.size,
      pendingCaptureDetails: Array.from(get().pendingCubicleCaptures.entries())
    })
  },

  getUnitAt: (coord) => {
    return useUnitStore.getState().getUnitAt(coord)
  },

  getTileAt: (coord) => {
    return useBoardStore.getState().getTileAt(coord)
  },

  calculatePossibleMoves: (unit) => {
    if (unit.hasMoved || unit.actionsRemaining === 0) return []

    const boardStore = useBoardStore.getState()
    const unitStore = useUnitStore.getState()
    return getCachedPossibleMoves(unit, get().memoCache, () => {
      return calcMoves(unit, { board: boardStore.board, units: unitStore.units })
    })
  },

  calculatePossibleTargets: (unit) => {
    if (unit.hasAttacked || unit.actionsRemaining === 0) return []
    
    const unitStore = useUnitStore.getState()
    return getCachedPossibleTargets(unit, get().memoCache, () => {
      return calcTargets(unit, { units: unitStore.units })
    })
  },

  isValidMove: (unit, to) => {
    const boardStore = useBoardStore.getState()
    const unitStore = useUnitStore.getState()
    return isValidMoveUtil(unit, to, { board: boardStore.board, units: unitStore.units })
  },
  isValidAttack: (attacker, target) => {
    const unitStore = useUnitStore.getState()
    return isValidAttackUtil(attacker, target, { units: unitStore.units })
  },

  checkVictoryConditions: () => {
    const unitStore = useUnitStore.getState()
    const boardStore = useBoardStore.getState()
    const playerStore = usePlayerStore.getState()
    
    // Check if game is already over
    if (playerStore.phase === GamePhase.GAME_OVER) {
      console.log('Game is already over, skipping victory check')
      return
    }

    const victoryResult = checkVictory({
      units: unitStore.units,
      board: boardStore.board,
      players: playerStore.players,
      phase: playerStore.phase
    })

    if (victoryResult.hasWinner && victoryResult.winner) {
      console.log(victoryResult.reason)
      // Find the player by ID and set as winner
      const winnerPlayer = playerStore.players.find(p => p.id === victoryResult.winner)
      if (winnerPlayer) {
        playerStore.setWinner(winnerPlayer)
      }
    }
  },

  // Ability system methods (selectAbility moved to uiStore)

  useAbility: (unitId: string, abilityId: string, target?: Unit | Coordinate) => {
    const unitStore = useUnitStore.getState()

    const unit = unitStore.getUnitById(unitId)
    if (!unit) return

    const ability = getAbilityById(abilityId, unit)
    if (!ability || !canUseAbility(unit, abilityId)) return

    // Calculate direction if target is provided
    let direction = unit.direction
    if (target) {
      if ('x' in target) {
        // Target is a coordinate
        direction = getDirection(unit.position, target)
      } else {
        // Target is a unit
        direction = getDirection(unit.position, target.position)
      }
    }

    // Execute the ability's effect function to get the result
    const result = ability.effect(unit, target)

    if (result.success) {
      // --- START OF CRITICAL FIX ---

      // 1. Apply Status Effects
      if (result.statusApplied && target && 'id' in target) {
        const targetUnit = unitStore.getUnitById(target.id)
        if (targetUnit) {
          // Look up the full status effect definition from the DataManager
          const statusKey = result.statusApplied[0].type // This will be 'increase_speed'
          const statusEffectData = dataManager.getStatusEffect(statusKey)

          if (statusEffectData) {
            // Map the status key to the appropriate StatusType enum value
            let statusType: StatusType
            switch (statusEffectData.key) {
              case 'increase_speed':
                statusType = StatusType.INSPIRED
                break
              case 'bleeding':
                statusType = StatusType.POISONED
                break
              case 'fire':
                statusType = StatusType.BURNING
                break
              default:
                statusType = StatusType.CONFUSED
            }
            
            const newStatus = {
              type: statusType,
              key: statusEffectData.key,
              name: statusEffectData.name,
              duration: statusEffectData.duration_in_turns,
            }
            // Note: A full implementation would also apply modifiers
            unitStore.updateUnit(targetUnit.id, {
              status: [...targetUnit.status, newStatus]
            })
            console.log(`Applied status '${newStatus.name}' to ${targetUnit.id}`)
          }
        }
      }

      // 2. Apply Damage
      if (result.damageDealt && target && 'id' in target) {
        const targetUnit = unitStore.getUnitById(target.id)
        if (targetUnit) {
          const newHp = Math.max(0, targetUnit.hp - result.damageDealt)
          if (newHp === 0) {
            unitStore.removeUnit(targetUnit.id)
          } else {
            unitStore.updateUnit(targetUnit.id, { hp: newHp })
          }
        }
      }

      // 3. Apply Healing
      if (result.healingDone && target && 'id' in target) {
        const targetUnit = unitStore.getUnitById(target.id)
        if (targetUnit) {
          unitStore.updateUnit(targetUnit.id, { 
            hp: Math.min(targetUnit.maxHp, targetUnit.hp + result.healingDone)
          })
        }
      }

      // 4. Apply Action Bonus to Caster
      if (result.actionBonus) {
        unitStore.updateUnit(unitId, {
          actionsRemaining: unit.actionsRemaining + result.actionBonus
        })
      }

      // --- END OF CRITICAL FIX ---

      // 5. Set Cooldown on Caster
      if (ability.cooldown > 0) {
        unitStore.updateUnit(unitId, { 
          abilityCooldowns: { 
            ...unit.abilityCooldowns, 
            [abilityId]: ability.cooldown 
          } 
        })
      }

      // 6. Consume Action Points from Caster and update direction
      unitStore.updateUnit(unitId, { 
        actionsRemaining: unit.actionsRemaining - (ability.cost || 1),
        direction: direction
      })

      // --- START OF CRITICAL FIX ---
      const finalUnitState = useUnitStore.getState().getUnitById(unitId)
      if (finalUnitState && finalUnitState.actionsRemaining <= 0) {
        console.log(`Unit ${unitId} has no actions left. Deselecting.`)
        useUnitStore.getState().selectUnit(null)
      }
      // --- END OF CRITICAL FIX ---

      // Emit event and clean up UI
      if (typeof window !== 'undefined') {
        const event = new CustomEvent('actionCompleted', {
          detail: { actionType: 'ability', unitId, abilityId }
        })
        window.dispatchEvent(event)
      }
      actionHandlers.cancelAction()
    }
  },

  getAbilityTargets: (unitId: string, abilityId: string) => {
    const unitStore = useUnitStore.getState()
    const boardStore = useBoardStore.getState()
    
    const unit = unitStore.getUnitById(unitId)
    if (!unit) return []
    
    const ability = getAbilityById(abilityId, unit)
    if (!ability) return []
    return getValidTargets(unit, ability, boardStore.board, unitStore.units)
  },

  canUseAbility: (unitId: string, abilityId: string) => {
    const unitStore = useUnitStore.getState()
    const unit = unitStore.getUnitById(unitId)
    if (!unit) return false
    
    return canUseAbility(unit, abilityId)
  },

  // New helper functions for smart action availability
  canUnitMove: (unit: Unit) => {
    return unit.actionsRemaining > 0 && unit.remainingMovement > 0;
  },

  canUnitAttack: (unit: Unit) => {
    return unit.actionsRemaining > 0 && !unit.hasAttacked;
  },

  getEnemiesInRange: (unit: Unit) => {
    const unitStore = useUnitStore.getState();
    return unitStore.getEnemyUnits(unit.playerId).filter(enemy => {
        const distance = Math.abs(enemy.position.x - unit.position.x) + Math.abs(enemy.position.y - unit.position.y);
      return distance <= unit.attackRange;
    });
  },

  getRemainingMovement: (unit: Unit) => {
    return unit.actionsRemaining;
  },

  // Helper function to check if a unit can be selected while another is active
  canSelectUnit: (unit: Unit, currentlySelected?: Unit) => {
    if (!unit) return false
    
    // If no unit is currently selected, any player unit can be selected
    if (!currentlySelected) {
      return unit.playerId === 'player1' && unit.actionsRemaining > 0
    }
    
    // If we're trying to select the same unit, allow it (for deselection)
    if (unit.id === currentlySelected.id) {
      return true
    }
    
    // If the currently selected unit is in action mode, don't allow switching
    // unless the new unit is a valid target for the current action
    if (currentlySelected.actionsRemaining > 0 && 
        currentlySelected.playerId === 'player1') {
      // Check if the new unit is a valid attack target
      const isEnemy = unit.playerId !== currentlySelected.playerId
      const inAttackRange = get().calculatePossibleTargets(currentlySelected)
        .some(target => target.x === unit.position.x && target.y === unit.position.y)
      
      if (isEnemy && inAttackRange) {
        // This is a valid attack target - allow selection to execute attack
        return true
      }
      
      // Don't allow switching units while in action mode
      return false
    }
    
    // If no action mode, allow selecting any player unit with actions
    return unit.playerId === 'player1' && unit.actionsRemaining > 0
  },

  // Helper function to check if clicking on a unit should execute an action instead of switching
  shouldExecuteActionInsteadOfSelect: (unit: Unit, currentlySelected?: Unit) => {
    if (!unit || !currentlySelected) return false
    
    // Check if the currently selected unit is in action mode
    const isCurrentUnitInActionMode = currentlySelected.actionsRemaining > 0 && 
                                    currentlySelected.playerId === 'player1'
    
    if (!isCurrentUnitInActionMode) return false
    
    // Check if the clicked unit is a valid target for the current action
    const isEnemy = unit.playerId !== currentlySelected.playerId
    const inAttackRange = get().calculatePossibleTargets(currentlySelected)
      .some(target => target.x === unit.position.x && target.y === unit.position.y)
    
    return isEnemy && inAttackRange
  },

  // Helper function to check if clicking on a unit should execute a move instead of switching
  shouldExecuteMoveInsteadOfSelect: (unit: Unit, currentlySelected?: Unit) => {
    if (!unit || !currentlySelected) return false
    
    // Check if the currently selected unit is in move mode
    const isCurrentUnitInMoveMode = currentlySelected.actionsRemaining > 0 && 
                                   currentlySelected.playerId === 'player1' &&
                                   !currentlySelected.hasMoved
    
    if (!isCurrentUnitInMoveMode) return false
    
    // Check if the clicked unit's position is a valid move target
    const inMoveRange = get().calculatePossibleMoves(currentlySelected)
      .some(move => move.x === unit.position.x && move.y === unit.position.y)
    
    return inMoveRange
  },

  // Helper function to check if a unit is a valid attack target
  isValidAttackTarget: (attacker: Unit, target: Unit) => {
    if (!attacker || !target) return false
    
    // Check if target is an enemy
    if (attacker.playerId === target.playerId) return false
    
    // Check if attacker can attack
    if (attacker.hasAttacked || attacker.actionsRemaining === 0) return false
    
    // Check if target is in attack range
    const distance = Math.abs(target.position.x - attacker.position.x) + 
                    Math.abs(target.position.y - attacker.position.y)
    
    return distance <= attacker.attackRange
  },
}})




// function isAdjacent(a: Coordinate, b: Coordinate): boolean {
//   const result = Math.abs(a.x - b.x) + Math.abs(a.y - b.y) === 1
//   console.log('isAdjacent check:', { a, b, result, distance: Math.abs(a.x - b.x) + Math.abs(a.y - b.y) })
//   return result
// }







===== ./src/stores/boardStore.ts =====
import { create } from 'zustand'
import { type Tile, type Coordinate, TileType } from 'shared'
import { mapRegistry } from '../game/map/MapRegistry'
import { MAPS } from '../game/map/registry'

interface BoardStore {
  // State - Single Source of Truth for Board
  board: Tile[][]

  // Actions
  setBoard: (board: Tile[][]) => void
  createBoard: () => void
  updateTileOwner: (coord: Coordinate, playerId: string) => void
  
  // Queries
  getTileAt: (coord: Coordinate) => Tile | undefined
  getCubicleTiles: () => Tile[]
  getCubicleTilesByOwner: (playerId: string) => Tile[]
  getBoardDimensions: () => { width: number; height: number }
}

// Helper function to create the game board
function createBoardFromMap(): Tile[][] {
  // Get the actual map dimensions and capture points from the tilemap
  const startingPositions = mapRegistry.getStartingPositions('OfficeLayout')
  const capturePoints = mapRegistry.getCapturePoints('OfficeLayout')
  
  if (!startingPositions) {
    console.warn('Starting positions not available, using fallback board')
    return createFallbackBoard()
  }
  
  // Get map dimensions from configuration
  const mapId = 'OfficeLayout'
  const mapSpec = MAPS[mapId]
  const width = mapSpec.width
  const height = mapSpec.height
  const board: Tile[][] = []
  
  // Initialize all tiles as NORMAL
  for (let y = 0; y < height; y++) {
    const row: Tile[] = []
    for (let x = 0; x < width; x++) {
      row.push({ x, y, type: TileType.NORMAL })
    }
    board.push(row)
  }
  
  // Mark starting positions as HQ tiles
  startingPositions.goldTeam.forEach((pos: { x: number; y: number }) => {
    board[pos.y][pos.x].type = TileType.HQ_BLUE
  })
  
  startingPositions.navyTeam.forEach((pos: { x: number; y: number }) => {
    board[pos.y][pos.x].type = TileType.HQ_RED
  })

  // Mark capture points as CUBICLE tiles
  if (capturePoints) {
    capturePoints.forEach((pos: { x: number; y: number; gid: number }) => {
      if (pos.gid === 472) { // GID 472 = capture point
        board[pos.y][pos.x].type = TileType.CUBICLE
        console.log('Marked capture point at:', { x: pos.x, y: pos.y })
      }
    })
  }
  
  console.log('Created board with dimensions:', { width, height, capturePoints: capturePoints?.length || 0 })
  return board
}

function createFallbackBoard(): Tile[][] {
  // Fallback board using config dimensions if tilemap data isn't available
  const mapId = 'OfficeLayout'
  const mapSpec = MAPS[mapId]
  const width = mapSpec.width
  const height = mapSpec.height
  const board: Tile[][] = []
  for (let y = 0; y < height; y++) {
    const row: Tile[] = []
    for (let x = 0; x < width; x++) {
      let type: TileType = TileType.NORMAL
      if (y === 0 && x <= 1) type = TileType.HQ_BLUE
      if (y === height - 1 && x >= width - 2) type = TileType.HQ_RED
      if (y >= 2 && y <= height - 3 && x >= 2 && x <= width - 3) {
        if ((x + y) % 2 === 0) type = TileType.CUBICLE
      }
      if ((x === 3 && y === 5) || (x === 4 && y === 4)) type = TileType.OBSTACLE
      
      const tile = { x, y, type }
      row.push(tile)
    }
    board.push(row)
  }
  
  console.log('Created fallback board with dimensions:', { width, height })
  return board
}

export const useBoardStore = create<BoardStore>((set, get) => ({
  // Initial state
  board: [],

  // Actions
  setBoard: (board) => {
    set({ board })
  },

  createBoard: () => {
    const board = createBoardFromMap()
    set({ board })
  },

  updateTileOwner: (coord, playerId) => {
    set((state) => ({
      board: state.board.map((row) =>
        row.map((tile) =>
          tile.x === coord.x && tile.y === coord.y
            ? { ...tile, owner: playerId }
            : tile
        )
      )
    }))
  },

  // Queries
  getTileAt: (coord) => {
    const { board } = get()
    return board[coord.y]?.[coord.x]
  },

  getCubicleTiles: () => {
    return get().board.flat().filter((tile) => tile.type === TileType.CUBICLE)
  },

  getCubicleTilesByOwner: (playerId) => {
    return get().board
      .flat()
      .filter((tile) => tile.type === TileType.CUBICLE && tile.owner === playerId)
  },

  getBoardDimensions: () => {
    const { board } = get()
    return {
      width: board[0]?.length || 0,
      height: board.length
    }
  }
}))

===== ./src/stores/uiStore.ts =====
import { create } from 'zustand'

interface UIStore {
  // State - Single Source of Truth for UI-specific state
  highlightedTiles: Map<string, string>
  actionMode: 'none' | 'move' | 'attack' | 'ability'
  selectedAbility: string | undefined
  targetingMode: boolean
  abilityAwaitingDirection: string | null
  actionMenuPosition: { x: number; y: number; isVisible: boolean } | null

  // Actions
  setHighlightedTiles: (tiles: Map<string, string>) => void
  setActionMode: (mode: 'none' | 'move' | 'attack' | 'ability') => void
  setSelectedAbility: (abilityId: string | undefined) => void
  setTargetingMode: (mode: boolean) => void
  setAbilityAwaitingDirection: (abilityId: string | null) => void
  setActionMenu: (position: { x: number; y: number } | null) => void
  clearActionMode: () => void
  clearHighlights: () => void
  addHighlight: (coord: string, type: string) => void
  removeHighlight: (coord: string) => void
  
  // Queries
  hasHighlight: (coord: string) => boolean
  getHighlightType: (coord: string) => string | undefined
  isInActionMode: () => boolean
  isAbilitySelected: () => boolean
}

export const useUIStore = create<UIStore>((set, get) => ({
  // Initial state
  highlightedTiles: new Map<string, string>(),
  actionMode: 'none',
  selectedAbility: undefined,
  targetingMode: false,
  abilityAwaitingDirection: null,
  actionMenuPosition: null,

  // Actions
  setHighlightedTiles: (tiles) => {
    set({ highlightedTiles: tiles })
  },

  setActionMode: (mode) => {
    set({ actionMode: mode })
    
    // Clear ability selection when changing action mode
    if (mode !== 'ability') {
      set({ 
        selectedAbility: undefined,
        targetingMode: false,
        abilityAwaitingDirection: null
      })
    }
  },

  setSelectedAbility: (abilityId) => {
    set({ 
      selectedAbility: abilityId,
      actionMode: abilityId ? 'ability' : 'none',
      targetingMode: !!abilityId
    })
  },

  setTargetingMode: (mode) => {
    set({ targetingMode: mode })
  },

  setAbilityAwaitingDirection: (abilityId) => {
    set({ 
      abilityAwaitingDirection: abilityId,
      targetingMode: !!abilityId
    })
  },

  setActionMenu: (position) => {
    set({ 
      actionMenuPosition: position ? { ...position, isVisible: true } : null
    })
  },

  clearActionMode: () => {
    set({
      actionMode: 'none',
      selectedAbility: undefined,
      targetingMode: false,
      abilityAwaitingDirection: null,
      highlightedTiles: new Map(),
      actionMenuPosition: null
    })
  },

  clearHighlights: () => {
    set({ highlightedTiles: new Map() })
  },

  addHighlight: (coord, type) => {
    set((state) => {
      const newHighlights = new Map(state.highlightedTiles)
      newHighlights.set(coord, type)
      return { highlightedTiles: newHighlights }
    })
  },

  removeHighlight: (coord) => {
    set((state) => {
      const newHighlights = new Map(state.highlightedTiles)
      newHighlights.delete(coord)
      return { highlightedTiles: newHighlights }
    })
  },

  // Queries
  hasHighlight: (coord) => {
    return get().highlightedTiles.has(coord)
  },

  getHighlightType: (coord) => {
    return get().highlightedTiles.get(coord)
  },

  isInActionMode: () => {
    return get().actionMode !== 'none'
  },

  isAbilitySelected: () => {
    return !!get().selectedAbility
  }
}))

===== ./src/stores/playerStore.ts =====
import { create } from 'zustand'
import { type Player, GamePhase, Team } from 'shared'

interface PlayerStore {
  // State - Single Source of Truth for Players and Game Flow
  players: Player[]
  currentPlayerId: string
  turnNumber: number
  phase: GamePhase
  winner: Player | undefined

  // Actions
  setPlayers: (players: Player[]) => void
  initializePlayers: () => void
  nextTurn: () => void
  setWinner: (winner: Player) => void
  setCurrentPlayerId: (playerId: string) => void
  setPhase: (phase: GamePhase) => void
  setTurnNumber: (turnNumber: number) => void
  
  // Queries
  getCurrentPlayer: () => Player | undefined
  getPlayerById: (playerId: string) => Player | undefined
  getNextPlayer: () => Player | undefined
  isGameOver: () => boolean
}

// Helper function to create players
function createPlayers(): Player[] {
  return [
    { id: 'player1', name: 'Blue Team', team: Team.BLUE, budget: 10, income: 0, controlledCubicles: 0 },
    { id: 'player2', name: 'Red Team', team: Team.RED, budget: 10, income: 0, controlledCubicles: 0 },
  ]
}

export const usePlayerStore = create<PlayerStore>((set, get) => ({
  // Initial state
  players: [],
  currentPlayerId: '',
  turnNumber: 1,
  phase: GamePhase.SETUP,
  winner: undefined,

  // Actions
  setPlayers: (players) => {
    set({ players })
  },

  initializePlayers: () => {
    const players = createPlayers()
    set({ 
      players,
      currentPlayerId: 'player1', // Always start with player1
      turnNumber: 1,
      phase: GamePhase.PLAYING,
      winner: undefined
    })
  },

  nextTurn: () => {
    set((state) => {
      const currentPlayerIndex = state.players.findIndex((p) => p.id === state.currentPlayerId)
      const nextPlayerIndex = (currentPlayerIndex + 1) % state.players.length
      const nextPlayer = state.players[nextPlayerIndex]
      
      // Increment turn number only when we complete a full round (back to first player)
      const newTurnNumber = nextPlayerIndex === 0 ? state.turnNumber + 1 : state.turnNumber
      
      return {
        currentPlayerId: nextPlayer.id,
        turnNumber: newTurnNumber
      }
    })
  },

  setWinner: (winner) => {
    set({ 
      winner,
      phase: GamePhase.GAME_OVER
    })
  },

  setCurrentPlayerId: (playerId) => {
    set({ currentPlayerId: playerId })
  },

  setPhase: (phase) => {
    set({ phase })
  },

  setTurnNumber: (turnNumber) => {
    set({ turnNumber })
  },

  // Queries
  getCurrentPlayer: () => {
    const { players, currentPlayerId } = get()
    return players.find((p) => p.id === currentPlayerId)
  },

  getPlayerById: (playerId) => {
    return get().players.find((p) => p.id === playerId)
  },

  getNextPlayer: () => {
    const { players, currentPlayerId } = get()
    const currentPlayerIndex = players.findIndex((p) => p.id === currentPlayerId)
    const nextPlayerIndex = (currentPlayerIndex + 1) % players.length
    return players[nextPlayerIndex]
  },

  isGameOver: () => {
    return get().phase === GamePhase.GAME_OVER
  }
}))

===== ./src/index.css =====
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Improve perceived contrast over busy images */
.hero-title { 
  text-shadow: 0 2px 20px rgba(0,0,0,0.35);
  background: linear-gradient(135deg, #60a5fa, #3b82f6, #1d4ed8);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* Enhanced button hover effects */
.btn-hover-glow {
  transition: all 0.3s ease;
}

.btn-hover-glow:hover {
  box-shadow: 0 0 30px rgba(59, 130, 246, 0.5);
}

/* Smooth backdrop blur for modern browsers */
.backdrop-blur-modern {
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
}

/* Enhanced text shadows for better readability */
.text-shadow-enhanced {
  text-shadow: 0 2px 4px rgba(0,0,0,0.5), 0 4px 8px rgba(0,0,0,0.3);
}

/* Loading screen animations */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes slideInFromTop {
  from { opacity: 0; transform: translateY(-30px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.animate-fade-in {
  animation: fadeIn 0.8s ease-out;
}

.animate-slide-in {
  animation: slideInFromTop 0.6s ease-out;
}

.animate-pulse-slow {
  animation: pulse 2s ease-in-out infinite;
}

.shimmer-effect {
  position: relative;
  overflow: hidden;
}

.shimmer-effect::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
  animation: shimmer 2s infinite;
}

===== ./src/game/responsive/ResponsiveGameManager.ts =====
import Phaser from 'phaser';
import { useBoardStore } from '../../stores/boardStore';
import { MAPS } from '../map/registry';

export interface ResponsiveMapConfig {
  minTileSize: number;    // 28px - mobile minimum (touch-friendly)
  maxTileSize: number;    // 64px - desktop maximum
  targetBoardScale: number; // 0.9 - use 90% of available space
  tileSizeSteps: number[]; // Discrete sizes for visual consistency
}

export const DEFAULT_CONFIG: ResponsiveMapConfig = {
  minTileSize: 28,
  maxTileSize: 64,
  targetBoardScale: 0.95, // Increased from 0.9 to 0.95 for better space utilization
  tileSizeSteps: [28, 32, 40, 48, 56, 64]
};

export function calculateOptimalTileSize(
  viewportWidth: number,
  viewportHeight: number,
  mapWidth: number = MAPS['OfficeLayout'].width, // Use config dimensions
  mapHeight: number = MAPS['OfficeLayout'].height,
  config: ResponsiveMapConfig = DEFAULT_CONFIG
): number {
  // Calculate available space for board (more aggressive space usage)
  const availableWidth = viewportWidth * config.targetBoardScale;
  const availableHeight = viewportHeight * config.targetBoardScale;
  
  // Calculate tile sizes that would fit
  const widthBasedTileSize = availableWidth / mapWidth;
  const heightBasedTileSize = availableHeight / mapHeight;
  
  // Use the smaller to ensure full board visibility
  let optimalTileSize = Math.min(widthBasedTileSize, heightBasedTileSize);
  
  // Add a small buffer to ensure the board fits comfortably
  optimalTileSize = optimalTileSize * 0.98; // 2% buffer for safety
  
  // Clamp to reasonable bounds
  optimalTileSize = Math.max(config.minTileSize, 
                            Math.min(config.maxTileSize, optimalTileSize));
  
  // Snap to nearest discrete tile size for visual consistency
  optimalTileSize = getClosestTileSize(optimalTileSize, config.tileSizeSteps);
  
  return Math.floor(optimalTileSize);
}

function getClosestTileSize(calculated: number, steps: number[]): number {
  return steps.reduce((prev, curr) => 
    Math.abs(curr - calculated) < Math.abs(prev - calculated) ? curr : prev
  );
}

export class ResponsiveGameManager {
  private game: Phaser.Game;
  private currentTileSize: number = 48;
  private config: ResponsiveMapConfig;
  private resizeTimeout?: NodeJS.Timeout;
  
  constructor(game: Phaser.Game, config: ResponsiveMapConfig = DEFAULT_CONFIG) {
    this.game = game;
    this.config = config;
    console.log('ResponsiveGameManager: Constructor called, setting up responsive handling');
    
    // Delay setup to ensure game is fully initialized
    // Increased delay to prevent timing issues with GameScene
    setTimeout(() => {
      this.setupResponsiveHandling();
    }, 1000);
  }
  
  private setupResponsiveHandling(): void {
    try {
      console.log('ResponsiveGameManager: Setting up responsive handling');
      
      // Debounced resize handler
      const handleResize = () => {
        if (this.resizeTimeout) {
          clearTimeout(this.resizeTimeout);
        }
        this.resizeTimeout = setTimeout(() => this.updateGameScale(), 100);
      };
      
      window.addEventListener('resize', handleResize);
      
      // Initial scale
      this.updateGameScale();
      
      console.log('ResponsiveGameManager: Responsive handling setup complete');
    } catch (error) {
      console.error('ResponsiveGameManager: Error setting up responsive handling:', error);
    }
  }

  private calculateOptimalTileSize(): number {
    const availableWidth = window.innerWidth - 320; // Account for control panel
    const availableHeight = window.innerHeight - 100; // Account for header
    
    // Get actual board dimensions from board store or use config fallback
    const boardState = useBoardStore.getState()
    const mapWidth = boardState.board?.[0]?.length || MAPS['OfficeLayout'].width
    const mapHeight = boardState.board?.length || MAPS['OfficeLayout'].height
    
    // Calculate tile size that would fit the map in available space
    const maxTileSizeForWidth = Math.floor(availableWidth / mapWidth);
    const maxTileSizeForHeight = Math.floor(availableHeight / mapHeight);
    
    // Use the smaller of the two to ensure map fits
    let optimalTileSize = Math.min(maxTileSizeForWidth, maxTileSizeForHeight);
    
    // Apply target board scale (want to use most of available space)
    optimalTileSize = Math.floor(optimalTileSize * this.config.targetBoardScale);
    
    // Clamp to min/max bounds
    optimalTileSize = Math.max(this.config.minTileSize, Math.min(this.config.maxTileSize, optimalTileSize));
    
    // Snap to nearest step for visual consistency
    const snappedTileSize = this.getClosestTileSize(optimalTileSize);
    
    console.log(`ResponsiveGameManager: Calculation details:`);
    console.log(`  - Available space: ${availableWidth}x${availableHeight}`);
    console.log(`  - Max tile size for width: ${maxTileSizeForWidth}px`);
    console.log(`  - Max tile size for height: ${maxTileSizeForHeight}px`);
    console.log(`  - Raw optimal: ${optimalTileSize}px`);
    console.log(`  - Snapped to: ${snappedTileSize}px`);
    
    return snappedTileSize;
  }

  private getClosestTileSize(targetSize: number): number {
    let closest = this.config.tileSizeSteps[0];
    let minDifference = Math.abs(targetSize - closest);
    
    for (const step of this.config.tileSizeSteps) {
      const difference = Math.abs(targetSize - step);
      if (difference < minDifference) {
        minDifference = difference;
        closest = step;
      }
    }
    
    return closest;
  }
  
  private updateGameScale(): void {
    // Don't update if the game isn't fully initialized yet
    if (!this.game.scene.isActive('GameScene')) {
      console.log('ResponsiveGameManager: GameScene not active yet, skipping update');
      return;
    }
    
    console.log(`ResponsiveGameManager: updateGameScale called - viewport: ${window.innerWidth}x${window.innerHeight}`);
    
    const newTileSize = this.calculateOptimalTileSize();
    console.log(`ResponsiveGameManager: Calculated new tile size: ${newTileSize}px (current: ${this.currentTileSize}px)`);
    
    // Debug: Show calculation details
    const availableWidth = window.innerWidth - 320; // Account for control panel
    const availableHeight = window.innerHeight - 100; // Account for header
    const maxTilesWidth = Math.floor(availableWidth / this.config.minTileSize);
    const maxTilesHeight = Math.floor(availableHeight / this.config.minTileSize);
    console.log(`ResponsiveGameManager: Available space - Width: ${availableWidth}px, Height: ${availableHeight}px`);
    console.log(`ResponsiveGameManager: Max tiles that could fit - Width: ${maxTilesWidth}, Height: ${maxTilesHeight}`);
    console.log(`ResponsiveGameManager: Target board scale: ${this.config.targetBoardScale}`);
    
    if (newTileSize !== this.currentTileSize) {
      console.log(`ResponsiveGameManager: Tile size changed from ${this.currentTileSize}px to ${newTileSize}px, updating game`);
      this.currentTileSize = newTileSize;
      this.resizeGameBoard();
    } else {
      console.log(`ResponsiveGameManager: Tile size unchanged, no update needed`);
    }
  }
  
  private resizeGameBoard(): void {
    // Get actual board dimensions for canvas sizing
    const boardState = useBoardStore.getState()
    const boardWidth = boardState.board?.[0]?.length || MAPS['OfficeLayout'].width
    const boardHeight = boardState.board?.length || MAPS['OfficeLayout'].height
    const newWidth = boardWidth * this.currentTileSize;
    const newHeight = boardHeight * this.currentTileSize;
    
    console.log(`ResponsiveGameManager: Resizing game board from ${this.game.scale.width}x${this.game.scale.height} to ${newWidth}x${newHeight}`);
    

    // Don't call Phaser scale methods when using Scale.NONE - just update the canvas directly
    // This avoids the snapTo.x error that occurs when the scale manager isn't properly initialized
    try {
      const canvas = this.game.canvas;
      if (canvas) {
        canvas.width = newWidth;
        canvas.height = newHeight;
        canvas.style.width = `${newWidth}px`;
        canvas.style.height = `${newHeight}px`;
      }
    } catch (error) {
      void error; // Suppress unused variable warning
      console.warn('ResponsiveGameManager: Could not update canvas directly, skipping resize');
    }
    
    // Update tile sprites and positioning
    this.updateTileSprites();
    
    // Emit resize event for UI components
    window.dispatchEvent(new CustomEvent('gameBoardResized', {
      detail: { tileSize: this.currentTileSize, width: newWidth, height: newHeight }
    }));
  }
  
  private updateTileSprites(): void {
    // Get the current scene
    const scene = this.game.scene.getScene('GameScene');
    if (scene && 'updateTileSprites' in scene && typeof (scene as { updateTileSprites: (tileSize: number) => void }).updateTileSprites === 'function') {
      try {
        // Add a small delay to ensure the scene is fully ready
        setTimeout(() => {
          if (scene && 'updateTileSprites' in scene && typeof (scene as { updateTileSprites: (tileSize: number) => void }).updateTileSprites === 'function') {
            (scene as { updateTileSprites: (tileSize: number) => void }).updateTileSprites(this.currentTileSize);
          }
        }, 100);
      } catch (error) {
        console.warn('ResponsiveGameManager: Error updating tile sprites:', error);
      }
    }
  }
  
  public getCurrentTileSize(): number {
    return this.currentTileSize;
  }
  
  public getBoardDimensions(): { width: number, height: number } {
    // Get actual board dimensions from board store
    const boardState = useBoardStore.getState()
    const boardWidth = boardState.board?.[0]?.length || MAPS['OfficeLayout'].width
    const boardHeight = boardState.board?.length || MAPS['OfficeLayout'].height
    return {
      width: boardWidth * this.currentTileSize,
      height: boardHeight * this.currentTileSize
    };
  }
  
  public destroy(): void {
    if (this.resizeTimeout) {
      clearTimeout(this.resizeTimeout);
    }
    window.removeEventListener('resize', this.handleResize);
  }
  
  private handleResize = () => {
    if (this.resizeTimeout) {
      clearTimeout(this.resizeTimeout);
    }
    this.resizeTimeout = setTimeout(() => this.updateGameScale(), 100);
  };
}

===== ./src/game/responsive/README.md =====
# ðM-^_M-^N¯ **Responsive Tile Sizing System**

## **Overview**

The ResponsiveGameManager provides dynamic tile sizing for HRmageddon's game board, ensuring the entire 16x12 grid is always visible across different screen sizes.

## **Key Features**

- **Dynamic Tile Sizing**: Automatically calculates optimal tile size based on viewport
- **Full Board Visibility**: Always shows the complete game board
- **Touch-Friendly**: Minimum 28px tiles for mobile devices
- **Performance Optimized**: Debounced resize handling (100ms)
- **Phaser Integration**: Seamlessly works with existing Phaser game setup

## **Configuration**

```typescript
const DEFAULT_CONFIG: ResponsiveMapConfig = {
  minTileSize: 28,        // Mobile minimum (touch-friendly)
  maxTileSize: 64,        // Desktop maximum
  targetBoardScale: 0.9,  // Use 90% of available space
  tileSizeSteps: [28, 32, 40, 48, 56, 64] // Discrete sizes for consistency
};
```

## **Tile Size Ranges**

- **Mobile (<768px)**: 28px tiles
- **Tablet (768px-1200px)**: 32px tiles  
- **Desktop (1200px-1600px)**: 48px tiles
- **Wide (>1600px)**: 64px tiles

## **Testing the System**

### **1. Development Mode Debug Info**

When running in development mode, you'll see a debug panel in the top-right corner showing:
- Current tile size
- Board dimensions
- Screen dimensions

### **2. Manual Testing**

1. **Open the game** in your browser
2. **Resize the browser window** to different sizes
3. **Watch the debug panel** for tile size changes
4. **Verify the entire board** remains visible

### **3. Expected Behavior**

- **Small screens**: Tiles shrink to 28px minimum
- **Large screens**: Tiles grow up to 64px maximum
- **Smooth transitions**: No jarring size changes
- **Full board visibility**: Always see the complete 16x12 grid

## **Integration Points**

### **GameView.tsx**
- Initializes ResponsiveGameManager
- Listens for tile size change events
- Updates UI state with current tile size

### **GameScene.ts**
- Implements `updateTileSprites()` method
- Handles tile and unit sprite resizing
- Maintains game state during size changes

### **ResponsiveGameManager.ts**
- Core responsive logic
- Phaser game integration
- Event emission for UI updates

## **Performance Considerations**

- **Debounced resize**: 100ms delay prevents excessive updates
- **Conditional updates**: Only resizes when tile size actually changes
- **Memory efficient**: No viewport state management
- **Fast rendering**: Optimized sprite scaling

## **Future Enhancements**

- **Custom breakpoints**: User-configurable responsive thresholds
- **Animation**: Smooth transitions between tile sizes
- **Presets**: Predefined configurations for different device types
- **Analytics**: Track tile size usage across devices

## **Troubleshooting**

### **Board Not Resizing**
- Check browser console for ResponsiveGameManager logs
- Verify GameScene has `updateTileSprites` method
- Ensure resize events are firing

### **Performance Issues**
- Increase debounce delay (currently 100ms)
- Check for memory leaks in sprite cleanup
- Monitor frame rate during resize operations

### **Visual Glitches**
- Verify tile size steps are appropriate
- Check sprite positioning calculations
- Ensure proper cleanup of old graphics objects

===== ./src/game/scenes/GameScene.ts =====
import Phaser from 'phaser'
import { useGameStore } from '../../stores/gameStore'
import { useUIStore } from '../../stores/uiStore'
import { useUnitStore } from '../../stores/unitStore'
import { useBoardStore } from '../../stores/boardStore'
import { TileType, type Unit, type Tile, type Coordinate, AbilityTargetingType } from 'shared'
import { getAbilityById, getValidTargets } from '../core/abilities.ts'
import { getTilesInCone } from '../core/targeting'
import { MAPS } from '../map/registry'
import { MapManager } from '../map/MapManager'
import { GridOverlay } from '../debug/GridOverlay'
import { VisualEffectsPool } from '../visuals/VisualEffectsPool'
import { actionHandlers } from '../../stores/actionHandlers'

// ===== GAME SCENE CONFIGURATION =====
const VISUAL_CONFIG = {
  // Tile Colors (Corporate Beige & Gray Theme)
  COLORS: {
    TILES: {
      NORMAL: 0xf5f5f4,        // Stone-100 (Light beige)
      CUBICLE: 0xfef3c7,       // Amber-100 (Very light amber)
      OBSTACLE: 0x78716c,      // Stone-500 (Medium gray)
      CONFERENCE_ROOM: 0xd6d3d1, // Stone-300 (Light gray)
      HQ_BLUE: 0x57534e,       // Stone-600 (Dark gray for Player 1 HQ)
      HQ_RED: 0x44403c,        // Stone-700 (Darker gray for Player 2 HQ)
    },
    OWNERSHIP: {
      PLAYER1_CUBICLE: 0xfbbf24, // Amber-400 (Bright gold for Player 1)
      PLAYER2_CUBICLE: 0x3b82f6, // Blue-500 (Bright blue for Player 2 - more distinct from gray)
    },
    UNITS: {
      PLAYER1: 0xf59e0b,       // Amber-500 (Corporate gold)
      PLAYER2: 0x57534e,       // Stone-600 (Corporate gray)
      HP_BAR_BG: 0x000000,     // Black (kept for contrast)
      HP_BAR_FILL: 0x16a34a,   // Green-600 (kept for healing)
      SELECTION_BORDER: 0xf59e0b, // Amber-500 (Corporate gold)
      HOVER_BORDER: 0x78716c,  // Stone-500 (Corporate gray)
    },
    HIGHLIGHTS: {
      MOVEMENT: 0x78716c,      // Stone-500 (Corporate gray for movement)
      ATTACK: 0xef4444,        // Red-500 (Kept red for damage/attack)
      ATTACK_RANGE: 0xdc2626,  // Red-600 (Kept red for attack range)
      ABILITY: 0xf59e0b,       // Amber-500 (Corporate gold for abilities)
      ABILITY_AOE: 0xfbbf24,   // Amber-400 (Lighter gold for AOE abilities)
      MOVEMENT_BORDER: 0x57534e, // Stone-600 (Darker border for movement)
      ATTACK_BORDER: 0xdc2626,   // Red-600 (Darker border for attack)
      ABILITY_BORDER: 0xd97706,  // Amber-600 (Darker border for abilities)
    }
  },
  
  // Visual Properties
  UNIT: {
    CIRCLE_RADIUS: 20,
    FONT_SIZE: '14px',
    HP_BAR_WIDTH: 40,
    HP_BAR_HEIGHT: 6,
    HP_BAR_OFFSET_Y: -28,
    SELECTION_BORDER_WIDTH: 3,
    HOVER_BORDER_WIDTH: 2,
    HOVER_ALPHA: 0.9,
  },
  
  // Highlight Properties
  HIGHLIGHT: {
    MOVEMENT_ALPHA: 0.4,
    ATTACK_ALPHA: 0.4,
    ATTACK_RANGE_ALPHA: 0.4,
    ABILITY_ALPHA: 0.4,
    AOE_ALPHA: 0.4,
    BORDER_WIDTH: 2,
    TILE_BORDER_ALPHA: 0.5,
    OVERLAY_ENABLED: true, // Use transparent overlays instead of borders
  },
  
  // Animation
  ANIMATION: {
    MOVEMENT_DURATION: 250,
    CLICK_SCALE_DURATION: 100,
    CLICK_SCALE_FACTOR: 0.9,
  }
}
// ===== END CONFIGURATION =====

export class GameScene extends Phaser.Scene {
  private tileGraphics!: Phaser.GameObjects.Graphics
  private highlightGraphics!: Phaser.GameObjects.Graphics
  private unitSprites: Map<string, Phaser.GameObjects.Container> = new Map()
  private unsubscribe?: () => void
  private unsubscribeUI?: () => void
  private unsubscribeUnits?: () => void
  private isDestroyed: boolean = false
  private lastSelectedAbility?: string // Track ability changes for synchronization
  
  // Action menu integration
  private validTargets: (Unit | Coordinate)[] = []
  private abilityTargetGraphics!: Phaser.GameObjects.Graphics

  // Map management
  private mapMgr!: MapManager
  
  // Visual effects pooling
  private visualEffectsPool!: VisualEffectsPool
  // These are loaded from the map but not directly used yet - kept for future features
  /** @ts-expect-error - Intentionally unused, kept for future map features */
  private _tilemap!: Phaser.Tilemaps.Tilemap
  /** @ts-expect-error - Intentionally unused, kept for future map features */
  private _backgroundLayer!: Phaser.Tilemaps.TilemapLayer
  /** @ts-expect-error - Intentionally unused, kept for future map features */
  private _foregroundLayer!: Phaser.Tilemaps.TilemapLayer
  /** @ts-expect-error - Intentionally unused, kept for future map features */
  private _capturePointsLayer!: Phaser.Tilemaps.TilemapLayer
  /** @ts-expect-error - Intentionally unused, kept for future map features */
  private _startingPositionsLayer!: Phaser.Tilemaps.TilemapLayer

  private boardCols!: number
  private boardRows!: number
  private tileSizePx!: number
  


  private tileToWorld!: (tx:number, ty:number) => {x:number, y:number}
  private worldToTile!: (px:number, py:number) => {x:number, y:number}
  // Blocked helper for future movement validation
  /** @ts-expect-error - Intentionally unused, kept for future movement validation */
  private _isBlocked!: (tx:number, ty:number) => boolean

  constructor() {
    super({ key: 'GameScene' })
  }

  preload() {
    this.mapMgr = new MapManager(this, MAPS.OfficeLayout)
    this.mapMgr.preload()
  }

  create() {
    console.log('GameScene created')
    
    // Set up graphics for tiles and highlights
    this.tileGraphics = this.add.graphics()
    this.highlightGraphics = this.add.graphics()
    this.abilityTargetGraphics = this.add.graphics()
    
    // Initialize visual effects pool
    this.visualEffectsPool = new VisualEffectsPool(this)
    
    // Ensure ability graphics are drawn on top
    this.abilityTargetGraphics.setDepth(100)
    
    // Create the Tiled map
    console.log('GameScene: Creating Tiled map...');
    const created = this.mapMgr.create()
    console.log('GameScene: Map created:', created);
    
    this._tilemap    = created.map
    this._backgroundLayer = created.background
    this._foregroundLayer = created.foreground
    this._capturePointsLayer = created.capturePoints
    this._startingPositionsLayer = created.startingPositions

    this.boardCols = created.board.cols
    this.boardRows = created.board.rows
    this.tileSizePx = created.targetTileSizePx

    this.tileToWorld = created.tileToWorld
    this.worldToTile = created.worldToTile
    this._isBlocked   = created.isBlocked
    

    
    console.log('GameScene: Map setup complete:', {
      cols: this.boardCols,
      rows: this.boardRows,
      tileSize: this.tileSizePx
    });

    // Keep highlights above map
    this.highlightGraphics.setDepth(10)

    // Optional: toggle grid with 'G'
    new GridOverlay(this, this.boardCols, this.boardRows, this.tileSizePx)
    
    // Force initial render after map is ready
    const initialUnitState = useUnitStore.getState()
    const initialBoardState = useBoardStore.getState()
    if (initialBoardState.board && initialUnitState.units) {
      this.drawBoard(initialBoardState.board)
      this.drawUnits(initialUnitState.units)
    }
    
            // MapRegistry is now populated with starting positions
        console.log('GameScene: MapRegistry populated with starting positions for OfficeLayout')
    
    console.log('Graphics initialized:', {
      tileGraphics: !!this.tileGraphics,
      highlightGraphics: !!this.highlightGraphics,
      abilityTargetGraphics: !!this.abilityTargetGraphics
    })
    
    // Subscribe to UI store changes for highlights
    this.unsubscribeUI = useUIStore.subscribe((uiState) => {
      try {
        // Check if scene is still valid
        if (this.isDestroyed || !this.scene || !this.scene.manager || !this.scene.isActive || !this.scene.isActive()) {
          return
        }
        
        if (!this.highlightGraphics) {
          return
        }
        
        // Get current game state from slice stores
        const unitState = useUnitStore.getState()
        
        // Update highlights when UI store changes
        console.log('UI store changed, updating highlights:', {
          highlightCount: uiState.highlightedTiles.size,
          actionMode: uiState.actionMode,
          selectedAbility: uiState.selectedAbility
        })
        
        this.updateHighlights(uiState.highlightedTiles, unitState.selectedUnit)
      } catch (error) {
        console.error('Error in UI store subscription:', error)
      }
    })
    
    // Subscribe to unit store changes for unit rendering
    this.unsubscribeUnits = useUnitStore.subscribe((unitState) => {
      try {
        // Check if scene is still valid and has a valid manager
        if (this.isDestroyed || !this.scene || !this.scene.manager || !this.scene.isActive || !this.scene.isActive()) {
          console.warn('Scene destroyed or not active, skipping unit render update')
          return
        }
        
        if (!this.tileGraphics || !this.highlightGraphics || !this.abilityTargetGraphics) {
          console.warn('Graphics not initialized, skipping unit render update')
          return
        }
        
        // Redraw units when unit state changes
        this.drawUnits(unitState.units)
      } catch (error) {
        console.error('Error in unit store subscription:', error)
      }
    })
    
    // Subscribe to game store changes
    this.unsubscribe = useGameStore.subscribe(() => {
      try {
        // Check if scene is still valid and has a valid manager
        if (this.isDestroyed || !this.scene || !this.scene.manager || !this.scene.isActive || !this.scene.isActive()) {
          console.warn('Scene destroyed or not active, skipping render update')
          return
        }
        
        if (!this.tileGraphics || !this.highlightGraphics || !this.abilityTargetGraphics) {
          console.warn('Graphics not initialized, skipping render update')
          return
        }
        
        // Get current state from slice stores
        const unitState = useUnitStore.getState()
        const boardState = useBoardStore.getState()
        const uiState = useUIStore.getState()
        
        // Check for ability changes specifically
        if (uiState.selectedAbility !== this.lastSelectedAbility) {
          console.log('Ability selection changed:', {
            from: this.lastSelectedAbility,
            to: uiState.selectedAbility
          })
          this.lastSelectedAbility = uiState.selectedAbility
          
          // Force complete re-render of highlights
          this.highlightGraphics.clear()
          this.abilityTargetGraphics.clear()
          
        if (uiState.selectedAbility) {
          console.log('Ability mode active, updating ability targeting')
          this.updateAbilityTargeting(unitState.selectedUnit, uiState.selectedAbility)
        } else {
          console.log('Ability mode cleared, updating normal highlights')
          this.updateHighlights(uiState.highlightedTiles, unitState.selectedUnit)
        }
        } else {
          // Regular update (no ability change)
          console.log('Regular rendering update:', {
            board: boardState.board?.length,
            units: unitState.units?.length,
            highlights: uiState.highlightedTiles?.size,
            selectedUnit: !!unitState.selectedUnit,
            selectedAbility: !!uiState.selectedAbility
          })
          
          this.drawBoard(boardState.board)
          this.drawUnits(unitState.units)
          
          // If an ability is selected, don't show movement highlights
          if (uiState.selectedAbility) {
            console.log('Ability selected, clearing movement highlights and showing ability range')
            // Clear movement highlights when ability is active
            this.highlightGraphics.clear()
            // Only show ability targeting
            this.updateAbilityTargeting(unitState.selectedUnit, uiState.selectedAbility)
          } else {
            console.log('No ability selected, showing normal highlights')
            // Show normal highlights (movement, attack, etc.)
            this.updateHighlights(uiState.highlightedTiles, unitState.selectedUnit)
            // Clear ability targeting graphics
            this.abilityTargetGraphics.clear()
          }
        }
      } catch (error) {
        console.error('Error in game store subscription:', error)
        // Try to recover by re-initializing graphics if they were lost
        if (!this.tileGraphics || !this.highlightGraphics || !this.abilityTargetGraphics) {
          console.log('Attempting to recover graphics...')
          this.tileGraphics = this.add.graphics()
          this.highlightGraphics = this.add.graphics()
          this.abilityTargetGraphics.clear()
        }
      }
    })
    
    // Set up input handling with mobile touch optimizations
    this.input.on('pointerdown', this.handleClick, this)
    
    // Mobile touch optimizations
    this.input.on('pointerover', this.handlePointerOver, this)
    this.input.on('pointerout', this.handlePointerOut, this)
    
    // Prevent zoom on mobile devices
    this.input.on('wheel', (_pointer: Phaser.Input.Pointer, _gameObjects: Phaser.GameObjects.GameObject[], _deltaX: number, deltaY: number, _deltaZ: number) => {
      void _pointer; void _gameObjects; void _deltaX; void _deltaZ; // Suppress unused parameter warnings
      // Prevent zoom/scroll on mobile
      if (Math.abs(deltaY) > 0) {
        return false
      }
    })
    
    // Touch event optimizations for mobile
    this.input.setDefaultCursor('pointer')
    
    // Disable right-click context menu on mobile
    this.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
      if (pointer.rightButtonDown()) {
        return false
      }
    })
    
    // Initial render
    const finalUnitState = useUnitStore.getState()
    const finalBoardState = useBoardStore.getState()
    this.drawBoard(finalBoardState.board)
    this.drawUnits(finalUnitState.units)
  }

  // In GameScene.ts - replace getTileSize() with:
  public getTileSize(): number {
  // Get tile size from ResponsiveGameManager instead of calculating
  const responsiveManager = (this.game as Phaser.Game & { responsiveManager?: { getCurrentTileSize(): number } }).responsiveManager
  if (responsiveManager) {
    return responsiveManager.getCurrentTileSize()
  }
  
  // Fallback if ResponsiveGameManager not available
  return 40
}

  public getBoardOffsetX(): number {
    // With Tiled map, board starts at (0,0) - no offset needed
    return 0
  }

  public getBoardOffsetY(): number {
    // With Tiled map, board starts at (0,0) - no offset needed
    return 0
  }

  private drawBoard(board: Tile[][]) {
    try {
      if (!this.tileGraphics) {
        console.warn('tileGraphics not initialized, skipping board draw')
        return
      }
      
      // Don't clear the graphics - we want ownership overlays to persist
      // this.tileGraphics.clear()
      
      // With Tiled map, we don't need to draw the base tiles anymore
      // The map layers handle the visual representation
      // We only need to draw ownership overlays for cubicles
      
      let ownershipOverlaysDrawn = 0
      
      for (let y = 0; y < board.length; y++) {
        for (let x = 0; x < board[y].length; x++) {
          const tile = board[y][x]
          
          // Only draw ownership overlays for cubicles
          if (tile.type === TileType.CUBICLE && tile.owner) {
            const { x: wx, y: wy } = this.tileToWorld(x, y)
            const color = tile.owner === 'player1' ? VISUAL_CONFIG.COLORS.OWNERSHIP.PLAYER1_CUBICLE : VISUAL_CONFIG.COLORS.OWNERSHIP.PLAYER2_CUBICLE
            
            this.tileGraphics.fillStyle(color, 0.8) // Increased opacity to 0.8 for maximum visibility
            this.tileGraphics.fillRect(wx, wy, this.tileSizePx, this.tileSizePx)
            
            // Add a bold border to make ownership even clearer
            this.tileGraphics.lineStyle(3, color, 1.0) // Full opacity border
            this.tileGraphics.strokeRect(wx, wy, this.tileSizePx, this.tileSizePx)
            
            ownershipOverlaysDrawn++
            
            // Debug logging for ownership overlays
            console.log('Drawing ownership overlay:', {
              position: { x, y },
              owner: tile.owner,
              color: color.toString(16),
              worldPos: { wx, wy }
            })
          }
        }
      }
      
      // Set the highest depth to ensure ownership overlays are on top
      this.tileGraphics.setDepth(200)
      
      console.log('Board drawing complete:', {
        totalTiles: board.length * board[0].length,
        cubicles: board.flat().filter(t => t.type === TileType.CUBICLE).length,
        ownedCubicles: board.flat().filter(t => t.type === TileType.CUBICLE && t.owner).length,
        ownershipOverlaysDrawn,
        tileGraphicsDepth: this.tileGraphics.depth
      })
      
    } catch (error) {
      console.error('Error drawing board:', error)
    }
  }

  private drawUnits(units: Unit[]) {
    try {
      // remove containers that no longer exist
      this.unitSprites.forEach((container, id) => {
        if (!units.find((u) => u.id === id)) {
          container.destroy()
          this.unitSprites.delete(id)
        }
      })

      for (const unit of units) {
        const { x: wx, y: wy } = this.tileToWorld(unit.position.x, unit.position.y)
        const targetX = wx + this.tileSizePx / 2
        const targetY = wy + this.tileSizePx / 2
        const existing = this.unitSprites.get(unit.id)
        if (existing) {
          this.tweens.add({ targets: existing, x: targetX, y: targetY, duration: VISUAL_CONFIG.ANIMATION.MOVEMENT_DURATION, ease: 'Power2' })
          
          // Update HP bar width
          const hpFill = existing.getByName('hpFill') as Phaser.GameObjects.Rectangle
          if (hpFill) hpFill.width = VISUAL_CONFIG.UNIT.HP_BAR_WIDTH * (unit.hp / unit.maxHp)
          
          // Update transparency for "done" state
          const circle = existing.getByName('circle') as Phaser.GameObjects.Graphics
          const label = existing.getByName('label') as Phaser.GameObjects.Text
          const hpBg = existing.getByName('hpBg') as Phaser.GameObjects.Rectangle
          
          const alpha = unit.actionsRemaining === 0 ? 0.5 : 1.0
          if (circle) circle.setAlpha(alpha)
          if (label) label.setAlpha(alpha)
          if (hpBg) hpBg.setAlpha(alpha)
          if (hpFill) hpFill.setAlpha(alpha)
          
          continue
        }

        const container = this.add.container(targetX, targetY).setDepth(50)
        const circleColor = unit.playerId === 'player1' ? VISUAL_CONFIG.COLORS.UNITS.PLAYER1 : VISUAL_CONFIG.COLORS.UNITS.PLAYER2 // Gold vs Navy
        const circle = this.add.circle(0, 0, VISUAL_CONFIG.UNIT.CIRCLE_RADIUS, circleColor).setName('circle')
        const label = this.add.text(0, 0, unit.type.charAt(0).toUpperCase(), { color: '#fff', fontSize: VISUAL_CONFIG.UNIT.FONT_SIZE }).setName('label')
        label.setOrigin(0.5)
        const hpBg = this.add.rectangle(0, VISUAL_CONFIG.UNIT.HP_BAR_OFFSET_Y, VISUAL_CONFIG.UNIT.HP_BAR_WIDTH, VISUAL_CONFIG.UNIT.HP_BAR_HEIGHT, VISUAL_CONFIG.COLORS.UNITS.HP_BAR_BG).setOrigin(0.5).setName('hpBg')
        const hpFill = this.add.rectangle(-20, VISUAL_CONFIG.UNIT.HP_BAR_OFFSET_Y, VISUAL_CONFIG.UNIT.HP_BAR_WIDTH * (unit.hp / unit.maxHp), VISUAL_CONFIG.UNIT.HP_BAR_HEIGHT, VISUAL_CONFIG.COLORS.UNITS.HP_BAR_FILL)
          .setOrigin(0, 0.5)
          .setName('hpFill')
        
        // Set transparency for units with no actions remaining (visual "done" state)
        if (unit.actionsRemaining === 0) {
          circle.setAlpha(0.5) // Semi-transparent to show "done" state
          label.setAlpha(0.5)
          hpBg.setAlpha(0.5)
          hpFill.setAlpha(0.5)
        } else {
          circle.setAlpha(1.0) // Full opacity for active units
          label.setAlpha(1.0)
          hpBg.setAlpha(1.0)
          hpFill.setAlpha(1.0)
        }
        
        container.add([circle, label, hpBg, hpFill])
        
        // Make the container interactive with proper hit area
        container.setSize(this.tileSizePx, this.tileSizePx)
        container.setData('unitId', unit.id)
        
        // Enhanced interactivity for Safari compatibility
        container.setInteractive(new Phaser.Geom.Rectangle(-this.tileSizePx/2, -this.tileSizePx/2, this.tileSizePx, this.tileSizePx), Phaser.Geom.Rectangle.Contains)
        
        // Add multiple event listeners for better compatibility
        container.on('pointerdown', () => {
          console.log('Unit clicked:', unit.id) // Debug log
          const u = useUnitStore.getState().units.find((uu) => uu.id === unit.id)
          if (u) useGameStore.getState().selectUnit(u)
          
          // Add click feedback
          circle.setScale(VISUAL_CONFIG.ANIMATION.CLICK_SCALE_FACTOR)
          this.time.delayedCall(VISUAL_CONFIG.ANIMATION.CLICK_SCALE_DURATION, () => {
            circle.setScale(1)
          })
        })
        
        // Add visual feedback for interactivity
        container.on('pointerover', () => {
          circle.setStrokeStyle(VISUAL_CONFIG.UNIT.HOVER_BORDER_WIDTH, VISUAL_CONFIG.COLORS.UNITS.HOVER_BORDER, VISUAL_CONFIG.UNIT.HOVER_ALPHA)
          // Add a subtle glow effect
          circle.setAlpha(0.9)
        })
        
        container.on('pointerout', () => {
          circle.setStrokeStyle(0)
          circle.setAlpha(1)
        })
        
        this.unitSprites.set(unit.id, container)
      }
    } catch (error) {
      console.error('Error drawing units:', error)
    }
  }

  private updateHighlights(highlighted: Map<string, string>, selectedUnit?: Unit) {
    try {
      if (!this.highlightGraphics) {
        console.warn('highlightGraphics not initialized, skipping highlight update')
        return
      }
      
      // ALWAYS clear first
      this.highlightGraphics.clear()
      
      // Check ability state FIRST
      const uiStore = useUIStore.getState()
      if (uiStore.selectedAbility) {
        console.log('Ability mode active, showing ability highlights only')
        // Only render highlights with type 'ability'
        highlighted.forEach((type, coordKey) => {
          if (type === 'ability') {
            const [x, y] = coordKey.split(',').map(Number)
            const { x: px, y: py } = this.tileToWorld(x, y)
            
            // Use DISTINCT purple color for abilities
            this.drawHighlight(px, py, this.tileSizePx, 'ability')
          }
        })
        return // Don't show any other highlights
      }
      
      console.log('updateHighlights:', {
        hasAbility: !!uiStore.selectedAbility,
        highlightCount: highlighted.size,
        highlightTypes: Array.from(highlighted.values())
      })
      
      // Normal mode - show movement/attack highlights
      console.log('Normal mode active, showing movement/attack highlights')
      const highlightMap = new Map<string, string[]>()
      
      highlighted.forEach((type, key) => {
        // IGNORE ability highlights in normal mode
        if (type !== 'ability') {
          if (!highlightMap.has(key)) {
            highlightMap.set(key, [])
          }
          highlightMap.get(key)!.push(type)
        }
      })
      
      // Draw movement/attack highlights
      highlightMap.forEach((types, coordKey) => {
        const [x, y] = coordKey.split(',').map(Number)
        const { x: px, y: py } = this.tileToWorld(x, y)
        
        types.forEach(type => {
          this.drawHighlight(px, py, this.tileSizePx, type)
        })
      })

      // Always draw selected unit highlight last
      if (selectedUnit) {
        const { x: px, y: py } = this.tileToWorld(selectedUnit.position.x, selectedUnit.position.y)
        this.highlightGraphics.lineStyle(3, 0xfbbf24, 1) // Gold selection
        this.highlightGraphics.strokeRect(px - 1, py - 1, this.tileSizePx, this.tileSizePx)
      }
    } catch (error) {
      console.error('Error updating highlights:', error)
    }
  }

  private drawHighlight(x: number, y: number, tileSize: number, type: string) {
    try {
      if (!this.highlightGraphics) {
        console.warn('highlightGraphics not initialized, skipping highlight draw')
        return
      }
      
      let color = 0x16a34a // Default green
      let alpha = 0.3
      
      switch (type) {
        case 'movement':
          color = 0x3b82f6 // Blue for movement
          alpha = 0.4
          break
        case 'attack':
          color = 0xef4444 // Red for attack
          alpha = 0.4
          break
        case 'ability':
          color = 0x9333ea // DISTINCT Purple for abilities
          alpha = 0.5
          break
        case 'attack_range':
          color = 0xdc2626 // Darker red for attack range
          alpha = 0.3
          break
        case 'ability_aoe':
          color = 0xec4899 // Pink for AOE abilities
          alpha = 0.4
          break
        case 'target_enemy':
          color = 0xef4444 // Red for enemy targets
          alpha = 0.6
          break
        case 'target_ally':
          color = 0x16a34a // Green for ally targets
          alpha = 0.6
          break
        case 'capture':
          color = 0x06b6d4 // Cyan for capture
          alpha = 0.4
          break
        case 'invalid':
          color = 0x6b7280 // Gray for invalid targets
          alpha = 0.5
          break
        default:
          color = 0x16a34a // Default green
          alpha = 0.3
      }
      
      // Fill the tile
      this.highlightGraphics.fillStyle(color, alpha)
      this.highlightGraphics.fillRect(x, y, tileSize, tileSize)
      
      // Add border for clarity
      this.highlightGraphics.lineStyle(2, color, alpha + 0.3)
      this.highlightGraphics.strokeRect(x, y, tileSize, tileSize)
    } catch (error) {
      console.error('Error drawing highlight:', error)
    }
  }

  private updateAbilityTargeting(selectedUnit?: Unit, selectedAbility?: string) {
    console.log('updateAbilityTargeting called with:', { 
      selectedUnit: selectedUnit?.id, 
      selectedAbility,
      hasGraphics: !!this.abilityTargetGraphics 
    })
    
    this.abilityTargetGraphics.clear()
    
    if (!selectedUnit || !selectedAbility) {
      console.log('No unit or ability selected, clearing targeting')
      this.validTargets = []
      return
    }

    const ability = getAbilityById(selectedAbility, selectedUnit)
    if (!ability) {
      console.log('Ability not found:', selectedAbility)
      return
    }

    console.log('Found ability:', ability.name, 'with range:', ability.range)

    const unitState = useUnitStore.getState()
    const boardState = useBoardStore.getState()
    this.validTargets = getValidTargets(selectedUnit, ability, boardState.board, unitState.units)
    
    console.log('Valid targets found:', this.validTargets.length)

    // Show range highlight first
    this.showAbilityRange(selectedUnit, ability)
    
    // Handle different targeting types
    switch (ability.targetingType) {
      case AbilityTargetingType.AOE_CONE:
        this.showConePreview(selectedUnit, ability)
        break
      case AbilityTargetingType.AOE_CIRCLE:
        this.showCirclePreview(selectedUnit, ability)
        break
      case AbilityTargetingType.SINGLE_TARGET:
      default:
        this.showStandardTargeting(selectedUnit)
        break
    }
  }

  // Show the range area for an ability
  private showAbilityRange(caster: Unit, ability: { name: string; range: number; targetType: string }) {
    console.log('showAbilityRange called for:', ability.name, 'with range:', ability.range)
    console.log('Caster position:', caster.position)
    
    // Validate graphics context
    if (!this.abilityTargetGraphics) {
      console.error('abilityTargetGraphics not initialized!')
      return
    }
    
    console.log('Tile size:', this.tileSizePx, 'Board offset: (0,0) - Tiled map')
    
    // Determine if this is a positive or negative ability based on target type
    const isNegativeAbility = ability.targetType === 'enemy'
    
    console.log('Ability type:', { isPositiveAbility: false, isNegativeAbility, targetType: ability.targetType })
    
    // Use appropriate colors for range highlighting
    let rangeColor: number
    let rangeAlpha: number
    
    if (isNegativeAbility) {
      // Reddish for negative abilities (harmful to enemies)
      rangeColor = VISUAL_CONFIG.COLORS.HIGHLIGHTS.ATTACK_RANGE
      rangeAlpha = 0.25 // Good visibility without being too opaque
      console.log('Using negative ability colors:', { rangeColor: rangeColor.toString(16), rangeAlpha })
    } else {
      // Greenish for positive abilities (helpful to allies)
      rangeColor = VISUAL_CONFIG.COLORS.UNITS.HP_BAR_FILL
      rangeAlpha = 0.25 // Good visibility without being too opaque
      console.log('Using positive ability colors:', { rangeColor: rangeColor.toString(16), rangeAlpha })
    }
    
    // Draw range highlight for all tiles within range
    const range = ability.range || 1
    let tilesHighlighted = 0
    
    console.log('Drawing range highlights for range:', range)
    
    for (let dx = -range; dx <= range; dx++) {
      for (let dy = -range; dy <= range; dy++) {
        // Check if this tile is within the actual range (Manhattan distance)
        if (Math.abs(dx) + Math.abs(dy) <= range) {
          const targetX = caster.position.x + dx
          const targetY = caster.position.y + dy
          
          // Check if this position is on the board
          const boardState = useBoardStore.getState()
          if (targetX >= 0 && targetX < boardState.board[0].length && 
              targetY >= 0 && targetY < boardState.board.length) {
            
            const { x: px, y: py } = this.tileToWorld(targetX, targetY)
            
            console.log(`Highlighting tile at (${targetX}, ${targetY}) -> screen (${px}, ${py})`)
            
            // Draw range highlight
            this.abilityTargetGraphics.fillStyle(rangeColor, rangeAlpha)
            this.abilityTargetGraphics.fillRect(px, py, this.tileSizePx, this.tileSizePx)
            
            // Add subtle border
            this.abilityTargetGraphics.lineStyle(1, rangeColor, rangeAlpha + 0.2)
            this.abilityTargetGraphics.strokeRect(px, py, this.tileSizePx, this.tileSizePx)
            
            tilesHighlighted++
          }
        }
      }
    }
    
    console.log(`Range highlighting complete. Tiles highlighted: ${tilesHighlighted}`)
  }

  private showStandardTargeting(selectedUnit: Unit) {
    // Highlight valid targets with standard targeting
    this.validTargets.forEach(target => {
      if ('x' in target) {
        // Target is a coordinate
        const { x: px, y: py } = this.tileToWorld(target.x, target.y)
        
        // Determine if this is a positive or negative ability
        const ability = getAbilityById(useUIStore.getState().selectedAbility || '', selectedUnit)
        const isNegativeAbility = ability?.targetType === 'enemy'
        
        // Use appropriate colors for target highlighting
        let targetColor: number
        let targetAlpha: number
        
        if (isNegativeAbility) {
          // Reddish for negative abilities
          targetColor = VISUAL_CONFIG.COLORS.HIGHLIGHTS.ATTACK
          targetAlpha = VISUAL_CONFIG.HIGHLIGHT.ATTACK_ALPHA
        } else {
          // Greenish for positive abilities
          targetColor = VISUAL_CONFIG.COLORS.UNITS.HP_BAR_FILL
          targetAlpha = VISUAL_CONFIG.HIGHLIGHT.ABILITY_ALPHA
        }
        
        this.abilityTargetGraphics.lineStyle(VISUAL_CONFIG.HIGHLIGHT.BORDER_WIDTH, targetColor, targetAlpha)
        this.abilityTargetGraphics.strokeRect(px, py, this.tileSizePx, this.tileSizePx)
        this.abilityTargetGraphics.fillStyle(targetColor, targetAlpha * 0.3)
        this.abilityTargetGraphics.fillRect(px, py, this.tileSizePx, this.tileSizePx)
      } else {
        // Target is a unit
        const { x: px, y: py } = this.tileToWorld(target.position.x, target.position.y)
        
        // Determine if this is a positive or negative ability
        const ability = getAbilityById(useUIStore.getState().selectedAbility || '', selectedUnit)
        const isNegativeAbility = ability?.targetType === 'enemy'
        
        // Use appropriate colors for target highlighting
        let targetColor: number
        let targetAlpha: number
        
        if (isNegativeAbility) {
          // Reddish for negative abilities
          targetColor = VISUAL_CONFIG.COLORS.HIGHLIGHTS.ATTACK
          targetAlpha = VISUAL_CONFIG.HIGHLIGHT.ATTACK_ALPHA
        } else {
          // Greenish for positive abilities
          targetColor = VISUAL_CONFIG.COLORS.UNITS.HP_BAR_FILL
          targetAlpha = VISUAL_CONFIG.HIGHLIGHT.ABILITY_ALPHA
        }
        
        this.abilityTargetGraphics.lineStyle(VISUAL_CONFIG.HIGHLIGHT.BORDER_WIDTH, targetColor, targetAlpha)
        this.abilityTargetGraphics.strokeCircle(px + this.tileSizePx/2, py + this.tileSizePx/2, this.tileSizePx/2 + 2)
        this.abilityTargetGraphics.fillStyle(targetColor, targetAlpha * 0.3)
        this.abilityTargetGraphics.fillCircle(px + this.tileSizePx/2, py + this.tileSizePx/2, this.tileSizePx/2)
      }
    })
  }

  private showConePreview(caster: Unit, ability: { range: number; coneAngle?: number; requiresDirection?: boolean }) {
    // For cone abilities, show a preview of the cone area
    // Check if this is a directional ability awaiting direction input
    const uiStore = useUIStore.getState()
    if (ability.requiresDirection && uiStore.abilityAwaitingDirection) {
      // Start listening for pointer movement to draw the preview
      this.input.on('pointermove', this.updateConePreview, this)
      console.log('Cone preview mode activated - listening for mouse movement')
      return
    }
    
    // Default cone preview (facing right)
    const { x: casterX, y: casterY } = this.tileToWorld(caster.position.x, caster.position.y)
    const casterCenterX = casterX + this.tileSizePx / 2
    const casterCenterY = casterY + this.tileSizePx / 2
    
    // Draw cone preview (simplified for now - can be enhanced with mouse tracking)
    const coneRadius = (ability.range || 3) * this.tileSizePx
    const coneAngle = (ability.coneAngle || 90) * Math.PI / 180 // Convert to radians
    
    // Draw cone outline
    this.abilityTargetGraphics.lineStyle(VISUAL_CONFIG.HIGHLIGHT.BORDER_WIDTH, VISUAL_CONFIG.COLORS.HIGHLIGHTS.ABILITY_AOE, VISUAL_CONFIG.HIGHLIGHT.ABILITY_ALPHA)
    this.abilityTargetGraphics.beginPath()
    this.abilityTargetGraphics.moveTo(casterCenterX, casterCenterY)
    
    // Draw cone arc (facing right for now)
    const startAngle = -coneAngle / 2
    const endAngle = coneAngle / 2
    this.abilityTargetGraphics.arc(casterCenterX, casterCenterY, coneRadius, startAngle, endAngle)
    this.abilityTargetGraphics.lineTo(casterCenterX, casterCenterY)
    this.abilityTargetGraphics.strokePath()
    
    // Fill cone area
    this.abilityTargetGraphics.fillStyle(VISUAL_CONFIG.COLORS.HIGHLIGHTS.ABILITY_AOE, VISUAL_CONFIG.HIGHLIGHT.AOE_ALPHA)
    this.abilityTargetGraphics.fill()
  }

  // NEW METHOD to dynamically draw the cone preview
  private updateConePreview(pointer: Phaser.Input.Pointer) {
    const unitState = useUnitStore.getState()
    const uiStore = useUIStore.getState()
    const caster = unitState.selectedUnit
    const abilityId = uiStore.abilityAwaitingDirection

    if (!caster || !abilityId) {
      this.input.off('pointermove', this.updateConePreview, this) // Stop listening
      return
    }

    this.abilityTargetGraphics.clear() // Clear previous preview
    const ability = getAbilityById(abilityId, caster)
    if (!ability) return

    const { x: tileX, y: tileY } = this.worldToTile(pointer.x, pointer.y)
    const direction = { x: tileX - caster.position.x, y: tileY - caster.position.y }

    const affectedTiles = getTilesInCone(caster.position, direction, ability.range, ability.coneAngle || 90)

    // Draw the highlight for all affected tiles
    this.abilityTargetGraphics.fillStyle(VISUAL_CONFIG.COLORS.HIGHLIGHTS.ABILITY_AOE, VISUAL_CONFIG.HIGHLIGHT.AOE_ALPHA)
    affectedTiles.forEach(tile => {
      const { x: px, y: py } = this.tileToWorld(tile.x, tile.y)
      this.abilityTargetGraphics.fillRect(px, py, this.tileSizePx, this.tileSizePx)
    })
  }

  private showCirclePreview(caster: Unit, ability: { range: number; aoeRadius?: number }) {
    // For circle AOE abilities, show the area of effect
    const { x: casterX, y: casterY } = this.tileToWorld(caster.position.x, caster.position.y)
    const casterCenterX = casterX + this.tileSizePx / 2
    const casterCenterY = casterY + this.tileSizePx / 2
    
    const aoeRadius = (ability.aoeRadius || 2) * this.tileSizePx
    
    // Draw circle outline
    this.abilityTargetGraphics.lineStyle(VISUAL_CONFIG.HIGHLIGHT.BORDER_WIDTH, VISUAL_CONFIG.COLORS.HIGHLIGHTS.ABILITY_AOE, VISUAL_CONFIG.HIGHLIGHT.ABILITY_ALPHA)
    this.abilityTargetGraphics.strokeCircle(casterCenterX, casterCenterY, aoeRadius)
    
    // Fill circle area
    this.abilityTargetGraphics.fillStyle(VISUAL_CONFIG.COLORS.HIGHLIGHTS.ABILITY_AOE, VISUAL_CONFIG.HIGHLIGHT.AOE_ALPHA)
    this.abilityTargetGraphics.fill()
  }

  // Mobile touch event handlers
  private handlePointerOver(_pointer: Phaser.Input.Pointer) {
    void _pointer; // Suppress unused parameter warning
    // Add hover effects for desktop (optional for mobile)
    if (!this.isMobileDevice()) {
      // Desktop hover effects can go here
    }
  }

  private handlePointerOut(_pointer: Phaser.Input.Pointer) {
    void _pointer; // Suppress unused parameter warning
    // Clear hover effects for desktop (optional for mobile)
    if (!this.isMobileDevice()) {
      // Desktop hover cleanup can go here
    }
  }

  // Helper to detect mobile devices
  private isMobileDevice(): boolean {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
           window.innerWidth < 768
  }

  private handleClick(pointer: Phaser.Input.Pointer) {
    if (this.isDestroyed) return

    const uiState = useUIStore.getState()
    const unitState = useUnitStore.getState()
    const gameState = useGameStore.getState()
    const { x: tileX, y: tileY } = this.worldToTile(pointer.x, pointer.y)

    // Check if the click is outside the board boundaries
    const boardState = useBoardStore.getState()
    if (tileX < 0 || tileX >= boardState.board[0].length || tileY < 0 || tileY >= boardState.board.length) {
        console.log('Clicked outside board, cancelling action.')
        actionHandlers.cancelAction()
        gameState.selectUnit(null) // Deselect unit
        return
    }

    // --- START OF NEW LOGIC ---

    // Step 1: Handle clicks when an action mode is active
    if (uiState.actionMode !== 'none' && unitState.selectedUnit) {
      const targetCoord = { x: tileX, y: tileY }

      /*
      if (uiState.actionMode === 'move') {
        actionHandlers.executeMove(unitState.selectedUnit, targetCoord)
      } 
      */
      
      if (uiState.actionMode === 'move') {
        const isValidMove = gameState.isValidMove(unitState.selectedUnit, targetCoord);

        if (isValidMove) {
          actionHandlers.executeMove(unitState.selectedUnit, targetCoord);
        } else {
          // THIS IS THE FIX: Handle clicks on invalid tiles during move mode
          console.log("Invalid move target clicked. Cancelling move action.");
          actionHandlers.cancelAction();
        }
      } else if (uiState.actionMode === 'attack') {
        const targetUnit = unitState.getUnitAt(targetCoord)
        if (targetUnit) {
          actionHandlers.executeAttack(unitState.selectedUnit, targetUnit)
        } else {
          console.log("Invalid attack target.")
          actionHandlers.cancelAction()
        }
      } else if (uiState.actionMode === 'ability') {
        // This logic is already correctly implemented from the previous prompt.
        // The click is handled by the block at the top of the function.
        const ability = getAbilityById(uiState.selectedAbility!, unitState.selectedUnit)
        if (ability) {
          const validTargets = getValidTargets(unitState.selectedUnit, ability, boardState.board, unitState.units)
          const clickedTarget = validTargets.find(target => {
            if ('id' in target) { // It's a Unit
              return target.position.x === tileX && target.position.y === tileY
            } else { // It's a Coordinate
              return target.x === tileX && target.y === tileY
            }
          })

          if (clickedTarget) {
            console.log(`Executing ability '${uiState.selectedAbility}' on valid target.`)
            gameState.useAbility(unitState.selectedUnit.id, uiState.selectedAbility!, clickedTarget)
            actionHandlers.cancelAction()
            return
          } else {
            console.log("Invalid target clicked for ability. Cancelling action.")
            actionHandlers.cancelAction()
            return
          }
        }
      }
      return // Action has been handled or cancelled.
    }

    // Step 2: Handle clicks when NO action mode is active (i.e., selecting things)
    const unitAtClick = unitState.getUnitAt({ x: tileX, y: tileY })
    if (unitAtClick) {
      // A unit was clicked, so select it.
      gameState.selectUnit(unitAtClick)
    } else {
      // An empty tile was clicked, so deselect everything.
      gameState.selectUnit(null)
    }
    // --- END OF NEW LOGIC ---
  }


  // Public method to set action mode from the ActionMenu
  setActionMode(mode: 'none' | 'move' | 'attack' | 'ability', abilityId?: string) {
    const uiStore = useUIStore.getState()
    uiStore.setActionMode(mode)
    if (abilityId) {
      uiStore.setSelectedAbility(abilityId)
    }
    
    if (mode === 'none') {
      // Clear highlights when exiting action mode
      this.highlightGraphics.clear()
      // Restore normal unit highlights
      const unitState = useUnitStore.getState()
      const uiState = useUIStore.getState()
      if (unitState.selectedUnit) {
        this.updateHighlights(uiState.highlightedTiles, unitState.selectedUnit)
      }
    } else if (mode === 'move') {
      // Clear existing highlights and show move highlights
      this.highlightGraphics.clear()
      const unitState = useUnitStore.getState()
      const gameState = useGameStore.getState()
      if (unitState.selectedUnit) {
        // Show move highlights
        const possibleMoves = gameState.calculatePossibleMoves(unitState.selectedUnit)
        possibleMoves.forEach((move: Coordinate) => {
          const { x: px, y: py } = this.tileToWorld(move.x, move.y)
          
          // Draw blue highlight for move targets
          this.highlightGraphics.fillStyle(VISUAL_CONFIG.COLORS.TILES.HQ_BLUE, VISUAL_CONFIG.HIGHLIGHT.ABILITY_ALPHA)
          this.highlightGraphics.fillRect(px, py, this.tileSizePx, this.tileSizePx)
          this.highlightGraphics.lineStyle(VISUAL_CONFIG.HIGHLIGHT.BORDER_WIDTH, 0x1d4ed8, 1)
          this.highlightGraphics.strokeRect(px, py, this.tileSizePx, this.tileSizePx)
        })
      }
    } else if (mode === 'attack') {
      // Show attack highlights on enemies in range
      this.showAttackHighlights()
    } else if (mode === 'ability' && abilityId) {
      // Show ability highlights on valid targets
      this.showAbilityHighlights(abilityId)
    }
  }

  // Public getter for action mode
  getActionMode(): 'none' | 'move' | 'attack' | 'ability' {
    return useUIStore.getState().actionMode
  }

  // Public method to clear action mode
  clearActionMode() {
    useUIStore.getState().clearActionMode()
    this.highlightGraphics.clear()
    // Restore normal unit highlights
    const unitState = useUnitStore.getState()
    const uiState = useUIStore.getState()
    if (unitState.selectedUnit) {
      this.updateHighlights(uiState.highlightedTiles, unitState.selectedUnit)
    }
  }

  // Show attack highlights on enemies in attack range
  private showAttackHighlights() {
    const unitState = useUnitStore.getState()
    const gameState = useGameStore.getState()
    if (!unitState.selectedUnit) return

    // Clear existing highlights
    this.highlightGraphics.clear()
    
    // Get only enemies in attack range (use possibleTargets from store)
    const possibleTargets = gameState.calculatePossibleTargets(unitState.selectedUnit!)
    const enemies = unitState.units.filter(u => 
      u.playerId !== unitState.selectedUnit!.playerId &&
      possibleTargets.some((target: Coordinate) => target.x === u.position.x && target.y === u.position.y)
    )
    
    // Highlight each enemy position with red
    enemies.forEach(enemy => {
      const { x: px, y: py } = this.tileToWorld(enemy.position.x, enemy.position.y)
      
      // Draw red highlight for enemy targets
      this.highlightGraphics.fillStyle(VISUAL_CONFIG.COLORS.HIGHLIGHTS.ATTACK, VISUAL_CONFIG.HIGHLIGHT.ATTACK_ALPHA)
      this.highlightGraphics.fillRect(px, py, this.tileSizePx, this.tileSizePx)
      this.highlightGraphics.lineStyle(VISUAL_CONFIG.HIGHLIGHT.BORDER_WIDTH, VISUAL_CONFIG.COLORS.HIGHLIGHTS.ATTACK_RANGE, 1)
      this.highlightGraphics.strokeRect(px, py, this.tileSizePx, this.tileSizePx)
    })
  }

  // Show ability highlights on valid targets
  private showAbilityHighlights(abilityId: string) {
    const unitState = useUnitStore.getState()
    const boardState = useBoardStore.getState()
    if (!unitState.selectedUnit) return

    // Clear existing highlights
    this.highlightGraphics.clear()
    
    // Get valid targets for this ability
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const validTargets = getValidTargets(unitState.selectedUnit, { id: abilityId } as any, boardState.board, unitState.units)
    
    // Highlight each valid target with purple
    validTargets.forEach(target => {
      let px: number, py: number
      if ('x' in target) {
        // Coordinate target
        const { x: wx, y: wy } = this.tileToWorld(target.x, target.y)
        px = wx
        py = wy
      } else {
        // Unit target
        const { x: wx, y: wy } = this.tileToWorld(target.position.x, target.position.y)
        px = wx
        py = wy
      }
      
      // Draw purple highlight for ability targets
      this.highlightGraphics.fillStyle(VISUAL_CONFIG.COLORS.HIGHLIGHTS.ABILITY, VISUAL_CONFIG.HIGHLIGHT.ABILITY_ALPHA)
      this.highlightGraphics.fillRect(px, py, this.tileSizePx, this.tileSizePx)
      this.highlightGraphics.lineStyle(VISUAL_CONFIG.HIGHLIGHT.BORDER_WIDTH, 0x7c3aed, 1)
      this.highlightGraphics.strokeRect(px, py, this.tileSizePx, this.tileSizePx)
    })
  }

  destroy() {
    console.log('GameScene destroy called')
    
    // Mark as destroyed to prevent further operations
    this.isDestroyed = true
    
    // Clean up subscriptions first
    if (this.unsubscribe) {
      this.unsubscribe()
      this.unsubscribe = undefined
    }
    if (this.unsubscribeUI) {
      this.unsubscribeUI()
      this.unsubscribeUI = undefined
    }
    if (this.unsubscribeUnits) {
      this.unsubscribeUnits()
      this.unsubscribeUnits = undefined
    }
    
    // Clear graphics to prevent further operations
    if (this.tileGraphics) {
      this.tileGraphics.destroy()
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this.tileGraphics = undefined as any
    }
    if (this.highlightGraphics) {
      this.highlightGraphics.destroy()
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this.highlightGraphics = undefined as any
    }
    if (this.abilityTargetGraphics) {
      this.abilityTargetGraphics.destroy()
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this.abilityTargetGraphics = undefined as any
    }
    
    // Clear unit sprites
    this.unitSprites.forEach(container => {
      if (container && container.destroy) {
        container.destroy()
      }
    })
    this.unitSprites.clear()
    
    // Clean up visual effects pool
    if (this.visualEffectsPool) {
      this.visualEffectsPool.destroy()
    }
    
    console.log('GameScene destroy completed')
  }

  // Ability visual effects
  playAbilityEffect(abilityId: string, target: Unit | Coordinate) {
    try {
      const ability = getAbilityById(abilityId, undefined)
      if (!ability) return

      switch (ability.visualEffect) {
        case 'coffee_steam':
          this.createCoffeeParticles(target)
          break
        case 'pink_slip_flash':
          this.createPinkSlipEffect(target)
          break
        case 'paper_flying':
          this.createPaperEffect(target)
          break
        case 'harass_aura':
          this.createHarassEffect(target)
          break
        case 'overtime_glow':
          this.createOvertimeEffect(target)
          break
        default:
          this.createGenericEffect(target)
      }
    } catch (error) {
      console.error('Error playing ability effect:', error)
    }
  }

  private createCoffeeParticles(target: Unit | Coordinate) {
    const position = this.getTargetPosition(target)
    if (!position) return

    this.visualEffectsPool.createCoffeeParticles(target, position)
  }

  private createPinkSlipEffect(target: Unit | Coordinate) {
    const position = this.getTargetPosition(target)
    if (!position) return

    this.visualEffectsPool.createPinkSlipEffect(target, position)
  }

  private createPaperEffect(target: Unit | Coordinate) {
    const position = this.getTargetPosition(target)
    if (!position) return

    this.visualEffectsPool.createPaperEffect(target, position)
  }

  private createHarassEffect(target: Unit | Coordinate) {
    const position = this.getTargetPosition(target)
    if (!position) return

    this.visualEffectsPool.createHarassEffect(target, position)
  }

  private createOvertimeEffect(target: Unit | Coordinate) {
    const position = this.getTargetPosition(target)
    if (!position) return

    this.visualEffectsPool.createOvertimeGlow(target, position)
  }

  private createGenericEffect(target: Unit | Coordinate) {
    const position = this.getTargetPosition(target)
    if (!position) return

    // Use money sparkle for generic effect
    this.visualEffectsPool.createMoneySparkle(target, position)
  }

  private getTargetPosition(target: Unit | Coordinate): { x: number, y: number } | null {
    if ('x' in target) {
      // Target is a coordinate
      const { x: wx, y: wy } = this.tileToWorld(target.x, target.y)
      return {
        x: wx + this.tileSizePx / 2,
        y: wy + this.tileSizePx / 2
      }
    } else {
      // Target is a unit
      const { x: wx, y: wy } = this.tileToWorld(target.position.x, target.position.y)
      return {
        x: wx + this.tileSizePx / 2,
        y: wy + this.tileSizePx / 2
      }
    }
  }

  // ===== RESPONSIVE TILE SIZING =====
  
  /**
   * Updates tile sprites and positioning when tile size changes
   * Called by ResponsiveGameManager when viewport resizes
   */
  public updateTileSprites(newTileSize: number): void {
    if (this.isDestroyed) return;
    
    console.log(`GameScene: Updating tile size from ${this.tileSizePx} to ${newTileSize}`);
    
    // Update the tile size
    this.tileSizePx = newTileSize;
    
    // Clear existing graphics - add null checks to prevent errors
    if (this.tileGraphics && this.tileGraphics.clear) {
      this.tileGraphics.clear();
    }
    if (this.highlightGraphics && this.highlightGraphics.clear) {
      this.highlightGraphics.clear();
    }
    if (this.abilityTargetGraphics && this.abilityTargetGraphics.clear) {
      this.abilityTargetGraphics.clear();
    }
    
    // Redraw the board with new tile size
    const updateBoardState = useBoardStore.getState();
    if (updateBoardState.board) {
      this.drawBoard(updateBoardState.board);
    }
    
    // Update unit positions and sizes
    this.updateUnitSprites();
    
    // Clear any existing highlights (using existing clear methods) - add null checks
    if (this.highlightGraphics && this.highlightGraphics.clear) {
      this.highlightGraphics.clear();
    }
    if (this.abilityTargetGraphics && this.abilityTargetGraphics.clear) {
      this.abilityTargetGraphics.clear();
    }
    
    // Get actual board dimensions for logging
    const logBoardState = useBoardStore.getState()
    const boardWidth = logBoardState.board?.[0]?.length || 16
    const boardHeight = logBoardState.board?.length || 12
    console.log(`GameScene: Tile size update complete. New dimensions: ${boardWidth * newTileSize}x${boardHeight * newTileSize}`);
  }
  
  private updateUnitSprites(): void {
    // Update all unit sprites with new tile size
    this.unitSprites.forEach((container, unitId) => {
      const unitState = useUnitStore.getState()
      const unit = unitState.units.find(u => u.id === unitId);
      if (unit) {
        // Update container size
        container.setSize(this.tileSizePx, this.tileSizePx);
        
        // Update interactive area
        container.setInteractive(new Phaser.Geom.Rectangle(
          -this.tileSizePx/2, 
          -this.tileSizePx/2, 
          this.tileSizePx, 
          this.tileSizePx
        ), Phaser.Geom.Rectangle.Contains);
        
        // Update position
        const { x: wx, y: wy } = this.tileToWorld(unit.position.x, unit.position.y);
        container.setPosition(wx + this.tileSizePx / 2, wy + this.tileSizePx / 2);
        
        // Update unit circle radius proportionally
        const unitCircle = container.getByName('circle') as Phaser.GameObjects.Arc;
        if (unitCircle && unitCircle.setRadius) {
          const newRadius = Math.max(12, this.tileSizePx * 0.4); // Proportional radius with minimum
          // Use existing color logic from VISUAL_CONFIG
          const circleColor = unit.playerId === 'player1' ? VISUAL_CONFIG.COLORS.UNITS.PLAYER1 : VISUAL_CONFIG.COLORS.UNITS.PLAYER2;
          unitCircle.setRadius(newRadius);
          unitCircle.setFillStyle(circleColor, 1);
        } else {
          console.warn(`GameScene: unitCircle not found or invalid for unit ${unitId}`);
        }
        
        // Update HP bar positioning
        const hpBar = container.getByName('hpBg') as Phaser.GameObjects.Rectangle;
        if (hpBar) {
          const hpBarWidth = Math.max(30, this.tileSizePx * 0.8);
          const hpBarHeight = Math.max(4, this.tileSizePx * 0.1);
          const hpBarOffsetY = -this.tileSizePx / 2 - 8;
          
          // HP bar will be redrawn when needed, just update positioning
          container.setData('hpBarConfig', { width: hpBarWidth, height: hpBarHeight, offsetY: hpBarOffsetY });
        }
      }
    });
  }
}



===== ./src/game/core/movement.test.ts =====
import { describe, it, expect, beforeEach } from 'vitest'
import { 
  calculatePossibleMoves, 
  isValidMove, 
  getUnitsInRange, 
  findNearestUnit, 
  getDistance
} from './movement'
import { createMockUnit, createMockGameState } from '../test/helpers'
import { TileType, type GameState, type Tile } from 'shared'
import { expectImplementation, getImplementationStatus, TestStatus } from '../test/testHelpers'

describe('Movement System', () => {
  let mockGameState: GameState
  let mockBoard: Tile[][]

  beforeEach(() => {
    mockGameState = createMockGameState()
    mockBoard = mockGameState.board
  })

  describe('calculatePossibleMoves', () => {
    it('should return an empty array for a trapped unit surrounded by obstacles', () => {
      if (getImplementationStatus('MOVEMENT_SYSTEM') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Movement system', 'calculatePossibleMoves should handle obstacles and return empty array for trapped units')
        return
      }

      try {
        // Create a board with obstacles around the unit
        const trappedUnit = createMockUnit({ 
          id: 'trapped', 
          position: { x: 5, y: 5 }, 
          moveRange: 2 
        })
        
        // Create obstacles around the unit
        const boardWithObstacles = Array(10).fill(null).map((_, y) => 
          Array(10).fill(null).map((_, x) => {
            if (x === 5 && y === 5) return { type: TileType.NORMAL, x, y }
            if (Math.abs(x - 5) <= 1 && Math.abs(y - 5) <= 1) return { type: TileType.OBSTACLE, x, y }
            return { type: TileType.NORMAL, x, y }
          })
        )

        const result = calculatePossibleMoves(trappedUnit, { board: boardWithObstacles, units: [] })
        
        if (result === undefined) {
          expectImplementation('Movement calculation', 'calculatePossibleMoves should return array, got undefined')
          return
        }

        expect(result).toEqual([])
      } catch (error) {
        expectImplementation('Movement calculation', `calculatePossibleMoves function not implemented: ${error}`)
      }
    })

    it('should not allow movement through tiles occupied by other units', () => {
      if (getImplementationStatus('MOVEMENT_SYSTEM') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Movement collision detection', 'calculatePossibleMoves should avoid occupied tiles')
        return
      }

      try {
        const unit = createMockUnit({ 
          id: 'unit1', 
          position: { x: 5, y: 5 }, 
          moveRange: 2 
        })
        
        const blockingUnit = createMockUnit({ 
          id: 'unit2', 
          position: { x: 6, y: 5 }, 
          playerId: 'player2' 
        })

        const result = calculatePossibleMoves(unit, { board: mockBoard, units: [unit, blockingUnit] })
        
        if (result === undefined) {
          expectImplementation('Movement collision detection', 'calculatePossibleMoves should return array, got undefined')
          return
        }

        // Should not include the tile occupied by the blocking unit
        expect(result).not.toContainEqual({ x: 6, y: 5 })
        
        // Should include other valid moves
        expect(result).toContainEqual({ x: 4, y: 5 })
        expect(result).toContainEqual({ x: 5, y: 4 })
        expect(result).toContainEqual({ x: 5, y: 6 })
      } catch (error) {
        expectImplementation('Movement collision detection', `Movement collision detection not implemented: ${error}`)
      }
    })

    it('should return all tiles up to the unit\'s maximum moveRange on an empty board', () => {
      if (getImplementationStatus('MOVEMENT_SYSTEM') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Movement range calculation', 'calculatePossibleMoves should find all tiles within moveRange')
        return
      }

      try {
        const unit = createMockUnit({ 
          id: 'unit1', 
          position: { x: 5, y: 5 }, 
          moveRange: 2 
        })

        const result = calculatePossibleMoves(unit, { board: mockBoard, units: [unit] })
        
        if (result === undefined) {
          expectImplementation('Movement range calculation', 'calculatePossibleMoves should return array, got undefined')
          return
        }

        // Should include all tiles within range (Manhattan distance)
        expect(result).toContainEqual({ x: 4, y: 5 }) // 1 step
        expect(result).toContainEqual({ x: 6, y: 5 }) // 1 step
        expect(result).toContainEqual({ x: 5, y: 4 }) // 1 step
        expect(result).toContainEqual({ x: 5, y: 6 }) // 1 step
        expect(result).toContainEqual({ x: 3, y: 5 }) // 2 steps
        expect(result).toContainEqual({ x: 7, y: 5 }) // 2 steps
        expect(result).toContainEqual({ x: 5, y: 3 }) // 2 steps
        expect(result).toContainEqual({ x: 5, y: 7 }) // 2 steps
        expect(result).toContainEqual({ x: 4, y: 4 }) // 2 steps diagonal
        expect(result).toContainEqual({ x: 6, y: 6 }) // 2 steps diagonal

        // Should not include tiles beyond range
        expect(result).not.toContainEqual({ x: 2, y: 5 }) // 3 steps
        expect(result).not.toContainEqual({ x: 8, y: 5 }) // 3 steps
      } catch (error) {
        expectImplementation('Movement range calculation', `Movement range calculation not implemented: ${error}`)
      }
    })

    it('should not include the unit\'s current position in possible moves', () => {
      if (getImplementationStatus('MOVEMENT_SYSTEM') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Movement self-exclusion', 'calculatePossibleMoves should not include current position')
        return
      }

      try {
        const unit = createMockUnit({ 
          id: 'unit1', 
          position: { x: 5, y: 5 }, 
          moveRange: 2 
        })

        const result = calculatePossibleMoves(unit, { board: mockBoard, units: [unit] })
        
        if (result === undefined) {
          expectImplementation('Movement self-exclusion', 'calculatePossibleMoves should return array, got undefined')
          return
        }

        expect(result).not.toContainEqual({ x: 5, y: 5 })
      } catch (error) {
        expectImplementation('Movement self-exclusion', `Movement self-exclusion not implemented: ${error}`)
      }
    })
  })

  describe('isValidMove', () => {
    it('should validate moves within range', () => {
      if (getImplementationStatus('MOVEMENT_SYSTEM') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Move validation', 'isValidMove should check if move is within range')
        return
      }

      try {
        const unit = createMockUnit({ 
          id: 'unit1', 
          position: { x: 5, y: 5 }, 
          moveRange: 2 
        })
        const target = { x: 6, y: 5 }

        const result = isValidMove(unit, target, { board: mockBoard, units: [unit] })
        
        if (result === undefined) {
          expectImplementation('Move validation', 'isValidMove should return boolean, got undefined')
          return
        }

        expect(result).toBe(true)
      } catch (error) {
        expectImplementation('Move validation', `isValidMove function not implemented: ${error}`)
      }
    })

    it('should reject moves outside range', () => {
      if (getImplementationStatus('MOVEMENT_SYSTEM') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Range validation', 'isValidMove should reject moves outside range')
        return
      }

      try {
        const unit = createMockUnit({ 
          id: 'unit1', 
          position: { x: 5, y: 5 }, 
          moveRange: 1 
        })
        const target = { x: 7, y: 5 }

        const result = isValidMove(unit, target, { board: mockBoard, units: [unit] })
        
        if (result === undefined) {
          expectImplementation('Range validation', 'isValidMove should return boolean, got undefined')
          return
        }

        expect(result).toBe(false)
      } catch (error) {
        expectImplementation('Range validation', `Range validation not implemented: ${error}`)
      }
    })

    it('should reject moves to occupied tiles', () => {
      if (getImplementationStatus('MOVEMENT_SYSTEM') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Occupied tile validation', 'isValidMove should reject moves to occupied tiles')
        return
      }

      try {
        const unit = createMockUnit({ 
          id: 'unit1', 
          position: { x: 5, y: 5 }, 
          moveRange: 2 
        })
        const blockingUnit = createMockUnit({ 
          id: 'unit2', 
          position: { x: 6, y: 5 } 
        })
        const target = { x: 6, y: 5 }

        const result = isValidMove(unit, target, { board: mockBoard, units: [unit, blockingUnit] })
        
        if (result === undefined) {
          expectImplementation('Occupied tile validation', 'isValidMove should return boolean, got undefined')
          return
        }

        expect(result).toBe(false)
      } catch (error) {
        expectImplementation('Occupied tile validation', `Occupied tile validation not implemented: ${error}`)
      }
    })

    it('should reject moves to obstacle tiles', () => {
      if (getImplementationStatus('MOVEMENT_SYSTEM') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Obstacle validation', 'isValidMove should reject moves to obstacle tiles')
        return
      }

      try {
        const unit = createMockUnit({ 
          id: 'unit1', 
          position: { x: 5, y: 5 }, 
          moveRange: 2 
        })
        
        const boardWithObstacle = Array(10).fill(null).map((_, y) => 
          Array(10).fill(null).map((_, x) => {
            if (x === 6 && y === 5) return { type: TileType.OBSTACLE, x, y }
            return { type: TileType.NORMAL, x, y }
          })
        )
        
        const target = { x: 6, y: 5 }

        const result = isValidMove(unit, target, { board: boardWithObstacle, units: [unit] })
        
        if (result === undefined) {
          expectImplementation('Obstacle validation', 'isValidMove should return boolean, got undefined')
          return
        }

        expect(result).toBe(false)
      } catch (error) {
        expectImplementation('Obstacle validation', `Obstacle validation not implemented: ${error}`)
      }
    })
  })

  describe('Utility Functions', () => {
    it('should find units within specified range', () => {
      if (getImplementationStatus('MOVEMENT_SYSTEM') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Unit range detection', 'getUnitsInRange should find units within range')
        return
      }

      try {
        const unit = createMockUnit({ 
          id: 'unit1', 
          position: { x: 5, y: 5 } 
        })
        
        const nearbyUnit = createMockUnit({ 
          id: 'unit2', 
          position: { x: 6, y: 5 } 
        })
        
        const farUnit = createMockUnit({ 
          id: 'unit3', 
          position: { x: 8, y: 5 } 
        })

        const result = getUnitsInRange(unit.position, 2, [unit, nearbyUnit, farUnit])
        
        if (result === undefined) {
          expectImplementation('Unit range detection', 'getUnitsInRange should return array, got undefined')
          return
        }

        expect(result).toContain(nearbyUnit)
        expect(result).not.toContain(farUnit)
        expect(result).not.toContain(unit) // Should not include self
      } catch (error) {
        expectImplementation('Unit range detection', `Unit range detection not implemented: ${error}`)
      }
    })

    it('should find the nearest unit with optional filtering', () => {
      if (getImplementationStatus('MOVEMENT_SYSTEM') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Nearest unit detection', 'findNearestUnit should find closest unit with filtering')
        return
      }

      try {
        const unit = createMockUnit({ 
          id: 'unit1', 
          position: { x: 5, y: 5 } 
        })
        
        const nearbyUnit = createMockUnit({ 
          id: 'unit2', 
          position: { x: 6, y: 5 },
          playerId: 'player2'
        })
        
        const farUnit = createMockUnit({ 
          id: 'unit3', 
          position: { x: 8, y: 5 },
          playerId: 'player2'
        })

        const result = findNearestUnit(unit.position, [unit, nearbyUnit, farUnit], u => u.playerId === 'player2')
        
        if (result === undefined) {
          expectImplementation('Nearest unit detection', 'findNearestUnit should return Unit or undefined, got undefined')
          return
        }

        expect(result).toBe(nearbyUnit)
      } catch (error) {
        expectImplementation('Nearest unit detection', `Nearest unit detection not implemented: ${error}`)
      }
    })

    it('should calculate Manhattan distance correctly', () => {
      try {
        const pos1 = { x: 5, y: 5 }
        const pos2 = { x: 7, y: 3 }

        const result = getDistance(pos1, pos2)
        
        if (result === undefined) {
          expectImplementation('Distance calculation', 'getDistance should return number, got undefined')
          return
        }

        expect(result).toBe(4) // |7-5| + |3-5| = 2 + 2 = 4
      } catch (error) {
        expectImplementation('Distance calculation', `getDistance function not implemented: ${error}`)
      }
    })

    it('should return 0 for same position', () => {
      try {
        const pos1 = { x: 5, y: 5 }
        const pos2 = { x: 5, y: 5 }

        const result = getDistance(pos1, pos2)
        
        if (result === undefined) {
          expectImplementation('Distance calculation', 'getDistance should return number, got undefined')
          return
        }

        expect(result).toBe(0)
      } catch (error) {
        expectImplementation('Distance calculation', `getDistance function not implemented: ${error}`)
      }
    })
  })
})
===== ./src/game/core/targeting.ts =====
import { type Unit, type Coordinate, type Ability, type Tile } from 'shared'

/**
 * Core targeting logic for complex targeting patterns like cones, lines, and areas
 * This module contains pure functions for determining valid targets based on
 * different targeting patterns and ranges.
 */

export interface TargetingContext {
  source: Unit
  ability: Ability
  board: Tile[][]
  units: Unit[]
}

export interface TargetingResult {
  validTargets: (Unit | Coordinate)[]
  invalidTargets: (Unit | Coordinate)[]
  reason?: string
}

/**
 * Get all valid targets for a given ability and targeting pattern
 */
export function getValidTargets(
  context: TargetingContext,
  pattern: 'single' | 'line' | 'cone' | 'area' | 'self'
): TargetingResult {
  const { source: _source, ability: _ability, board: _board, units: _units } = context
  void _source; void _ability; void _board; void _units; // Suppress unused variable warnings
  
  switch (pattern) {
    case 'single':
      return getSingleTargets(context)
    case 'line':
      return getLineTargets(context)
    case 'cone':
      return getConeTargets(context)
    case 'area':
      return getAreaTargets(context)
    case 'self':
      return getSelfTargets(context)
    default:
      return { validTargets: [], invalidTargets: [], reason: 'Unknown targeting pattern' }
  }
}

/**
 * Single target selection - any unit or coordinate within range
 */
function getSingleTargets(context: TargetingContext): TargetingResult {
  const { source, ability, board, units } = context
  const validTargets: (Unit | Coordinate)[] = []
  const invalidTargets: (Unit | Coordinate)[] = []
  
  // Check range
  const range = ability.range || 1
  
  for (const unit of units) {
    if (unit.id === source.id) continue // Can't target self for single target
    
    const distance = getDistance(source.position, unit.position)
    if (distance <= range) {
      validTargets.push(unit)
    } else {
      invalidTargets.push(unit)
    }
  }
  
  // Add empty coordinates within range
  for (let x = 0; x < board[0].length; x++) {
    for (let y = 0; y < board.length; y++) {
      const distance = getDistance(source.position, { x, y })
      if (distance <= range) {
        // Check if this coordinate is empty
        const isEmpty = !units.some(unit => 
          unit.position.x === x && unit.position.y === y
        )
        if (isEmpty) {
          validTargets.push({ x, y })
        }
      }
    }
  }
  
  return { validTargets, invalidTargets }
}

/**
 * Line targeting - targets in a straight line from source
 */
function getLineTargets(context: TargetingContext): TargetingResult {
  const { source, ability, board, units } = context
  const validTargets: (Unit | Coordinate)[] = []
  const invalidTargets: (Unit | Coordinate)[] = []
  
  const range = ability.range || 1
  const directions = [
    { x: 1, y: 0 },   // Right
    { x: -1, y: 0 },  // Left
    { x: 0, y: 1 },   // Down
    { x: 0, y: -1 },  // Up
    { x: 1, y: 1 },   // Down-Right
    { x: -1, y: 1 },  // Down-Left
    { x: 1, y: -1 },  // Up-Right
    { x: -1, y: -1 }  // Up-Left
  ]
  
  for (const direction of directions) {
    for (let distance = 1; distance <= range; distance++) {
      const targetX = source.position.x + (direction.x * distance)
      const targetY = source.position.y + (direction.y * distance)
      
      // Check bounds
      if (targetX < 0 || targetX >= board[0].length || 
          targetY < 0 || targetY >= board.length) {
        break
      }
      
      const targetPos = { x: targetX, y: targetY }
      
      // Check if there's a unit at this position
      const unitAtPosition = units.find(unit => 
        unit.position.x === targetX && unit.position.y === targetY
      )
      
      if (unitAtPosition) {
        validTargets.push(unitAtPosition)
        break // Line stops at first unit
      } else {
        validTargets.push(targetPos)
      }
    }
  }
  
  return { validTargets, invalidTargets }
}

/**
 * Cone targeting - targets in a cone shape from source
 */
function getConeTargets(context: TargetingContext): TargetingResult {
  const { source, ability, board, units } = context
  const validTargets: (Unit | Coordinate)[] = []
  const invalidTargets: (Unit | Coordinate)[] = []
  
  const range = ability.range || 1
  const coneWidth = (ability as Ability & { coneWidth?: number }).coneWidth || 1
  
  // For simplicity, implement a basic cone pattern
  // In a real implementation, you'd want more sophisticated cone math
  for (let distance = 1; distance <= range; distance++) {
    for (let offset = -coneWidth; offset <= coneWidth; offset++) {
      const targetX = source.position.x + distance
      const targetY = source.position.y + offset
      
      // Check bounds
      if (targetX < 0 || targetX >= board[0].length || 
          targetY < 0 || targetY >= board.length) {
        continue
      }
      
      const targetPos = { x: targetX, y: targetY }
      
      // Check if there's a unit at this position
      const unitAtPosition = units.find(unit => 
        unit.position.x === targetX && unit.position.y === targetY
      )
      
      if (unitAtPosition) {
        validTargets.push(unitAtPosition)
      } else {
        validTargets.push(targetPos)
      }
    }
  }
  
  return { validTargets, invalidTargets }
}

/**
 * Area targeting - targets in an area around a point
 */
function getAreaTargets(context: TargetingContext): TargetingResult {
  const { source, ability, board, units } = context
  const validTargets: (Unit | Coordinate)[] = []
  const invalidTargets: (Unit | Coordinate)[] = []
  
  const range = ability.range || 1
  // const _areaSize = (ability as Ability & { areaSize?: number }).areaSize || 1 // Currently unused
  
  // Check all positions within range
  for (let x = 0; x < board[0].length; x++) {
    for (let y = 0; y < board.length; y++) {
      const distance = getDistance(source.position, { x, y })
      if (distance <= range) {
        const targetPos = { x, y }
        
        // Check if there's a unit at this position
        const unitAtPosition = units.find(unit => 
          unit.position.x === x && unit.position.y === y
        )
        
        if (unitAtPosition) {
          validTargets.push(unitAtPosition)
        } else {
          validTargets.push(targetPos)
        }
      }
    }
  }
  
  return { validTargets, invalidTargets }
}

/**
 * Self targeting - can only target the source unit
 */
function getSelfTargets(context: TargetingContext): TargetingResult {
  const { source } = context
  return {
    validTargets: [source],
    invalidTargets: []
  }
}

/**
 * Calculate Manhattan distance between two coordinates
 */
function getDistance(pos1: Coordinate, pos2: Coordinate): number {
  return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y)
}

/**
 * Check if a target is valid for a specific ability
 */
export function isValidTarget(
  source: Unit,
  target: Unit | Coordinate,
  ability: Ability,
  board: Tile[][],
  units: Unit[]
): boolean {
  const context: TargetingContext = { source, ability, board, units }
  
  // Check if target is friendly for enemy-only abilities
  if ('id' in target && ability.targetType === 'enemy') {
    if (target.playerId === source.playerId) {
      return false // Can't target friendly units with enemy-only abilities
    }
  }
  
  // Check if target is enemy for ally-only abilities
  if ('id' in target && ability.targetType === 'ally') {
    if (target.playerId !== source.playerId) {
      return false // Can't target enemy units with ally-only abilities
    }
  }
  
  // Determine targeting pattern based on ability
  const pattern = (ability as Ability & { targetingPattern?: 'self' | 'single' | 'line' | 'cone' | 'area' }).targetingPattern || 'single'
  const result = getValidTargets(context, pattern)
  
  return result.validTargets.some(validTarget => 
    'id' in target ? 
      'id' in validTarget && validTarget.id === target.id :
      'x' in validTarget && validTarget.x === target.x && validTarget.y === target.y
  )
}

/**
 * Calculates tiles within a cone defined by a direction vector
 * Used for directional abilities like paperclip_storm
 */
export function getTilesInCone(
  casterPosition: Coordinate,
  direction: Coordinate,
  range: number,
  coneAngleDegrees: number
): Coordinate[] {
  const affectedTiles: Coordinate[] = []
  const coneAngleRadians = (coneAngleDegrees / 2) * (Math.PI / 180)

  // Normalize the direction vector
  const mag = Math.sqrt(direction.x * direction.x + direction.y * direction.y)
  if (mag === 0) return [] // Avoid division by zero
  const normDir = { x: direction.x / mag, y: direction.y / mag }

  // Check all tiles within a bounding box of the range
  for (let x = casterPosition.x - range; x <= casterPosition.x + range; x++) {
    for (let y = casterPosition.y - range; y <= casterPosition.y + range; y++) {
      const distance = Math.abs(x - casterPosition.x) + Math.abs(y - casterPosition.y) // Manhattan distance
      if (distance > range || (x === casterPosition.x && y === casterPosition.y)) continue

      const vectorToTarget = { x: x - casterPosition.x, y: y - casterPosition.y }
      const magTarget = Math.sqrt(vectorToTarget.x * vectorToTarget.x + vectorToTarget.y * vectorToTarget.y)
      if (magTarget === 0) continue

      // Calculate dot product to find the angle between the direction and the target
      const dotProduct = (normDir.x * vectorToTarget.x + normDir.y * vectorToTarget.y) / magTarget
      const angle = Math.acos(Math.max(-1, Math.min(1, dotProduct))) // Angle in radians, clamp to avoid NaN

      if (angle <= coneAngleRadians) {
        affectedTiles.push({ x, y })
      }
    }
  }
  return affectedTiles
}

===== ./src/game/core/victory.ts =====
import { type Unit, type Tile, TileType, type GamePhase } from 'shared'

/**
 * Pure victory condition utility functions that can be used by both the game store and AI system.
 * These functions take the required state as parameters, making them easily testable and reusable.
 */

export interface VictoryState {
  units: Unit[]
  board: Tile[][]
  players: Array<{ id: string; controlledCubicles: number }>
  phase: GamePhase
}

export interface VictoryResult {
  hasWinner: boolean
  winner?: string
  reason?: string
}

/**
 * Get cubicle data from the board (cached for performance)
 * @param board - The game board
 * @returns Object containing cubicle count and positions
 */
export function getCubicleData(board: Tile[][]) {
  const cubicles = board.flat().filter(t => t.type === TileType.CUBICLE)
  return {
    totalCubicles: cubicles.length,
    count: cubicles.length, // Keep both for compatibility
    positions: cubicles.map(t => ({ x: t.x, y: t.y }))
  }
}

/**
 * Check if a player has won by eliminating all enemy units
 * @param state - The current game state
 * @returns VictoryResult indicating if there's a winner
 */
export function checkEliminationVictory(state: VictoryState): VictoryResult {
  const p1Units = state.units.filter((u) => u.playerId === 'player1' && u.hp > 0)
  const p2Units = state.units.filter((u) => u.playerId === 'player2' && u.hp > 0)

  if (p1Units.length === 0) {
    return {
      hasWinner: true,
      winner: 'player2',
      reason: 'Player 1 has no units left'
    }
  }

  if (p2Units.length === 0) {
    return {
      hasWinner: true,
      winner: 'player1',
      reason: 'Player 2 has no units left'
    }
  }

  return { hasWinner: false }
}

/**
 * Check if a player has won by controlling 51% of capture points
 * @param state - The current game state
 * @returns VictoryResult indicating if there's a winner
 */
export function checkCapturePointVictory(state: VictoryState): VictoryResult {
  const cubicleData = getCubicleData(state.board)
  const totalCapturePoints = cubicleData.count

  if (totalCapturePoints === 0) {
    return { hasWinner: false }
  }

  const VICTORY_THRESHOLD = Math.ceil(totalCapturePoints * 0.51) // 51% rule
  
  for (const player of state.players) {
    if (player.controlledCubicles >= VICTORY_THRESHOLD) {
      return {
        hasWinner: true,
        winner: player.id,
        reason: `Player ${player.id} controls ${player.controlledCubicles}/${totalCapturePoints} capture points (>= ${VICTORY_THRESHOLD})`
      }
    }
  }

  return { hasWinner: false }
}

/**
 * Check all victory conditions
 * @param state - The current game state
 * @returns VictoryResult indicating if there's a winner and why
 */
export function checkVictoryConditions(state: VictoryState): VictoryResult {
  // Check elimination victory first (immediate)
  const eliminationResult = checkEliminationVictory(state)
  if (eliminationResult.hasWinner) {
    return eliminationResult
  }

  // Check capture point victory (51% rule)
  const captureResult = checkCapturePointVictory(state)
  if (captureResult.hasWinner) {
    return captureResult
  }

  return { hasWinner: false }
}

/**
 * Get the current capture point ownership distribution
 * @param state - The current game state
 * @returns Object with capture point statistics
 */
export function getCapturePointStats(state: VictoryState) {
  const cubicleData = getCubicleData(state.board)
  const totalCapturePoints = cubicleData.count

  const stats = {
    totalCapturePoints,
    player1Controlled: state.players.find(p => p.id === 'player1')?.controlledCubicles || 0,
    player2Controlled: state.players.find(p => p.id === 'player2')?.controlledCubicles || 0,
    unclaimed: totalCapturePoints - (state.players.reduce((sum, p) => sum + p.controlledCubicles, 0))
  }

  return {
    ...stats,
    player1Percentage: totalCapturePoints > 0 ? (stats.player1Controlled / totalCapturePoints) * 100 : 0,
    player2Percentage: totalCapturePoints > 0 ? (stats.player2Controlled / totalCapturePoints) * 100 : 0,
    victoryThreshold: totalCapturePoints > 0 ? Math.ceil(totalCapturePoints * 0.51) : 0
  }
}

/**
 * Check if a player is close to victory (within 2 capture points of winning)
 * @param state - The current game state
 * @returns Object indicating if any player is close to victory
 */
export function checkCloseToVictory(state: VictoryState) {
  const stats = getCapturePointStats(state)
  
  return {
    player1Close: stats.player1Controlled >= stats.victoryThreshold - 2,
    player2Close: stats.player2Controlled >= stats.victoryThreshold - 2,
    stats
  }
}

/**
 * Get the most valuable capture points (unclaimed or enemy-controlled)
 * @param state - The current game state
 * @param playerId - The player to check for
 * @returns Array of coordinates for valuable capture points
 */
export function getValuableCapturePoints(state: VictoryState, playerId: string) {
  const cubicleData = getCubicleData(state.board)
  
  return cubicleData.positions.filter(coord => {
    const tile = state.board[coord.y]?.[coord.x]
    if (!tile || tile.type !== TileType.CUBICLE) return false
    
    // Valuable if unclaimed or controlled by enemy
    return !tile.owner || tile.owner !== playerId
  })
}

===== ./src/game/core/movement.ts =====
import { type Unit, type Tile, type Coordinate, TileType } from 'shared'
import { mapRegistry } from '../map/MapRegistry'

/**
 * Pure movement utility functions that can be used by both the game store and AI system.
 * These functions take the required state as parameters, making them easily testable and reusable.
 */

export interface MovementState {
  board: Tile[][]
  units: Unit[]
}

export interface CombatState {
  units: Unit[]
}

/**
 * Calculate all possible moves for a unit using BFS algorithm
 * @param unit - The unit to calculate moves for
 * @param state - The current game state (board and units)
 * @returns Array of valid move coordinates
 */
export function calculatePossibleMoves(unit: Unit, state: MovementState): Coordinate[] {
  if (unit.remainingMovement <= 0 || unit.actionsRemaining === 0) return []

  const { board, units } = state
  const moves: Coordinate[] = []
  const visited = new Set<string>()
  const queue: { coord: Coordinate; distance: number }[] = [{ coord: unit.position, distance: 0 }]

  // Get blocked tiles from MapRegistry for additional movement validation
  const blockedTiles = mapRegistry.getBlockedTiles('OfficeLayout') || []
  const blockedSet = new Set(blockedTiles.map(t => `${t.x},${t.y}`))

  while (queue.length > 0) {
    const { coord, distance } = queue.shift()!
    const key = `${coord.x},${coord.y}`
    if (visited.has(key)) continue
    visited.add(key)

    if (distance > 0 && distance <= unit.remainingMovement) {
      const tile = board[coord.y]?.[coord.x]
      const occupant = units.find((u) => u.position.x === coord.x && u.position.y === coord.y)
      const isBlockedByTilemap = blockedSet.has(`${coord.x},${coord.y}`)
      
      // Check both board tile type and tilemap blocked status
      if (tile && tile.type !== TileType.OBSTACLE && !occupant && !isBlockedByTilemap) {
        moves.push(coord)
      }
    }

    if (distance < unit.remainingMovement) {
      const neighbors = [
        { x: coord.x + 1, y: coord.y },
        { x: coord.x - 1, y: coord.y },
        { x: coord.x, y: coord.y + 1 },
        { x: coord.x, y: coord.y - 1 },
      ]
      for (const neighbor of neighbors) {
        if (
          neighbor.x >= 0 &&
          neighbor.x < board[0].length &&
          neighbor.y >= 0 &&
          neighbor.y < board.length
        ) {
          queue.push({ coord: neighbor, distance: distance + 1 })
        }
      }
    }
  }
  
  console.log('Movement calculation for unit:', {
    unitId: unit.id,
    position: unit.position,
    moveRange: unit.moveRange,
    remainingMovement: unit.remainingMovement,
    totalMoves: moves.length,
    blockedTilesCount: blockedTiles.length,
    boardObstacles: board.flat().filter(t => t.type === TileType.OBSTACLE).length
  })
  
  return moves
}

/**
 * Check if a move is valid for a unit
 * @param unit - The unit attempting to move
 * @param to - The destination coordinate
 * @param state - The current game state
 * @returns True if the move is valid
 */
export function isValidMove(unit: Unit, to: Coordinate, state: MovementState): boolean {
  const possibleMoves = calculatePossibleMoves(unit, state)
  return possibleMoves.some((m) => m.x === to.x && m.y === to.y)
}

/**
 * Get all units within a specific range of a position
 * @param position - The center position
 * @param range - The range to search within
 * @param units - Array of units to search through
 * @returns Array of units within range
 */
export function getUnitsInRange(position: Coordinate, range: number, units: Unit[]): Unit[] {
  return units.filter(unit => {
    const distance = Math.abs(unit.position.x - position.x) + Math.abs(unit.position.y - position.y)
    return distance <= range
  })
}

/**
 * Get the distance between two coordinates using Manhattan distance
 * @param from - Starting coordinate
 * @param to - Target coordinate
 * @returns Manhattan distance between the coordinates
 */
export function getDistance(from: Coordinate, to: Coordinate): number {
  return Math.abs(to.x - from.x) + Math.abs(to.y - from.y)
}

/**
 * Calculate the direction from one coordinate to another
 * @param from - Starting coordinate
 * @param to - Target coordinate
 * @returns Direction as 'up', 'down', 'left', or 'right'
 */
export function getDirection(from: Coordinate, to: Coordinate): 'up' | 'down' | 'left' | 'right' {
  const dx = to.x - from.x
  const dy = to.y - from.y
  
  // If no movement, return current direction or default
  if (dx === 0 && dy === 0) return 'down'
  
  // Determine primary direction based on larger delta
  if (Math.abs(dx) > Math.abs(dy)) {
    return dx > 0 ? 'right' : 'left'
  } else {
    return dy > 0 ? 'down' : 'up'
  }
}

/**
 * Find the nearest unit to a given position
 * @param position - The reference position
 * @param units - Array of units to search through
 * @param filter - Optional filter function to exclude certain units
 * @returns The nearest unit, or undefined if none found
 */
export function findNearestUnit(
  position: Coordinate, 
  units: Unit[], 
  filter?: (unit: Unit) => boolean
): Unit | undefined {
  const filteredUnits = filter ? units.filter(filter) : units
  if (filteredUnits.length === 0) return undefined

  let nearest = filteredUnits[0]
  let nearestDistance = getDistance(position, nearest.position)

  for (let i = 1; i < filteredUnits.length; i++) {
    const distance = getDistance(position, filteredUnits[i].position)
    if (distance < nearestDistance) {
      nearest = filteredUnits[i]
      nearestDistance = distance
    }
  }

  return nearest
}

/**
 * Find the nearest coordinate to a given position from a list of coordinates
 * @param position - The reference position
 * @param coordinates - Array of coordinates to search through
 * @returns The nearest coordinate, or undefined if none found
 */
export function findNearestCoordinate(
  position: Coordinate, 
  coordinates: Coordinate[]
): Coordinate | undefined {
  if (coordinates.length === 0) return undefined

  let nearest = coordinates[0]
  let nearestDistance = getDistance(position, nearest)

  for (let i = 1; i < coordinates.length; i++) {
    const distance = getDistance(position, coordinates[i])
    if (distance < nearestDistance) {
      nearest = coordinates[i]
      nearestDistance = distance
    }
  }

  return nearest
}

export function calculatePossibleTargets(unit: Unit, state: CombatState): Coordinate[] {
  const targets: Coordinate[] = []
  
  for (const enemy of state.units) {
    if (enemy.playerId === unit.playerId) continue
    
    const distance = getDistance(unit.position, enemy.position)
    if (distance <= unit.attackRange) {
      targets.push(enemy.position)
    }
  }
  
  return targets
}

===== ./src/game/core/abilities.ts =====
import { type Unit, StatusType, type Coordinate, type Ability, TargetType, AbilityTargetingType, type Tile, type DataAbility } from 'shared'
import { dataManager } from '../data/DataManager'

// Get ability from DataManager
export function getAbilityById(id: string, unit?: Unit): Ability {
  console.log(`ðM-^_M-^TM-^M getAbilityById: Looking for ability "${id}"`)
  
  const dataAbility = dataManager.getAbility(id)
  if (!dataAbility) {
    // This is no longer a silent failure.
    throw new Error(`Ability data for "${id}" not found or not loaded.`)
  }
  
  console.log(`âM-^\M-^E getAbilityById: Found data ability for "${id}":`, dataAbility)
  const converted = convertDataAbilityToLegacyAbility(dataAbility, unit?.attackRange)
  console.log(`ðM-^_M-^TM-^D getAbilityById: Converted ability:`, converted)
  return converted
}

// Convert DataAbility to legacy Ability format
function convertDataAbilityToLegacyAbility(dataAbility: DataAbility, unitAttackRange?: number): Ability {
  let targetType: TargetType = TargetType.ENEMY; // Default
  if (dataAbility.effects.some(e => e.target === 'ally')) {
    targetType = TargetType.ALLY;
  } else if (dataAbility.effects.some(e => e.target === 'self')) {
    targetType = TargetType.SELF;
  } else if (dataAbility.effects.some(e => e.target === 'all_allies')) {
    targetType = TargetType.ALL_ALLIES;
  } else if (dataAbility.effects.some(e => e.target === 'all_enemies')) {
    targetType = TargetType.ALL_ENEMIES;
  }

  // --- CRITICAL FIX ---
  // Use the unit's actual attackRange as the ability's range for consistency.
  const range = unitAttackRange ?? 1;
  // --- END FIX ---

  // Determine targeting type from range pattern
  let targetingType = AbilityTargetingType.SINGLE_TARGET
  if (dataAbility.range_pattern_key === 'forward_cone') {
    targetingType = AbilityTargetingType.AOE_CONE
  } else if (dataAbility.range_pattern_key === 'centered_cross_burst') {
    targetingType = AbilityTargetingType.AOE_CIRCLE
  } else if (dataAbility.range_pattern_key === 'all_allies') {
    targetingType = AbilityTargetingType.ALL_ALLIES
  } else if (dataAbility.range_pattern_key === 'all_enemies') {
    targetingType = AbilityTargetingType.ALL_ENEMIES
  } else if (dataAbility.range_pattern_key === 'self_target') {
    targetingType = AbilityTargetingType.SELF_BUFF
  }

  return {
    id: dataAbility.key,
    name: dataAbility.name,
    description: dataAbility.description,
    cost: 1, // Default cost
    cooldown: dataAbility.cooldown_turns,
    range: range, // Use the corrected range
    targetType: targetType,
    targetingType: targetingType,
    effect: () => {
      // Process effects from JSON
      const results = dataAbility.effects.map((effect) => {
        switch (effect.type) {
          case 'damage':
            return { damageDealt: effect.value || 0 }
          case 'heal':
            return { healingDone: effect.value || 0 }
          case 'action_bonus':
            return { actionBonus: effect.value || 0 }
          case 'apply_status_effect': {
            // Map status keys to StatusType enum
            let statusType: StatusType
            switch (effect.status_key) {
              case 'on_deadline':
                statusType = StatusType.ON_DEADLINE
                break
              case 'exhausted':
                statusType = StatusType.EXHAUSTED
                break
              case 'written_up':
                statusType = StatusType.WRITTEN_UP
                break
              case 'harassed':
                statusType = StatusType.HARASSED
                break
              case 'confused':
                statusType = StatusType.CONFUSED
                break
              case 'focused':
                statusType = StatusType.FOCUSED
                break
              case 'stunned':
                statusType = StatusType.STUNNED
                break
              case 'shielded':
                statusType = StatusType.SHIELDED
                break
              case 'inspired':
                statusType = StatusType.INSPIRED
                break
              case 'increase_speed':
                statusType = StatusType.INSPIRED // Use inspired as a speed boost
                break
              case 'bleeding':
                statusType = StatusType.POISONED // Use poisoned as bleeding effect
                break
              case 'fire':
                statusType = StatusType.BURNING
                break
              default:
                statusType = StatusType.CONFUSED // Default fallback
            }
            return { statusApplied: [{ type: statusType, duration: 2 }] }
          }
          case 'cleanse_status':
            return { message: `Status effects cleansed` }
          case 'create_tile_hazard':
            // For now, just return success - tile hazards need more complex implementation
            return { message: `${dataAbility.name} creates a hazard` }
          default:
            return {}
        }
      })
      
      return {
        success: true,
        message: `${dataAbility.name} used`,
        ...results.reduce((acc: Record<string, unknown>, result: Record<string, unknown>) => ({ ...acc, ...result }), {})
      }
    },
    visualEffect: 'default',
    soundEffect: 'default',
    range_pattern_key: dataAbility.range_pattern_key,
  } as Ability
}


// Helper functions for ability system

export function getUnitAbilities(unit: Unit): Ability[] {
  // Get abilities from unit's abilities array (populated by DataManager)
  return unit.abilities.map(abilityId => getAbilityById(abilityId, unit))
}

export function canUseAbility(unit: Unit, abilityId: string): boolean {
  try {
    const ability = getAbilityById(abilityId, unit)
    
    // Check if unit has access to this ability
    if (!unit.abilities.includes(abilityId)) return false
    
    // Check cooldown
    const currentCooldown = unit.abilityCooldowns[abilityId] || 0
    if (currentCooldown > 0) return false
    
    // Check action cost
    if (unit.actionsRemaining < ability.cost) return false
    
    return true
  } catch (error) {
    console.error('Error checking ability usage:', error)
    return false
  }
}

export function getValidTargets(unit: Unit, ability: Ability, board: Tile[][], units: Unit[]): (Unit | Coordinate)[] {
  const targets: (Unit | Coordinate)[] = []
  
  switch (ability.targetType) {
    case TargetType.SELF:
      targets.push(unit)
      break
    case TargetType.ALLY:
    case TargetType.ENEMY:
      // Find units in range using the units array
      for (const targetUnit of units) {
        // Skip the caster unit
        if (targetUnit.id === unit.id) continue
        
        const distance = Math.abs(unit.position.x - targetUnit.position.x) + Math.abs(unit.position.y - targetUnit.position.y)
        if (distance <= ability.range) {
          if (ability.targetType === TargetType.ALLY && targetUnit.playerId === unit.playerId) {
            targets.push(targetUnit)
          } else if (ability.targetType === TargetType.ENEMY && targetUnit.playerId !== unit.playerId) {
            targets.push(targetUnit)
          }
        }
      }
      break
    case TargetType.TILE:
      // Find tiles in range
      for (let y = 0; y < board.length; y++) {
        for (let x = 0; x < board[y].length; x++) {
          const distance = Math.abs(unit.position.x - x) + Math.abs(unit.position.y - y)
          if (distance <= ability.range) {
            targets.push({ x, y })
          }
        }
      }
      break
  }
  
  return targets
}



===== ./src/game/core/victory.test.ts =====
import { describe, it, expect, beforeEach } from 'vitest'
import { 
  checkVictoryConditions, 
  getCubicleData, 
  getCapturePointStats, 
  getValuableCapturePoints 
} from './victory'
import { createMockUnit, createMockGameState } from '../test/helpers'
import { TileType, GamePhase, type GameState, type Tile } from 'shared'

describe('Victory System', () => {
  let mockGameState: GameState
  let mockBoard: Tile[][]

  beforeEach(() => {
    mockGameState = createMockGameState()
    mockBoard = mockGameState.board
  })

  describe('checkVictoryConditions', () => {
    it('should declare Player 1 the winner if all Player 2 units are eliminated', () => {
      const player1Units = [
        createMockUnit({ id: 'p1_unit1', playerId: 'player1' }),
        createMockUnit({ id: 'p1_unit2', playerId: 'player1' })
      ]
      
      // No player2 units
      const units = player1Units
      const players = [
        { id: 'player1', controlledCubicles: 0 },
        { id: 'player2', controlledCubicles: 0 }
      ]

      const result = checkVictoryConditions({ units, board: mockBoard, players, phase: GamePhase.PLAYING })

      expect(result.winner).toBe('player1')
      expect(result.reason).toBe('elimination')
    })

    it('should declare Player 2 the winner if they control over 51% of the cubicles', () => {
      const units = [
        createMockUnit({ id: 'p1_unit1', playerId: 'player1' }),
        createMockUnit({ id: 'p2_unit1', playerId: 'player2' })
      ]
      
      // Create a board with 10 cubicles, player2 controls 6 (60%)
      const boardWithCubicles = Array(10).fill(null).map((_, y) => 
        Array(10).fill(null).map((_, x) => {
          if (x < 6 && y === 0) return { type: TileType.CUBICLE, x, y, owner: 'player2' }
          if (x >= 6 && y === 0) return { type: TileType.CUBICLE, x, y, owner: 'player1' }
          return { type: TileType.NORMAL, x, y, owner: undefined }
        })
      )
      
      const players = [
        { id: 'player1', controlledCubicles: 4 },
        { id: 'player2', controlledCubicles: 6 }
      ]

      const result = checkVictoryConditions({ units, board: boardWithCubicles, players, phase: GamePhase.PLAYING })

      expect(result.winner).toBe('player2')
      expect(result.reason).toBe('capture_points')
    })

    it('should return no winner if neither condition is met', () => {
      const units = [
        createMockUnit({ id: 'p1_unit1', playerId: 'player1' }),
        createMockUnit({ id: 'p2_unit1', playerId: 'player2' })
      ]
      
      const players = [
        { id: 'player1', controlledCubicles: 5 },
        { id: 'player2', controlledCubicles: 5 }
      ]

      const result = checkVictoryConditions({ units, board: mockBoard, players, phase: GamePhase.PLAYING })

      expect(result.winner).toBe(null)
      expect(result.reason).toBe(null)
    })

    it('should handle edge case of exactly 50% cubicle control', () => {
      const units = [
        createMockUnit({ id: 'p1_unit1', playerId: 'player1' }),
        createMockUnit({ id: 'p2_unit1', playerId: 'player2' })
      ]
      
      const players = [
        { id: 'player1', controlledCubicles: 5 },
        { id: 'player2', controlledCubicles: 5 }
      ]

      const result = checkVictoryConditions({ units, board: mockBoard, players, phase: GamePhase.PLAYING })

      expect(result.winner).toBe(null)
      expect(result.reason).toBe(null)
    })
  })

  describe('getCubicleData', () => {
    it('should extract capture point information from board', () => {
      const boardWithCubicles = Array(5).fill(null).map((_, y) => 
        Array(5).fill(null).map((_, x) => {
          if (x === 0 && y === 0) return { type: TileType.CUBICLE, x, y, owner: 'player1' }
          if (x === 1 && y === 0) return { type: TileType.CUBICLE, x, y, owner: 'player2' }
          if (x === 2 && y === 0) return { type: TileType.CUBICLE, x, y, owner: undefined }
          return { type: TileType.NORMAL, x, y, owner: undefined }
        })
      )

      const result = getCubicleData(boardWithCubicles)

      expect(result.totalCubicles).toBe(3)
      expect(result.count).toBe(3)
      expect(result.positions).toHaveLength(3)
    })

    it('should handle board with no cubicles', () => {
      const result = getCubicleData(mockBoard)

      expect(result.totalCubicles).toBe(0)
      expect(result.count).toBe(0)
      expect(result.positions).toHaveLength(0)
    })
  })

  describe('getCapturePointStats', () => {
    it('should return detailed victory statistics', () => {
      const boardWithCubicles = Array(5).fill(null).map((_, y) => 
        Array(5).fill(null).map((_, x) => {
          if (x === 0 && y === 0) return { type: TileType.CUBICLE, x, y, owner: 'player1' }
          if (x === 1 && y === 0) return { type: TileType.CUBICLE, x, y, owner: 'player2' }
          if (x === 2 && y === 0) return { type: TileType.CUBICLE, x, y, owner: undefined }
          return { type: TileType.NORMAL, x, y, owner: undefined }
        })
      )

      const players = [
        { id: 'player1', controlledCubicles: 1 },
        { id: 'player2', controlledCubicles: 1 }
      ]

      const result = getCapturePointStats({ units: [], board: boardWithCubicles, players, phase: GamePhase.PLAYING })

      expect(result.totalCapturePoints).toBe(3)
      expect(result.player1Percentage).toBeCloseTo(33.33, 1)
      expect(result.player2Percentage).toBeCloseTo(33.33, 1)
      expect(result.unclaimed).toBe(1)
      expect(result.victoryThreshold).toBe(2) // Need 2 more to reach 51%
    })
  })

  describe('getValuableCapturePoints', () => {
    it('should find strategic positions for AI targeting', () => {
      const boardWithCubicles = Array(5).fill(null).map((_, y) => 
        Array(5).fill(null).map((_, x) => {
          if (x === 0 && y === 0) return { type: TileType.CUBICLE, x, y, owner: 'player1' }
          if (x === 1 && y === 0) return { type: TileType.CUBICLE, x, y, owner: 'player2' }
          if (x === 2 && y === 0) return { type: TileType.CUBICLE, x, y, owner: undefined }
          return { type: TileType.NORMAL, x, y, owner: undefined }
        })
      )

      const result = getValuableCapturePoints({ units: [], board: boardWithCubicles, players: [], phase: GamePhase.PLAYING }, 'player1')

      // Should prioritize neutral and enemy-controlled cubicles
      expect(result).toContainEqual({ x: 2, y: 0 }) // Neutral
      expect(result).toContainEqual({ x: 1, y: 0 }) // Enemy-controlled
      expect(result).not.toContainEqual({ x: 0, y: 0 }) // Own cubicle
    })

    it('should return empty array if no valuable targets', () => {
      const boardWithOwnCubicles = Array(5).fill(null).map((_, y) => 
        Array(5).fill(null).map((_, x) => {
          if (x === 0 && y === 0) return { type: TileType.CUBICLE, x, y, owner: 'player1' }
          if (x === 1 && y === 0) return { type: TileType.CUBICLE, x, y, owner: 'player1' }
          return { type: TileType.NORMAL, x, y, owner: undefined }
        })
      )

      const result = getValuableCapturePoints({ units: [], board: boardWithOwnCubicles, players: [], phase: GamePhase.PLAYING }, 'player1')

      expect(result).toHaveLength(0)
    })
  })
})

===== ./src/game/core/combat.test.ts =====
import { describe, it, expect, beforeEach } from 'vitest'
import { 
  calculatePossibleTargets, 
  isValidAttack, 
  calculateDamage,
  getEnemiesInRange,
  getWeakestEnemyInRange,
  getStrongestEnemyInRange,
  canAttackAnyEnemy,
  canKillTargetThisTurn
} from './combat'
import { createMockUnit } from '../test/helpers'

describe('Combat System', () => {
  beforeEach(() => {
    // Test setup if needed
  })

  describe('calculateDamage', () => {
    it('should correctly calculate damage using unit\'s attackDamage', () => {
      const attacker = createMockUnit({ 
        id: 'attacker', 
        attackDamage: 3 
      })
      const target = createMockUnit({ 
        id: 'target', 
        hp: 5 
      })

      const result = calculateDamage(attacker, target)

      expect(result).toBe(3)
    })

    it('should handle different attack damage values', () => {
      const attacker = createMockUnit({ 
        id: 'attacker', 
        attackDamage: 5 
      })
      const target = createMockUnit({ 
        id: 'target', 
        hp: 10 
      })

      const result = calculateDamage(attacker, target)

      expect(result).toBe(5)
    })
  })

  describe('calculatePossibleTargets', () => {
    it('should validate an attack at the exact maximum attackRange', () => {
      const attacker = createMockUnit({ 
        id: 'attacker', 
        position: { x: 5, y: 5 }, 
        attackRange: 2 
      })
      
      const target = createMockUnit({ 
        id: 'target', 
        position: { x: 7, y: 5 }, 
        playerId: 'player2' 
      })

      const result = calculatePossibleTargets(attacker, { units: [attacker, target] })

      expect(result).toContainEqual({ x: 7, y: 5 })
    })

    it('should not include targets beyond attack range', () => {
      const attacker = createMockUnit({ 
        id: 'attacker', 
        position: { x: 5, y: 5 }, 
        attackRange: 2 
      })
      
      const target = createMockUnit({ 
        id: 'target', 
        position: { x: 8, y: 5 }, 
        playerId: 'player2' 
      })

      const result = calculatePossibleTargets(attacker, { units: [attacker, target] })

      expect(result).not.toContainEqual({ x: 8, y: 5 })
    })

    it('should not allow a unit to target friendly units', () => {
      const attacker = createMockUnit({ 
        id: 'attacker', 
        position: { x: 5, y: 5 }, 
        attackRange: 2,
        playerId: 'player1'
      })
      
      const friendlyTarget = createMockUnit({ 
        id: 'friendly', 
        position: { x: 6, y: 5 }, 
        playerId: 'player1' 
      })

      const result = calculatePossibleTargets(attacker, { units: [attacker, friendlyTarget] })

      expect(result).not.toContainEqual({ x: 6, y: 5 })
    })

    it('should include enemy units within range', () => {
      const attacker = createMockUnit({ 
        id: 'attacker', 
        position: { x: 5, y: 5 }, 
        attackRange: 2,
        playerId: 'player1'
      })
      
      const enemyTarget = createMockUnit({ 
        id: 'enemy', 
        position: { x: 6, y: 5 }, 
        playerId: 'player2' 
      })

      const result = calculatePossibleTargets(attacker, { units: [attacker, enemyTarget] })

      expect(result).toContainEqual({ x: 6, y: 5 })
    })
  })

  describe('isValidAttack', () => {
    it('should validate attacks within range', () => {
      const attacker = createMockUnit({ 
        id: 'attacker', 
        position: { x: 5, y: 5 }, 
        attackRange: 2,
        playerId: 'player1'
      })
      
      const target = createMockUnit({ 
        id: 'target', 
        position: { x: 6, y: 5 }, 
        playerId: 'player2' 
      })

      const result = isValidAttack(attacker, target, { units: [attacker, target] })

      expect(result).toBe(true)
    })

    it('should reject attacks on friendly units', () => {
      const attacker = createMockUnit({ 
        id: 'attacker', 
        position: { x: 5, y: 5 }, 
        attackRange: 2,
        playerId: 'player1'
      })
      
      const friendlyTarget = createMockUnit({ 
        id: 'friendly', 
        position: { x: 6, y: 5 }, 
        playerId: 'player1' 
      })

      const result = isValidAttack(attacker, friendlyTarget, { units: [attacker, friendlyTarget] })

      expect(result).toBe(false)
    })

    it('should reject attacks beyond range', () => {
      const attacker = createMockUnit({ 
        id: 'attacker', 
        position: { x: 5, y: 5 }, 
        attackRange: 1,
        playerId: 'player1'
      })
      
      const target = createMockUnit({ 
        id: 'target', 
        position: { x: 7, y: 5 }, 
        playerId: 'player2' 
      })

      const result = isValidAttack(attacker, target, { units: [attacker, target] })

      expect(result).toBe(false)
    })
  })

  describe('getEnemiesInRange', () => {
    it('should find enemies within attack range', () => {
      const unit = createMockUnit({ 
        id: 'unit1', 
        position: { x: 5, y: 5 }, 
        attackRange: 2,
        playerId: 'player1'
      })
      
      const enemy1 = createMockUnit({ 
        id: 'enemy1', 
        position: { x: 6, y: 5 }, 
        playerId: 'player2' 
      })
      
      const enemy2 = createMockUnit({ 
        id: 'enemy2', 
        position: { x: 8, y: 5 }, 
        playerId: 'player2' 
      })

      const result = getEnemiesInRange(unit, { units: [unit, enemy1, enemy2] })

      expect(result).toContain(enemy1)
      expect(result).not.toContain(enemy2)
      expect(result).not.toContain(unit)
    })
  })

  describe('getWeakestEnemyInRange', () => {
    it('should find the enemy with lowest HP in range', () => {
      const unit = createMockUnit({ 
        id: 'unit1', 
        position: { x: 5, y: 5 }, 
        attackRange: 2,
        playerId: 'player1'
      })
      
      const weakEnemy = createMockUnit({ 
        id: 'weak', 
        position: { x: 6, y: 5 }, 
        playerId: 'player2',
        hp: 1
      })
      
      const strongEnemy = createMockUnit({ 
        id: 'strong', 
        position: { x: 6, y: 6 }, 
        playerId: 'player2',
        hp: 5
      })

      const result = getWeakestEnemyInRange(unit, { units: [unit, weakEnemy, strongEnemy] })

      expect(result).toBe(weakEnemy)
    })
  })

  describe('getStrongestEnemyInRange', () => {
    it('should find the enemy with highest HP in range', () => {
      const unit = createMockUnit({ 
        id: 'unit1', 
        position: { x: 5, y: 5 }, 
        attackRange: 2,
        playerId: 'player1'
      })
      
      const weakEnemy = createMockUnit({ 
        id: 'weak', 
        position: { x: 6, y: 5 }, 
        playerId: 'player2',
        hp: 1
      })
      
      const strongEnemy = createMockUnit({ 
        id: 'strong', 
        position: { x: 6, y: 6 }, 
        playerId: 'player2',
        hp: 5
      })

      const result = getStrongestEnemyInRange(unit, { units: [unit, weakEnemy, strongEnemy] })

      expect(result).toBe(strongEnemy)
    })
  })

  describe('canAttackAnyEnemy', () => {
    it('should return true if any enemies are in range', () => {
      const unit = createMockUnit({ 
        id: 'unit1', 
        position: { x: 5, y: 5 }, 
        attackRange: 2,
        playerId: 'player1'
      })
      
      const enemy = createMockUnit({ 
        id: 'enemy', 
        position: { x: 6, y: 5 }, 
        playerId: 'player2' 
      })

      const result = canAttackAnyEnemy(unit, { units: [unit, enemy] })

      expect(result).toBe(true)
    })

    it('should return false if no enemies are in range', () => {
      const unit = createMockUnit({ 
        id: 'unit1', 
        position: { x: 5, y: 5 }, 
        attackRange: 1,
        playerId: 'player1'
      })
      
      const enemy = createMockUnit({ 
        id: 'enemy', 
        position: { x: 7, y: 5 }, 
        playerId: 'player2' 
      })

      const result = canAttackAnyEnemy(unit, { units: [unit, enemy] })

      expect(result).toBe(false)
    })
  })

  describe('canKillTargetThisTurn', () => {
    it('should return true if attacker can kill target in one hit', () => {
      const attacker = createMockUnit({ 
        id: 'attacker', 
        attackDamage: 5,
        playerId: 'player1'
      })
      
      const target = createMockUnit({ 
        id: 'target', 
        hp: 3,
        playerId: 'player2' 
      })

      const result = canKillTargetThisTurn(target, { units: [attacker, target] })

      expect(result).toBe(true)
    })

    it('should return false if attacker cannot kill target in one hit', () => {
      const attacker = createMockUnit({ 
        id: 'attacker', 
        attackDamage: 2,
        playerId: 'player1'
      })
      
      const target = createMockUnit({ 
        id: 'target', 
        hp: 5,
        playerId: 'player2' 
      })

      const result = canKillTargetThisTurn(target, { units: [attacker, target] })

      expect(result).toBe(false)
    })
  })
})

===== ./src/game/core/abilities.test.ts =====
import { describe, it, expect, beforeEach } from 'vitest'
import { getAbilityById, getUnitAbilities, canUseAbility, getValidTargets } from './abilities'
import { createMockUnit, createMockGameState } from '../test/helpers.ts'
import { UnitType, type GameState, type Unit } from 'shared'
import { expectImplementation, getImplementationStatus, TestStatus } from '../test/testHelpers'

describe('Ability System', () => {
  let mockGameState: GameState

  beforeEach(() => {
    mockGameState = createMockGameState()
  })

  describe('Ability Definitions', () => {
    it('should have all required abilities defined', () => {
      const requiredAbilities = [
        'fetch_coffee', 'overtime', 'file_it', 'harass', 'pink_slip', 
        'mediation', 'hack_system', 'tech_support', 'audit', 
        'creative_accounting', 'legal_threat', 'contract_negotiation',
        'executive_order', 'corporate_restructuring', 'paperclip_storm'
      ]
      
      requiredAbilities.forEach(abilityId => {
        const ability = getAbilityById(abilityId)
        expect(ability).toBeDefined()
        expect(ability!.id).toBe(abilityId)
        expect(ability!.name).toBeDefined()
        expect(ability!.description).toBeDefined()
        expect(ability!.cost).toBeGreaterThanOrEqual(0)
        expect(ability!.cost).toBeLessThanOrEqual(3)
        expect(ability!.cooldown).toBeGreaterThanOrEqual(-1)
        expect(ability!.range).toBeGreaterThanOrEqual(0)
      })
    })

    it('should have paperclip_storm as directional ability', () => {
      const ability = getAbilityById('paperclip_storm')
      expect(ability).toBeDefined()
      expect(ability!.requiresDirection).toBe(true)
      expect(ability!.coneAngle).toBe(90)
      expect(ability!.targetingType).toBe('aoe_cone')
    })
  })

  describe('Ability Usage Validation', () => {
    it('should check if unit has required actions to use ability', () => {
      // This test expects the canUseAbility function to work properly
      // If it's not implemented, we'll get a clear error
      try {
      const unit = createMockUnit({ actionsRemaining: 0 })
      const ability = getAbilityById('fetch_coffee')
      
        const result = canUseAbility(unit, ability!.id)
        
        // If we get here, the function exists but might not work correctly
        if (result === undefined) {
          expectImplementation('Ability action validation', 'canUseAbility should return boolean, got undefined')
          return
        }
        
        expect(result).toBe(false)
      
      unit.actionsRemaining = 1
      expect(canUseAbility(unit, ability!.id)).toBe(true)
      } catch (error) {
        expectImplementation('Ability action validation', `canUseAbility function not implemented: ${error}`)
      }
    })

    it('should check if unit has the required ability', () => {
      try {
      const unit = createMockUnit({ abilities: [] })
      const ability = getAbilityById('fetch_coffee')
      
        const result = canUseAbility(unit, ability!.id)
        
        if (result === undefined) {
          expectImplementation('Ability ownership validation', 'canUseAbility should return boolean, got undefined')
          return
        }
        
        expect(result).toBe(false)
      
      unit.abilities = [ability!.id]
      expect(canUseAbility(unit, ability!.id)).toBe(true)
      } catch (error) {
        expectImplementation('Ability ownership validation', `canUseAbility function not implemented: ${error}`)
      }
    })

    it('should check ability cooldowns', () => {
      // This is a more complex feature that likely needs implementation
      if (getImplementationStatus('ABILITY_COOLDOWNS') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Ability cooldown system', 'Units should track ability cooldowns and prevent usage during cooldown')
        return
      }

      const unit = createMockUnit({ 
        abilities: ['fetch_coffee'],
        abilityCooldowns: { 'fetch_coffee': 2 }
      })
      
      expect(canUseAbility(unit, 'fetch_coffee')).toBe(false)
    })
  })

  describe('Ability Targeting', () => {
    it('should return valid targets for ally-targeting abilities', () => {
      // This test expects getValidTargets to work with proper board/unit integration
      if (getImplementationStatus('ABILITY_TARGETING') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Ability targeting system', 'getValidTargets should find valid targets based on ability type and range')
        return
      }

      try {
        const caster = createMockUnit({ 
          id: 'caster', 
          playerId: 'player1',
          position: { x: 5, y: 5 }
        })
        const ally = createMockUnit({ 
          id: 'ally', 
          playerId: 'player1',
          position: { x: 6, y: 5 }
        })
        const enemy = createMockUnit({ 
          id: 'enemy', 
          playerId: 'player2',
          position: { x: 7, y: 5 }
        })
      
      const ability = getAbilityById('fetch_coffee')
        const targets = getValidTargets(caster, ability!, mockGameState.board, [caster, ally, enemy])
        
        if (targets === undefined) {
          expectImplementation('Ability targeting', 'getValidTargets should return array, got undefined')
          return
        }
      
      expect(targets).toContain(ally)
      expect(targets).not.toContain(enemy)
      } catch (error) {
        expectImplementation('Ability targeting', `getValidTargets function not implemented: ${error}`)
      }
    })

    it('should return valid targets for enemy-targeting abilities', () => {
      if (getImplementationStatus('ABILITY_TARGETING') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Enemy targeting', 'getValidTargets should find enemy targets for enemy-targeting abilities')
        return
      }

      try {
        const caster = createMockUnit({ 
          id: 'caster', 
          playerId: 'player1',
          position: { x: 5, y: 5 }
        })
        const ally = createMockUnit({ 
          id: 'ally', 
          playerId: 'player1',
          position: { x: 6, y: 5 }
        })
        const enemy = createMockUnit({ 
          id: 'enemy', 
          playerId: 'player2',
          position: { x: 7, y: 5 }
        })
      
      const ability = getAbilityById('file_it')
        const targets = getValidTargets(caster, ability!, mockGameState.board, [caster, ally, enemy])
        
        if (targets === undefined) {
          expectImplementation('Enemy targeting', 'getValidTargets should return array, got undefined')
          return
        }
      
      expect(targets).toContain(enemy)
      expect(targets).not.toContain(ally)
      } catch (error) {
        expectImplementation('Enemy targeting', `getValidTargets function not implemented: ${error}`)
      }
    })

    it('should respect ability range limits', () => {
      if (getImplementationStatus('ABILITY_TARGETING') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Range validation', 'getValidTargets should respect ability range limits')
        return
      }

      try {
        const caster = createMockUnit({ 
          id: 'caster', 
          playerId: 'player1',
          position: { x: 5, y: 5 }
        })
      const nearbyEnemy = createMockUnit({ 
          id: 'nearby', 
        playerId: 'player2', 
          position: { x: 6, y: 5 } // 1 tile away
      })
      const farEnemy = createMockUnit({ 
          id: 'far', 
        playerId: 'player2', 
          position: { x: 9, y: 5 } // 4 tiles away
        })
        
        const ability = getAbilityById('file_it') // Range 3
        const targets = getValidTargets(caster, ability!, mockGameState.board, [caster, nearbyEnemy, farEnemy])
        
        if (targets === undefined) {
          expectImplementation('Range validation', 'getValidTargets should return array, got undefined')
          return
        }
      
      expect(targets).toContain(nearbyEnemy)
        expect(targets).not.toContain(farEnemy)
      } catch (error) {
        expectImplementation('Range validation', `getValidTargets function not implemented: ${error}`)
      }
    })
  })

  describe('Unit Ability Mappings', () => {
    it('should assign correct abilities to each unit type', () => {
      // This tests the unit abilities mapping
      try {
        const mockIntern: Unit = {
          id: 'test-intern',
          playerId: 'player1',
          type: UnitType.INTERN,
          position: { x: 0, y: 0 },
          hp: 2,
          maxHp: 2,
          moveRange: 3,
          attackRange: 1,
          attackDamage: 1,
          actionsRemaining: 2,
          maxActions: 2,
          status: [],
          cost: 2,
          hasMoved: false,
          hasAttacked: false,
          abilities: ['fetch_coffee', 'overtime'],
          abilityCooldowns: {},
          movementUsed: 0,
          remainingMovement: 3,
          direction: 'down',
        }
        
        expect(getUnitAbilities(mockIntern)).toHaveLength(2)
      } catch (error) {
        expectImplementation('Unit ability mappings', `getUnitAbilities function not implemented: ${error}`)
      }
    })
  })

  describe('Helper Functions', () => {
    it('should return ability by ID', () => {
      try {
      const ability = getAbilityById('fetch_coffee')
      expect(ability).toBeDefined()
        expect(ability?.id).toBe('fetch_coffee')
      } catch (error) {
        expectImplementation('Ability lookup', `getAbilityById function not implemented: ${error}`)
      }
    })

    it('should return undefined for unknown ability ID', () => {
      try {
        const ability = getAbilityById('unknown_ability')
        expect(ability).toBeUndefined()
      } catch (error) {
        expectImplementation('Unknown ability handling', `getAbilityById should handle unknown IDs: ${error}`)
      }
    })
  })

  describe('Edge Cases', () => {
    it('should handle units with no abilities', () => {
      if (getImplementationStatus('ABILITY_COOLDOWNS') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Empty abilities handling', 'System should handle units with no abilities gracefully')
        return
      }

      try {
      const unit = createMockUnit({ abilities: [] })
      
      expect(canUseAbility(unit, 'fetch_coffee')).toBe(false)
        expect(getValidTargets(unit, getAbilityById('fetch_coffee')!, mockGameState.board, [unit])).toEqual([])
      } catch (error) {
        expectImplementation('Empty abilities handling', `System should handle empty abilities: ${error}`)
      }
    })

    it('should handle board boundaries correctly', () => {
      if (getImplementationStatus('ABILITY_TARGETING') === TestStatus.IMPLEMENTATION_NEEDED) {
        expectImplementation('Board boundary handling', 'Targeting should respect board boundaries')
        return
      }

      try {
        const unit = createMockUnit({ 
          position: { x: 0, y: 0 } // Edge of board
        })
      const edgeTarget = createMockUnit({ 
          position: { x: 0, y: 1 } // Adjacent to edge
        })
        
        const ability = getAbilityById('fetch_coffee')
        const targets = getValidTargets(unit, ability!, mockGameState.board, [unit, edgeTarget])
        
        if (targets === undefined) {
          expectImplementation('Board boundary handling', 'getValidTargets should return array, got undefined')
          return
        }
        
      expect(targets).toContain(edgeTarget)
      } catch (error) {
        expectImplementation('Board boundary handling', `Board boundary handling not implemented: ${error}`)
      }
    })
  })
})
===== ./src/game/core/combat.ts =====
import { type Unit, type Coordinate } from 'shared'

/**
 * Pure combat utility functions that can be used by both the game store and AI system.
 * These functions take the required state as parameters, making them easily testable and reusable.
 */

export interface CombatState {
  units: Unit[]
}

/**
 * Calculate all possible attack targets for a unit
 * @param unit - The unit to calculate targets for
 * @param state - The current game state (units)
 * @returns Array of valid target coordinates
 */
export function calculatePossibleTargets(unit: Unit, state: CombatState): Coordinate[] {
  if (unit.hasAttacked || unit.actionsRemaining === 0) return []
  
  const { units } = state
  const targets: Coordinate[] = []
  
  for (const enemy of units) {
    if (enemy.playerId === unit.playerId) continue
    const distance = Math.abs(enemy.position.x - unit.position.x) + Math.abs(enemy.position.y - unit.position.y)
    if (distance <= unit.attackRange) {
      targets.push(enemy.position)
      console.log('Valid attack target found:', {
        targetId: enemy.id,
        targetType: enemy.type,
        distance,
        attackRange: unit.attackRange,
        targetPosition: enemy.position
      })
    }
  }
  
  console.log('Calculated possible targets for unit:', {
    unitId: unit.id,
    unitType: unit.type,
    attackRange: unit.attackRange,
    targetCount: targets.length,
    targets
  })
  
  return targets
}

/**
 * Check if an attack is valid
 * @param attacker - The attacking unit
 * @param target - The target unit
 * @param state - The current game state
 * @returns True if the attack is valid
 */
export function isValidAttack(attacker: Unit, target: Unit, state: CombatState): boolean {
  const possibleTargets = calculatePossibleTargets(attacker, state)
  return possibleTargets.some((t) => t.x === target.position.x && t.y === target.position.y)
}

/**
 * Calculate damage dealt by an attacker to a target
 * @param attacker - The attacking unit
 * @param target - The target unit
 * @returns The damage amount
 */
export function calculateDamage(attacker: Unit, target: Unit): number {
  // Base damage is the attacker's attack damage
  const baseDamage = attacker.attackDamage
  
  // Simple damage calculation - can be enhanced later
  // For now, just return the base damage, ensuring it's at least 1
  // Target parameter is available for future damage calculations based on target stats
  // Currently not using target stats, but keeping parameter for future enhancements
  void target // Suppress unused parameter warning
  
  return Math.max(1, baseDamage)
}

/**
 * Get all enemy units within attack range of a unit
 * @param unit - The attacking unit
 * @param state - The current game state
 * @returns Array of enemy units within range
 */
export function getEnemiesInRange(unit: Unit, state: CombatState): Unit[] {
  const { units } = state
  return units.filter(enemy => {
    if (enemy.playerId === unit.playerId) return false
    const distance = Math.abs(enemy.position.x - unit.position.x) + Math.abs(enemy.position.y - unit.position.y)
    return distance <= unit.attackRange
  })
}

/**
 * Find the weakest enemy within attack range
 * @param unit - The attacking unit
 * @param state - The current game state
 * @returns The weakest enemy unit, or undefined if none found
 */
export function getWeakestEnemyInRange(unit: Unit, state: CombatState): Unit | undefined {
  const enemiesInRange = getEnemiesInRange(unit, state)
  if (enemiesInRange.length === 0) return undefined

  return enemiesInRange.reduce((weakest, current) => 
    current.hp < weakest.hp ? current : weakest
  )
}

/**
 * Find the strongest enemy within attack range
 * @param unit - The attacking unit
 * @param state - The current game state
 * @returns The strongest enemy unit, or undefined if none found
 */
export function getStrongestEnemyInRange(unit: Unit, state: CombatState): Unit | undefined {
  const enemiesInRange = getEnemiesInRange(unit, state)
  if (enemiesInRange.length === 0) return undefined

  return enemiesInRange.reduce((strongest, current) => 
    current.hp > strongest.hp ? current : strongest
  )
}

/**
 * Check if a unit can attack any enemy
 * @param unit - The unit to check
 * @param state - The current game state
 * @returns True if the unit can attack any enemy
 */
export function canAttackAnyEnemy(unit: Unit, state: CombatState): boolean {
  return getEnemiesInRange(unit, state).length > 0
}

/**
 * Get all units that can attack a specific target
 * @param target - The target unit
 * @param state - The current game state
 * @returns Array of units that can attack the target
 */
export function getUnitsThatCanAttack(target: Unit, state: CombatState): Unit[] {
  const { units } = state
  return units.filter(unit => {
    if (unit.playerId === target.playerId) return false
    if (unit.hasAttacked || unit.actionsRemaining === 0) return false
    const distance = Math.abs(unit.position.x - target.position.x) + Math.abs(unit.position.y - target.position.y)
    return distance <= unit.attackRange
  })
}

/**
 * Calculate the total damage that can be dealt to a target by all possible attackers
 * @param target - The target unit
 * @param state - The current game state
 * @returns Total potential damage
 */
export function calculateTotalDamageToTarget(target: Unit, state: CombatState): number {
  const attackers = getUnitsThatCanAttack(target, state)
  return attackers.reduce((total, attacker) => total + calculateDamage(attacker, target), 0)
}

/**
 * Check if a unit can be killed in one turn by available attackers
 * @param target - The target unit
 * @param state - The current game state
 * @returns True if the target can be killed this turn
 */
export function canKillTargetThisTurn(target: Unit, state: CombatState): boolean {
  const totalDamage = calculateTotalDamageToTarget(target, state)
  return totalDamage >= target.hp
}

===== ./src/game/core/targeting.test.ts =====
import { describe, it, expect } from 'vitest'
import { getTilesInCone, isValidTarget } from './targeting'
import { createMockUnit } from '../test/helpers'
import { AbilityTargetingType, TargetType } from 'shared'

describe('Targeting System', () => {
  describe('getTilesInCone', () => {
    it('should return the correct tiles for a 90-degree cone facing right', () => {
      const casterPosition = { x: 5, y: 5 }
      const direction = { x: 1, y: 0 } // Facing right
      const range = 3
      const coneAngle = 90

      const result = getTilesInCone(casterPosition, direction, range, coneAngle)

      // Should include tiles to the right of the caster
      expect(result).toContainEqual({ x: 6, y: 5 })
      expect(result).toContainEqual({ x: 7, y: 5 })
      expect(result).toContainEqual({ x: 8, y: 5 })
      
      // Should include diagonal tiles within cone
      expect(result).toContainEqual({ x: 6, y: 4 })
      expect(result).toContainEqual({ x: 6, y: 6 })
      
      // Should not include tiles behind the caster
      expect(result).not.toContainEqual({ x: 4, y: 5 })
      expect(result).not.toContainEqual({ x: 3, y: 5 })
    })

    it('should return the correct tiles for a 45-degree cone facing diagonally', () => {
      const casterPosition = { x: 5, y: 5 }
      const direction = { x: 1, y: 1 } // Facing diagonally down-right
      const range = 2
      const coneAngle = 45

      const result = getTilesInCone(casterPosition, direction, range, coneAngle)

      // Should include tiles in the diagonal direction
      expect(result).toContainEqual({ x: 6, y: 6 })
      expect(result).toContainEqual({ x: 7, y: 7 })
      
      // Should not include tiles too far from the direction
      expect(result).not.toContainEqual({ x: 6, y: 5 })
      expect(result).not.toContainEqual({ x: 5, y: 6 })
    })

    it('should return an empty array if the direction vector is zero', () => {
      const casterPosition = { x: 5, y: 5 }
      const direction = { x: 0, y: 0 }
      const range = 3
      const coneAngle = 90

      const result = getTilesInCone(casterPosition, direction, range, coneAngle)

      expect(result).toEqual([])
    })

    it('should respect the range limit and not include tiles beyond it', () => {
      const casterPosition = { x: 5, y: 5 }
      const direction = { x: 1, y: 0 }
      const range = 2
      const coneAngle = 90

      const result = getTilesInCone(casterPosition, direction, range, coneAngle)

      // Should not include tiles beyond range
      expect(result).not.toContainEqual({ x: 8, y: 5 })
      expect(result).not.toContainEqual({ x: 9, y: 5 })
      
      // Should include tiles within range
      expect(result).toContainEqual({ x: 6, y: 5 })
      expect(result).toContainEqual({ x: 7, y: 5 })
    })

    it('should not include the caster position itself', () => {
      const casterPosition = { x: 5, y: 5 }
      const direction = { x: 1, y: 0 }
      const range = 3
      const coneAngle = 90

      const result = getTilesInCone(casterPosition, direction, range, coneAngle)

      expect(result).not.toContainEqual({ x: 5, y: 5 })
    })
  })

  describe('isValidTarget', () => {
    it('should validate single target abilities correctly', () => {
      const source = createMockUnit({ id: 'source', position: { x: 5, y: 5 }, playerId: 'player1' })
      const target = createMockUnit({ id: 'target', position: { x: 6, y: 5 }, playerId: 'player2' })
      const ability = {
        id: 'test_ability',
        name: 'Test Ability',
        description: 'Test ability for testing',
        cost: 1,
        cooldown: 0,
        range: 2,
        targetType: TargetType.ENEMY,
        targetingType: AbilityTargetingType.SINGLE_TARGET,
        effect: () => ({ success: true })
      }
      const board = Array(10).fill(null).map(() => Array(10).fill({ type: 'NORMAL' }))
      const units = [source, target]

      const result = isValidTarget(source, target, ability, board, units)

      expect(result).toBe(true)
    })

    it('should reject targets outside range', () => {
      const source = createMockUnit({ id: 'source', position: { x: 5, y: 5 }, playerId: 'player1' })
      const target = createMockUnit({ id: 'target', position: { x: 8, y: 5 }, playerId: 'player2' })
      const ability = {
        id: 'test_ability',
        name: 'Test Ability',
        description: 'Test ability for testing',
        cost: 1,
        cooldown: 0,
        range: 2,
        targetType: TargetType.ENEMY,
        targetingType: AbilityTargetingType.SINGLE_TARGET,
        effect: () => ({ success: true })
      }
      const board = Array(10).fill(null).map(() => Array(10).fill({ type: 'NORMAL' }))
      const units = [source, target]

      const result = isValidTarget(source, target, ability, board, units)

      expect(result).toBe(false)
    })

    it('should reject friendly targets for enemy-only abilities', () => {
      const source = createMockUnit({ id: 'source', position: { x: 5, y: 5 }, playerId: 'player1' })
      const target = createMockUnit({ id: 'target', position: { x: 6, y: 5 }, playerId: 'player1' })
      const ability = {
        id: 'test_ability',
        name: 'Test Ability',
        description: 'Test ability for testing',
        cost: 1,
        cooldown: 0,
        range: 2,
        targetType: TargetType.ENEMY,
        targetingType: AbilityTargetingType.SINGLE_TARGET,
        effect: () => ({ success: true })
      }
      const board = Array(10).fill(null).map(() => Array(10).fill({ type: 'NORMAL' }))
      const units = [source, target]

      const result = isValidTarget(source, target, ability, board, units)

      expect(result).toBe(false)
    })
  })
})

===== ./src/game/test/helpers.ts =====
import { type Unit, type GameState, type Player, type Tile, UnitType, StatusType, TileType, Team, GamePhase } from 'shared'

export function createMockUnit(overrides: Partial<Unit> = {}): Unit {
  return {
    id: 'test-unit-1',
    type: UnitType.INTERN,
    playerId: 'player1',
    position: { x: 0, y: 0 },
    hp: 10,
    maxHp: 10,
    moveRange: 2,
    attackRange: 1,
    attackDamage: 3,
    actionsRemaining: 2,
    maxActions: 2,
    hasMoved: false,
    hasAttacked: false,
    abilities: ['fetch_coffee', 'overtime'],
    abilityCooldowns: {},
    status: [],
    cost: 100,
    movementUsed: 0,
    remainingMovement: 2,
    direction: 'down',
    ...overrides
  }
}

export function createMockPlayer(overrides: Partial<Player> = {}): Player {
  return {
    id: 'player1',
    name: 'Test Player',
    team: Team.BLUE,
    budget: 1000,
    income: 100,
    controlledCubicles: 0,
    ...overrides
  }
}

export function createMockTile(overrides: Partial<Tile> = {}): Tile {
  return {
    x: 0,
    y: 0,
    type: TileType.CUBICLE,
    ...overrides
  }
}

export function createMockGameState(overrides: Partial<GameState> = {}): GameState {
  return {
    id: 'test-game',
    board: [
      [createMockTile({ x: 0, y: 0 }), createMockTile({ x: 1, y: 0 }), createMockTile({ x: 2, y: 0 })],
      [createMockTile({ x: 0, y: 1 }), createMockTile({ x: 1, y: 1 }), createMockTile({ x: 2, y: 1 })],
      [createMockTile({ x: 0, y: 2 }), createMockTile({ x: 1, y: 2 }), createMockTile({ x: 2, y: 2 })]
    ],
    units: [createMockUnit()],
    players: [createMockPlayer()],
    currentPlayerId: 'player1',
    turnNumber: 1,
    phase: GamePhase.PLAYING,
    ...overrides
  }
}

export function createMockUnitWithStatus(statusType: StatusType, duration: number = 2): Unit {
  return createMockUnit({
    status: [{ type: statusType, duration, source: 'test' }]
  })
}

export function createMockUnitWithAbilities(abilities: string[]): Unit {
  return createMockUnit({
    abilities,
    abilityCooldowns: {}
  })
}

===== ./src/game/test/testHelpers.ts =====
/**
 * Test Helper Utilities
 * 
 * This file provides utilities to clearly distinguish between:
 * - Tests that are implemented and working
 * - Tests that are not yet implemented (placeholder)
 * - Tests that should work but are failing (needs code fix)
 */

/**
 * Mark a test as not yet implemented
 * This prevents hallucination and clearly indicates work is needed
 */
export function testNotImplemented(feature: string, reason?: string): never {
  const message = reason 
    ? `Test not implemented: ${feature} - ${reason}`
    : `Test not implemented: ${feature}`
  
  throw new Error(`ðM-^_M-^Z§ ${message}`)
}

/**
 * Mark a test as expecting implementation but code is missing
 * This indicates the test is correct but the feature needs to be built
 */
export function expectImplementation(feature: string, expectedBehavior: string): never {
  throw new Error(`ðM-^_M-^T¨ Implementation needed: ${feature} - Expected: ${expectedBehavior}`)
}

/**
 * Mark a test as having incorrect implementation
 * This indicates the code exists but doesn't work as expected
 */
export function expectCorrectImplementation(feature: string, currentBehavior: string, expectedBehavior: string): never {
  throw new Error(`âM-^]M-^L Incorrect implementation: ${feature} - Current: ${currentBehavior}, Expected: ${expectedBehavior}`)
}

/**
 * Test status markers for different implementation states
 */
export const TestStatus = {
  NOT_IMPLEMENTED: 'not_implemented',
  IMPLEMENTATION_NEEDED: 'implementation_needed', 
  INCORRECT_IMPLEMENTATION: 'incorrect_implementation',
  WORKING: 'working'
} as const

export type TestStatus = typeof TestStatus[keyof typeof TestStatus]

/**
 * Conditional test execution based on implementation status
 */
export function conditionalTest(
  status: TestStatus,
  feature: string,
  testFn: () => void,
  reason?: string
) {
  switch (status) {
    case TestStatus.NOT_IMPLEMENTED:
      testFn = () => testNotImplemented(feature, reason)
      break
    case TestStatus.IMPLEMENTATION_NEEDED:
      testFn = () => expectImplementation(feature, reason || 'Feature needs to be implemented')
      break
    case TestStatus.INCORRECT_IMPLEMENTATION:
      testFn = () => expectCorrectImplementation(feature, 'Current behavior', reason || 'Expected behavior')
      break
    case TestStatus.WORKING:
      // Run the actual test
      break
  }
  
  return testFn
}

/**
 * Skip test with clear reason
 */
export function skipTest(reason: string) {
  return `âM-^O­ï¸M-^O Skipped: ${reason}`
}

/**
 * Test implementation checklist
 * Use this to track what's implemented vs what needs work
 */
export const ImplementationChecklist = {
  // Core Game Logic
  TARGETING_SYSTEM: TestStatus.WORKING, // Our new cone targeting works
  MOVEMENT_SYSTEM: TestStatus.IMPLEMENTATION_NEEDED, // Needs proper board integration
  COMBAT_SYSTEM: TestStatus.IMPLEMENTATION_NEEDED, // Needs proper unit integration
  VICTORY_SYSTEM: TestStatus.IMPLEMENTATION_NEEDED, // Needs proper board integration
  
  // Abilities System
  ABILITY_DEFINITIONS: TestStatus.WORKING, // Abilities are defined
  ABILITY_TARGETING: TestStatus.IMPLEMENTATION_NEEDED, // Targeting logic needs work
  ABILITY_EFFECTS: TestStatus.IMPLEMENTATION_NEEDED, // Effect execution needs work
  ABILITY_COOLDOWNS: TestStatus.IMPLEMENTATION_NEEDED, // Cooldown system needs work
  
  // Store System
  UNIT_STORE: TestStatus.IMPLEMENTATION_NEEDED, // Store functions need implementation
  PLAYER_STORE: TestStatus.IMPLEMENTATION_NEEDED, // Store functions need implementation
  BOARD_STORE: TestStatus.IMPLEMENTATION_NEEDED, // Store functions need implementation
  
  // AI System
  AI_DECISION_MAKING: TestStatus.IMPLEMENTATION_NEEDED, // AI methods need implementation
  AI_STRATEGY: TestStatus.IMPLEMENTATION_NEEDED, // AI strategy needs work
} as const

/**
 * Get implementation status for a feature
 */
export function getImplementationStatus(feature: keyof typeof ImplementationChecklist): TestStatus {
  return ImplementationChecklist[feature]
}

/**
 * Mark test as working when implementation is complete
 */
export function markAsWorking(feature: keyof typeof ImplementationChecklist) {
  // In a real implementation, this would update the checklist
  console.log(`âM-^\M-^E ${feature} marked as working`)
}

===== ./src/game/map/MapManager.ts =====
import Phaser from "phaser";
import type { MapSpec, BoardDim } from "./types";
import { mapRegistry } from "./MapRegistry";


export class MapManager {
  private scene: Phaser.Scene;
  private spec: MapSpec;

  constructor(scene: Phaser.Scene, spec: MapSpec) {
    this.scene = scene;
    this.spec = spec;
  }

  preload() {
    const s = this.spec;
    this.scene.load.tilemapTiledJSON(s.jsonKey, s.jsonUrl);
    this.scene.load.image(s.tilesetKey, s.tilesetUrl);
  }

  create() {
    const s = this.spec;
    const map = this.scene.make.tilemap({ key: s.jsonKey });
    const tiles = map.addTilesetImage(s.tilesetName, s.tilesetKey, 16, 16, 0, 0);
    if (!tiles) throw new Error(`Tileset '${s.tilesetName}' not found in map.`);

    const background = map.createLayer(s.backgroundLayerName, tiles, 0, 0)!;
    const foreground = map.createLayer(s.foregroundLayerName, tiles, 0, 0)!;
    const capturePoints = map.createLayer(s.capturePointsLayerName, tiles, 0, 0)!;
    const startingPositions = map.createLayer(s.startingPositionsLayerName, tiles, 0, 0)!;

    const scale = s.targetTileSizePx / map.tileWidth;
    background.setScale(scale);
    foreground.setScale(scale);
    capturePoints.setScale(scale);
    startingPositions.setScale(scale);

    background.setDepth(0);
    foreground.setDepth(1);
    capturePoints.setDepth(2);
    startingPositions.setDepth(3);

    const w = map.width * s.targetTileSizePx;
    const h = map.height * s.targetTileSizePx;
    this.scene.cameras.main.setBounds(0, 0, w, h);
    this.scene.cameras.main.centerOn(w / 2, h / 2);

    // Parse blocked tiles from foreground layer
    const blockedSet = new Set(
      foreground.layer.data.flatMap((row, y) =>
        row.filter(t => t && t.index > 0).map(t => `${t.x},${y}`)
      )
    );
    const isBlocked = (tx: number, ty: number) => foreground.hasTileAt(tx, ty);

    // Parse capture points from capture points layer
    const capturePointsData = capturePoints.layer.data.flatMap((row, y) =>
      row.filter(t => t && t.index > 0).map(t => ({ x: t.x, y: y, gid: t.index }))
    );
    
    // Parse starting positions from starting positions layer
    const startingPositionsData = startingPositions.layer.data.flatMap((row, y) =>
      row.filter(t => t && t.index > 0).map(t => ({ x: t.x, y: y, gid: t.index }))
    );

    const goldTeamPositions = startingPositionsData.filter(pos => pos.gid === 595);
    const navyTeamPositions = startingPositionsData.filter(pos => pos.gid === 563);

    // CRITICAL: Populate the MapRegistry with starting positions
    mapRegistry.setStartingPositions(s.id, {
      goldTeam: goldTeamPositions,
      navyTeam: navyTeamPositions
    });
    
    console.log('MapManager: Populated MapRegistry for', s.id, {
      goldTeam: goldTeamPositions.length,
      navyTeam: navyTeamPositions.length
    });

    // CRITICAL: Store blocked tiles in MapRegistry for movement validation
    const blockedTiles = Array.from(blockedSet).map(coordStr => {
      const [x, y] = coordStr.split(',').map(Number);
      return { x, y };
    });
    mapRegistry.setBlockedTiles(s.id, blockedTiles);
    
    console.log('MapManager: Stored blocked tiles for movement validation:', {
      blockedTiles: blockedTiles.length,
      blockedSet: blockedSet.size
    });

    const blockedMatrix: number[][] = Array.from({ length: map.height }, (_, y) =>
      Array.from({ length: map.width }, (_, x) => (foreground.hasTileAt(x, y) ? 1 : 0))
    );

    const tileToWorld = (tx: number, ty: number) =>
      ({ x: tx * s.targetTileSizePx, y: ty * s.targetTileSizePx });
    const worldToTile = (px: number, py: number) =>
      ({ x: Math.floor(px / s.targetTileSizePx), y: Math.floor(py / s.targetTileSizePx) });

    return {
      map,
      background,
      foreground,
      capturePoints,
      startingPositions,
      board: { cols: map.width, rows: map.height } as BoardDim,
      targetTileSizePx: s.targetTileSizePx,
      tileToWorld,
      worldToTile,
      blocked: blockedSet,
      isBlocked,
      blockedMatrix,
      capturePointsData,
      startingPositionsData,
      goldTeamPositions,
      navyTeamPositions,
      scale
    };
  }
}

===== ./src/game/map/MapRegistry.ts =====
import type { MapSpec, StartingPosition } from "./types"

export type MapStartingPositions = {
  goldTeam: StartingPosition[]
  navyTeam: StartingPosition[]
}

export class MapRegistry {
  private static instance: MapRegistry
  private maps: Map<string, MapSpec> = new Map()
  private startingPositions: Map<string, MapStartingPositions> = new Map()
  private capturePoints: Map<string, StartingPosition[]> = new Map()
  private blockedTiles: Map<string, { x: number; y: number }[]> = new Map()
  private isLoaded = false

  static getInstance(): MapRegistry {
    if (!MapRegistry.instance) {
      MapRegistry.instance = new MapRegistry()
    }
    return MapRegistry.instance
  }

  // Register a map specification
  registerMap(spec: MapSpec): void {
    this.maps.set(spec.id, spec)
  }

  // Get a map specification
  getMap(id: string): MapSpec | undefined {
    return this.maps.get(id)
  }

  // Set starting positions for a map
  setStartingPositions(mapId: string, positions: MapStartingPositions): void {
    this.startingPositions.set(mapId, positions)
  }

  // Get starting positions for a map
  getStartingPositions(mapId: string): MapStartingPositions | undefined {
    return this.startingPositions.get(mapId)
  }

  // Set capture points for a map
  setCapturePoints(mapId: string, points: StartingPosition[]): void {
    this.capturePoints.set(mapId, points)
  }

  // Get capture points for a map
  getCapturePoints(mapId: string): StartingPosition[] | undefined {
    return this.capturePoints.get(mapId)
  }

  // Set blocked tiles for a map
  setBlockedTiles(mapId: string, tiles: { x: number; y: number }[]): void {
    this.blockedTiles.set(mapId, tiles)
  }

  // Get blocked tiles for a map
  getBlockedTiles(mapId: string): { x: number; y: number }[] | undefined {
    return this.blockedTiles.get(mapId)
  }

  // Check if all maps are loaded
  isFullyLoaded(): boolean {
    return this.isLoaded
  }

  // Mark as fully loaded
  setLoaded(loaded: boolean): void {
    this.isLoaded = loaded
  }

  // Get all registered map IDs
  getMapIds(): string[] {
    return Array.from(this.maps.keys())
  }
}

// Global instance
export const mapRegistry = MapRegistry.getInstance()

===== ./src/game/map/types.ts =====
export type MapId = "OfficeLayout";

export type MapSpec = {
  id: MapId;
  jsonKey: string;          // loader key for the json
  jsonUrl: string;          // /assets/tilemaps/OfficeLayout16x12.json
  tilesetKey: string;       // loader key for the image
  tilesetUrl: string;       // /assets/tilesets/inside.png
  tilesetName: string;      // MUST equal the tileset 'name' in Tiled/TSX
  backgroundLayerName: string; // walkable floor tiles
  foregroundLayerName: string; // blocking walls/objects
  capturePointsLayerName: string; // strategic locations
  startingPositionsLayerName: string; // team spawn points
  targetTileSizePx: number; // 48 (game logic grid)
  width: number;            // map width in tiles
  height: number;           // map height in tiles
};

export type BoardDim = { cols: number; rows: number };

export type StartingPosition = { x: number; y: number; gid: number };

===== ./src/game/map/registry.ts =====
import type { MapSpec } from "./types"
import { mapRegistry } from "./MapRegistry"

export const MAPS: Record<string, MapSpec> = {
  OfficeLayout: {
    id: "OfficeLayout",
    jsonKey: "office-map",
    jsonUrl: "/assets/tilemaps/OfficeLayout16x12.json",
    tilesetKey: "office-tiles",
    tilesetUrl: "/assets/tilesets/inside.png",
    tilesetName: "OfficeLayout",   // <-- set to the exact TSX tileset name
    backgroundLayerName: "Background",
    foregroundLayerName: "Foreground",
    capturePointsLayerName: "CapturePoints",
    startingPositionsLayerName: "StartingPoints", // Fixed from "StartingPositions"
    targetTileSizePx: 48,
    width: 16,
    height: 12,
  }
}

// Initialize all maps in the registry
export function initializeMapRegistry(): void {
  Object.values(MAPS).forEach(spec => {
    mapRegistry.registerMap(spec)
  })
  console.log('MapRegistry: Registered maps:', mapRegistry.getMapIds())
}

===== ./src/game/ai/aiDraft.ts =====
import { type DraftUnit } from 'shared'
import { dataManager } from '../data/DataManager'

export function generateAIDraft(budget: number, maxHeadcount: number): DraftUnit[] {
  const draft: DraftUnit[] = []
  let remainingBudget = budget
  
  // Get all available employees from DataManager
  const employees = dataManager.getAllEmployees()
  if (employees.length === 0) {
    console.error('No employees available for AI draft')
    return []
  }
  
  // Sort employees by cost (cheapest first)
  const sortedEmployees = employees.sort((a, b) => a.cost - b.cost)
  
  // AI strategy: Try to get a mix of units within budget
  // Priority: 1 expensive unit if affordable, then mid-tier, fill with cheapest
  
  // Try to get the most expensive unit if affordable
  const mostExpensive = sortedEmployees[sortedEmployees.length - 1]
  if (remainingBudget >= mostExpensive.cost && maxHeadcount > 0) {
    draft.push({ employeeKey: mostExpensive.key })
    remainingBudget -= mostExpensive.cost
    maxHeadcount--
  }
  
  // Add mid-tier units (middle cost range)
  const midTierEmployees = sortedEmployees.filter(emp => 
    emp.cost > sortedEmployees[0].cost && 
    emp.cost < sortedEmployees[sortedEmployees.length - 1].cost
  )
  
  // Add 1-2 mid-tier units if budget allows
  const midTierCount = Math.min(2, Math.floor(remainingBudget / 50), maxHeadcount)
  for (let i = 0; i < midTierCount; i++) {
    const availableMidTier = midTierEmployees.filter(emp => 
      emp.cost <= remainingBudget
    )
    
    if (availableMidTier.length > 0) {
      const selectedEmployee = availableMidTier[Math.floor(Math.random() * availableMidTier.length)]
      draft.push({ employeeKey: selectedEmployee.key })
      remainingBudget -= selectedEmployee.cost
      maxHeadcount--
    }
  }
  
  // Fill remaining slots with cheapest units
  const cheapestEmployee = sortedEmployees[0]
  while (maxHeadcount > 0 && remainingBudget >= cheapestEmployee.cost) {
    draft.push({ employeeKey: cheapestEmployee.key })
    remainingBudget -= cheapestEmployee.cost
    maxHeadcount--
  }
  
  // Ensure at least 2 units for viability
  if (draft.length < 2) {
    // If we don't have enough units, add more cheapest units even if it exceeds budget
    while (draft.length < 2) {
      draft.push({ employeeKey: cheapestEmployee.key })
    }
  }
  
  return draft
}

===== ./src/game/ai/gameStateQueries.ts =====
import { type Unit, type Coordinate, type Tile, type GamePhase, type Player, TileType, GamePhase as GamePhaseEnum } from 'shared'
import { calculatePossibleMoves, calculatePossibleTargets, findNearestUnit, findNearestCoordinate, getDistance } from '../core/movement'
import { getEnemiesInRange, getWeakestEnemyInRange, getStrongestEnemyInRange, canAttackAnyEnemy, getUnitsThatCanAttack, calculateTotalDamageToTarget, canKillTargetThisTurn } from '../core/combat'
import { getValuableCapturePoints, getCapturePointStats, checkCloseToVictory } from '../core/victory'

/**
 * Game State Query Interface
 * 
 * Provides a clean, declarative API for querying game state.
 * This abstracts the data structure from AI decision-making and makes
 * the code more readable and maintainable.
 */

export interface GameState {
  units: Unit[]
  board: Tile[][]
  players: Player[]
  currentPlayerId: string
  phase: GamePhase
  turnNumber: number
}

export interface GameStateQueries {
  // Unit queries
  getMyUnits: (state: GameState) => Unit[]
  getEnemyUnits: (state: GameState) => Unit[]
  getUnitById: (state: GameState, unitId: string) => Unit | undefined
  getUnitsByType: (state: GameState, unitType: string) => Unit[]
  getUnitsByPlayer: (state: GameState, playerId: string) => Unit[]
  
  // Movement queries
  getPossibleMoves: (state: GameState, unit: Unit) => Coordinate[]
  canUnitMove: (state: GameState, unit: Unit) => boolean
  getUnitsInRange: (state: GameState, position: Coordinate, range: number) => Unit[]
  findNearestEnemy: (state: GameState, position: Coordinate, playerId: string) => Unit | undefined
  findNearestObjective: (state: GameState, position: Coordinate, playerId: string) => Coordinate | undefined
  
  // Combat queries
  getPossibleTargets: (state: GameState, unit: Unit) => Coordinate[]
  canUnitAttack: (state: GameState, unit: Unit) => boolean
  getEnemiesInRange: (state: GameState, unit: Unit) => Unit[]
  getWeakestEnemyInRange: (state: GameState, unit: Unit) => Unit | undefined
  getStrongestEnemyInRange: (state: GameState, unit: Unit) => Unit | undefined
  canAttackAnyEnemy: (state: GameState, unit: Unit) => boolean
  getUnitsThatCanAttack: (state: GameState, target: Unit) => Unit[]
  canKillTargetThisTurn: (state: GameState, target: Unit) => boolean
  calculateTotalDamageToTarget: (state: GameState, target: Unit) => number
  
  // Strategic queries
  getValuableCapturePoints: (state: GameState, playerId: string) => Coordinate[]
  getCapturePointStats: (state: GameState) => { totalCapturePoints: number; player1Percentage: number; player2Percentage: number; unclaimed: number; victoryThreshold: number }
  isCloseToVictory: (state: GameState) => { player1Close: boolean; player2Close: boolean; stats: { totalCapturePoints: number; player1Percentage: number; player2Percentage: number; unclaimed: number; victoryThreshold: number } }
  getThreatLevel: (state: GameState, unit: Unit) => number
  getStrategicValue: (state: GameState, position: Coordinate) => number
  
  // Game state queries
  isMyTurn: (state: GameState, playerId: string) => boolean
  getGamePhase: (state: GameState) => GamePhase
  getTurnNumber: (state: GameState) => number
  isGameOver: (state: GameState) => boolean
}

/**
 * Implementation of the Game State Query Interface
 */
export const GameQueries: GameStateQueries = {
  // Unit queries
  getMyUnits: (state) => state.units.filter(unit => unit.playerId === state.currentPlayerId),
  
  getEnemyUnits: (state) => state.units.filter(unit => unit.playerId !== state.currentPlayerId),
  
  getUnitById: (state, unitId) => state.units.find(unit => unit.id === unitId),
  
  getUnitsByType: (state, unitType) => state.units.filter(unit => unit.type === unitType),
  
  getUnitsByPlayer: (state, playerId) => state.units.filter(unit => unit.playerId === playerId),
  
  // Movement queries
  getPossibleMoves: (state, unit) => calculatePossibleMoves(unit, { board: state.board, units: state.units }),
  
  canUnitMove: (_state, unit) => unit.actionsRemaining > 0 && !unit.hasMoved,
  
  getUnitsInRange: (state, position, range) => {
    return state.units.filter(unit => {
      const distance = getDistance(position, unit.position)
      return distance <= range
    })
  },
  
  findNearestEnemy: (state, position, playerId) => {
    return findNearestUnit(position, state.units, unit => unit.playerId !== playerId)
  },
  
  findNearestObjective: (state, position, playerId) => {
    const valuableCubicles = getValuableCapturePoints(state, playerId)
    return findNearestCoordinate(position, valuableCubicles)
  },
  
  // Combat queries
  getPossibleTargets: (state, unit) => calculatePossibleTargets(unit, { units: state.units }),
  
  canUnitAttack: (_state, unit) => unit.actionsRemaining > 0 && !unit.hasAttacked,
  
  getEnemiesInRange: (state, unit) => getEnemiesInRange(unit, { units: state.units }),
  
  getWeakestEnemyInRange: (state, unit) => getWeakestEnemyInRange(unit, { units: state.units }),
  
  getStrongestEnemyInRange: (state, unit) => getStrongestEnemyInRange(unit, { units: state.units }),
  
  canAttackAnyEnemy: (state, unit) => canAttackAnyEnemy(unit, { units: state.units }),
  
  getUnitsThatCanAttack: (state, target) => getUnitsThatCanAttack(target, { units: state.units }),
  
  canKillTargetThisTurn: (state, target) => canKillTargetThisTurn(target, { units: state.units }),
  
  calculateTotalDamageToTarget: (state, target) => calculateTotalDamageToTarget(target, { units: state.units }),
  
  // Strategic queries
  getValuableCapturePoints: (state, playerId) => getValuableCapturePoints(state, playerId),
  
  getCapturePointStats: (state) => getCapturePointStats(state),
  
  isCloseToVictory: (state) => checkCloseToVictory(state),
  
  getThreatLevel: (state, unit) => {
    // Calculate how threatened a unit is based on nearby enemies
    const enemiesInRange = getEnemiesInRange(unit, { units: state.units })
    const totalDamage = enemiesInRange.reduce((total, _enemy) => {
      void _enemy; // Suppress unused parameter warning
      return total + calculateTotalDamageToTarget(unit, { units: state.units })
    }, 0)
    
    // Higher threat if more damage can be dealt to this unit
    return totalDamage / Math.max(unit.hp, 1)
  },
  
  getStrategicValue: (state, position) => {
    // Calculate strategic value of a position
    let value = 0
    
    // Check if it's a capture point
    const tile = state.board[position.y]?.[position.x]
    if (tile?.type === TileType.CUBICLE) {
      value += 10
      
      // Higher value if unclaimed or enemy-controlled
      if (!tile.owner || tile.owner !== state.currentPlayerId) {
        value += 5
      }
    }
    
    // Check proximity to enemies (for attack positioning)
    const enemies = state.units.filter(unit => unit.playerId !== state.currentPlayerId)
    const nearestEnemy = findNearestUnit(position, enemies)
    if (nearestEnemy) {
      const distance = getDistance(position, nearestEnemy.position)
      value += Math.max(0, 5 - distance) // Closer to enemies = higher value
    }
    
    // Check proximity to allies (for support positioning)
    const allies = state.units.filter(unit => unit.playerId === state.currentPlayerId)
    const nearestAlly = findNearestUnit(position, allies)
    if (nearestAlly) {
      const distance = getDistance(position, nearestAlly.position)
      value += Math.max(0, 3 - distance) // Closer to allies = higher value
    }
    
    return value
  },
  
  // Game state queries
  isMyTurn: (state, playerId) => state.currentPlayerId === playerId,
  
  getGamePhase: (state) => state.phase,
  
  getTurnNumber: (state) => state.turnNumber,
  
  isGameOver: (state) => state.phase === GamePhaseEnum.GAME_OVER
}

/**
 * Convenience functions for common AI queries
 */
export const AIQueries = {
  /**
   * Get all actionable units (can move or attack)
   */
  getActionableUnits: (state: GameState) => {
    return GameQueries.getMyUnits(state).filter(unit => 
      GameQueries.canUnitMove(state, unit) || GameQueries.canUnitAttack(state, unit)
    )
  },
  
  /**
   * Get the best attack target for a unit
   */
  getBestAttackTarget: (state: GameState, unit: Unit) => {
    if (!GameQueries.canUnitAttack(state, unit)) return undefined
    
    const enemiesInRange = GameQueries.getEnemiesInRange(state, unit)
    if (enemiesInRange.length === 0) return undefined
    
    // Prioritize by: 1) Can kill this turn, 2) Lowest HP, 3) Highest threat
    return enemiesInRange.sort((a, b) => {
      const canKillA = GameQueries.canKillTargetThisTurn(state, a)
      const canKillB = GameQueries.canKillTargetThisTurn(state, b)
      
      if (canKillA && !canKillB) return -1
      if (!canKillA && canKillB) return 1
      
      return a.hp - b.hp // Lower HP first
    })[0]
  },
  
  /**
   * Get the best move position for a unit
   */
  getBestMovePosition: (state: GameState, unit: Unit) => {
    if (!GameQueries.canUnitMove(state, unit)) return undefined
    
    const possibleMoves = GameQueries.getPossibleMoves(state, unit)
    if (possibleMoves.length === 0) return undefined
    
    // Find move with highest strategic value
    let bestMove = possibleMoves[0]
    let bestValue = GameQueries.getStrategicValue(state, bestMove)
    
    for (const move of possibleMoves) {
      const value = GameQueries.getStrategicValue(state, move)
      if (value > bestValue) {
        bestValue = value
        bestMove = move
      }
    }
    
    return bestMove
  },
  
  /**
   * Check if a unit should retreat (high threat, low HP)
   */
  shouldRetreat: (state: GameState, unit: Unit) => {
    const threatLevel = GameQueries.getThreatLevel(state, unit)
    const hpRatio = unit.hp / unit.maxHp
    
    // Retreat if high threat and low HP
    return threatLevel > 1.5 && hpRatio < 0.5
  },
  
  /**
   * Get the most valuable capture point to target
   */
  getMostValuableCapturePoint: (state: GameState, playerId: string) => {
    const valuablePoints = GameQueries.getValuableCapturePoints(state, playerId)
    if (valuablePoints.length === 0) return undefined
    
    // Find the one with highest strategic value
    let bestPoint = valuablePoints[0]
    let bestValue = GameQueries.getStrategicValue(state, bestPoint)
    
    for (const point of valuablePoints) {
      const value = GameQueries.getStrategicValue(state, point)
      if (value > bestValue) {
        bestValue = value
        bestPoint = point
      }
    }
    
    return bestPoint
  }
}

===== ./src/game/ai/ai.ts =====
import { type GameState, type Unit, type Coordinate, TileType, type Ability } from 'shared'
import { getUnitAbilities, canUseAbility, getValidTargets } from '../core/abilities'
import { GameQueries, type GameState as QueryGameState } from './gameStateQueries'
// import { type MainStoreState } from '../../stores/mainStore' // TODO: Remove when mainStore is implemented
import { calculatePossibleMoves, findNearestCoordinate } from '../core/movement'

interface AIActions {
  moveUnit: (unitId: string, to: Coordinate) => void
  attackTarget: (attackerId: string, targetId: string) => void
  captureCubicle: (unitId: string, coord: Coordinate) => void
  useAbility: (unitId: string, abilityId: string, target?: Unit | Coordinate) => void
  endTurn: () => void
}

interface AIAction {
  type: 'move' | 'attack' | 'ability' | 'capture'
  target?: Coordinate
  targetId?: string
  abilityId?: string
}

export class AIController {
  // private _difficulty: 'easy' | 'normal' | 'hard' // Currently unused
  
  constructor(_difficulty: 'easy' | 'normal' | 'hard' = 'normal') {
    // Difficulty setting currently unused
    void _difficulty; // Suppress unused parameter warning
  }

  // TODO: Implement when mainStore is available
  // takeTurnWithMainStore(mainStore: MainStoreState): void {
  //   // Implementation will be added when mainStore is implemented
  // }

  // TODO: Implement when mainStore is available
  // private executeDecisionWithMainStore(decision: AIAction, unit: Unit, mainStore: MainStoreState): void {
  //   // Implementation will be added when mainStore is implemented
  // }

  takeTurn(state: GameState, actions: AIActions, getState: () => GameState): void {
    const queryState: QueryGameState = {
      units: state.units,
      board: state.board,
      players: state.players,
      currentPlayerId: state.currentPlayerId,
      phase: state.phase,
      turnNumber: state.turnNumber
    }
    
    const myUnits = GameQueries.getMyUnits(queryState)
    console.log('AI takeTurn called with', myUnits.length, 'units')
    
    // Process each unit
    for (const unit of myUnits) {
      console.log('Processing AI unit:', unit.id, 'actions remaining:', unit.actionsRemaining)
      
      // Process this unit until it has no actions left
      let shouldContinue = true
      let iterationCount = 0
      const maxIterations = 5 // Safety limit to detect infinite loops
      
      while (shouldContinue) {
        iterationCount++
        
        if (iterationCount > maxIterations) {
          console.error('ðM-^_M-^Z¨ INFINITE LOOP DETECTED! Unit', unit.id, 'has been processed', iterationCount, 'times without consuming actions')
          console.error('This indicates a bug in the action execution or state update logic')
          shouldContinue = false
          break
        }
        // Get fresh state before making decision
        const freshState = getState()
        const queryState: QueryGameState = {
          units: freshState.units,
          board: freshState.board,
          players: freshState.players,
          currentPlayerId: freshState.currentPlayerId,
          phase: freshState.phase,
          turnNumber: freshState.turnNumber
        }
        
        const currentUnit = GameQueries.getUnitById(queryState, unit.id)
        
        if (!currentUnit || currentUnit.actionsRemaining <= 0) {
          console.log('Unit', unit.id, 'has no actions remaining or was destroyed, moving to next unit')
          break
        }
        
        const decision = this.makeDecisionWithQueries(currentUnit, queryState)
        console.log('AI decision for unit', currentUnit.id, ':', decision)
        
        if (!decision) {
          console.log('No decision found for unit', currentUnit.id)
          break
        }
        
        // Execute the decision through the action callbacks
        switch (decision.type) {
          case 'attack':
            console.log('Executing attack decision')
            actions.attackTarget(currentUnit.id, decision.targetId!)
            break
          case 'move':
            console.log('Executing move decision')
            actions.moveUnit(currentUnit.id, decision.target!)
            break
          case 'ability':
            console.log('Executing ability decision')
            actions.useAbility(currentUnit.id, decision.abilityId!, decision.target)
            break
          default:
            console.log('Unknown decision type:', decision.type)
            shouldContinue = false // Skip if no valid action
        }
        
        // After executing an action, check if we should continue
        // Get fresh state to see if actions were consumed
        const updatedState = getState()
        const updatedUnit = updatedState.units.find(u => u.id === unit.id)
        
        console.log('After action execution - Unit:', unit.id, 'Actions before:', currentUnit.actionsRemaining, 'Actions after:', updatedUnit?.actionsRemaining)
        
        if (!updatedUnit || updatedUnit.actionsRemaining <= 0) {
          console.log('Unit', unit.id, 'actions consumed, stopping processing')
          shouldContinue = false
        } else {
          console.log('Unit', unit.id, 'still has actions, continuing...')
        }
        
        // Small delay to allow state to update
        setTimeout(() => {}, 10)
      }
    }
    
    console.log('AI turn completed')
    // End the AI turn to return control to the player
    actions.endTurn()
  }

  private makeDecisionWithQueries(unit: Unit, queryState: QueryGameState): AIAction | null {
    console.log('Making decision for unit:', unit.id, 'type:', unit.type, 'actions:', unit.actionsRemaining)
    
    // 1. Check for ability opportunities first (highest priority)
    const abilityDecision = this.evaluateAbilities(unit, queryState)
    if (abilityDecision) {
      console.log('Ability decision:', abilityDecision)
      return abilityDecision
    }
    
    // 2. Check for attack opportunities (high priority)
    const enemiesInRange = GameQueries.getEnemiesInRange(queryState, unit)
    if (enemiesInRange.length > 0) {
      // Find the weakest enemy in range
      const weakestEnemy = enemiesInRange.reduce((weakest, enemy) => 
        enemy.hp < weakest.hp ? enemy : weakest
      )
      console.log('Attack decision: target', weakestEnemy.id, 'HP:', weakestEnemy.hp)
      return { type: 'attack', targetId: weakestEnemy.id }
    }
    
    // 3. Check for capture opportunities (medium priority)
    const capturableTiles = this.getCapturableTiles(unit, {
      id: 'ai-game-state',
      units: queryState.units,
      board: queryState.board,
      players: queryState.players,
      phase: queryState.phase,
      currentPlayerId: queryState.currentPlayerId,
      turnNumber: queryState.turnNumber
    })
    
    if (capturableTiles.length > 0) {
      // Find the closest capturable tile
      const nearestCapture = findNearestCoordinate(unit.position, capturableTiles)
      if (nearestCapture) {
        console.log('Capture decision: move to', nearestCapture)
        return { type: 'move', target: nearestCapture }
      }
    }
    
    // 4. Move towards nearest enemy (low priority)
    const nearestEnemy = GameQueries.findNearestEnemy(queryState, unit.position, unit.playerId)
    if (nearestEnemy) {
      const possibleMoves = GameQueries.getPossibleMoves(queryState, unit)
      if (possibleMoves.length > 0) {
        // Find the move that gets us closest to the enemy
        const bestMove = this.findBestMoveTowardsTarget(unit.position, nearestEnemy.position, possibleMoves)
        if (bestMove) {
          console.log('Enemy pursuit decision: move to', bestMove, 'towards', nearestEnemy.id)
          return { type: 'move', target: bestMove }
        }
      }
    }
    
    // 5. Move towards nearest objective (fallback)
    const nearestObjective = GameQueries.findNearestObjective(queryState, unit.position, unit.playerId)
    if (nearestObjective) {
      const possibleMoves = GameQueries.getPossibleMoves(queryState, unit)
      if (possibleMoves.length > 0) {
        const bestMove = this.findBestMoveTowardsTarget(unit.position, nearestObjective, possibleMoves)
        if (bestMove) {
          console.log('Objective decision: move to', bestMove, 'towards', nearestObjective)
          return { type: 'move', target: bestMove }
        }
      }
    }
    
    // 6. Random move if nothing else works (last resort)
    const possibleMoves = GameQueries.getPossibleMoves(queryState, unit)
    if (possibleMoves.length > 0) {
      const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)]
      console.log('Random move decision:', randomMove)
      return { type: 'move', target: randomMove }
    }
    
    console.log('No decision found for unit', unit.id)
    return null
  }

  private evaluateAbilities(unit: Unit, queryState: QueryGameState): AIAction | null {
    const abilities = getUnitAbilities(unit)
    
    for (const ability of abilities) {
      if (!canUseAbility(unit, ability.id)) continue
      
      const validTargets = getValidTargets(unit, ability, queryState.board, queryState.units)
      if (validTargets.length === 0) continue
      
      // Score this ability based on its potential impact
      const score = this.scoreAbility(unit, ability, validTargets, queryState)
      if (score > 0.7) { // Threshold for using ability
        const bestTarget = validTargets[0] // For now, just use first target
        return { type: 'ability', abilityId: ability.id, target: bestTarget as Coordinate }
      }
    }
    
    return null
  }

  private scoreAbility(unit: Unit, ability: Ability, targets: (Unit | Coordinate)[], _queryState: QueryGameState): number {
    void _queryState; // Suppress unused parameter warning
    let score = 0

    // Base score for different ability types
    switch (ability.id) {
      case 'pink_slip': {
        // High value for execution abilities
        const target = targets[0] as Unit
        if (target && 'hp' in target && target.hp <= 2) {
          score += 0.9
        }
        break
      }
      case 'fetch_coffee': {
        // Good for supporting allies
        if (targets[0] && 'playerId' in targets[0] && targets[0].playerId === unit.playerId) {
          score += 0.8
        }
        break
      }
      case 'overtime': {
        // Good when actions are needed
        if (unit.actionsRemaining <= 1) {
          score += 0.7
        }
        break
      }
      case 'file_it': {
        // Good for debuffing enemies
        if (targets[0] && 'playerId' in targets[0] && targets[0].playerId !== unit.playerId) {
          score += 0.6
        }
        break
      }
      case 'harass': {
        // Good for preventing captures
        if (targets[0] && 'playerId' in targets[0] && targets[0].playerId !== unit.playerId) {
          score += 0.7
        }
        break
      }
      default:
        score += 0.3
    }

    // Bonus for targeting low HP enemies
    if (targets[0] && 'hp' in targets[0] && targets[0].hp <= 3) {
      score += 0.5
    }

    // Bonus for targeting high-value units (HR Managers, Executives)
    if (targets[0] && 'type' in targets[0]) {
      if (targets[0].type === 'hr_manager' || targets[0].type === 'executive') {
        score += 0.4
      }
    }

    return score
  }


  private getCapturableTiles(unit: Unit, state: GameState): Coordinate[] {
    // AI now moves TO cubicles instead of capturing from adjacent positions
    // The actual capture happens at turn end when the unit is on the tile
    const possibleMoves = calculatePossibleMoves(unit, { board: state.board, units: state.units })
    
    const capturable = possibleMoves.filter(coord => {
      const tile = state.board[coord.y]?.[coord.x]
      console.log('Checking moveable tile at', coord, 'type:', tile?.type, 'owner:', tile?.owner, 'unit player:', unit.playerId)
      
      // Check if it's a cubicle and not owned by this unit's player
      return tile?.type === TileType.CUBICLE && tile.owner !== unit.playerId
    })
    
    console.log('Capturable tiles found (AI will move to):', capturable)
    return capturable
  }




  private findBestMoveTowardsTarget(_currentPosition: Coordinate, targetPosition: Coordinate, possibleMoves: Coordinate[]): Coordinate | null {
    if (possibleMoves.length === 0) return null
    
    // Find the move that gets us closest to the target
    let bestMove = possibleMoves[0]
    let bestDistance = this.getDistance(bestMove, targetPosition)
    
    for (const move of possibleMoves) {
      const distance = this.getDistance(move, targetPosition)
      if (distance < bestDistance) {
        bestDistance = distance
        bestMove = move
      }
    }
    
    return bestMove
  }

  private getDistance(pos1: Coordinate, pos2: Coordinate): number {
    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y)
  }
}



===== ./src/game/ai/ai.test.ts =====
// TODO: Re-enable AI tests when mainStore is implemented
/*
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { AIController } from './ai'
import { createMockUnit, createMockGameState } from '../test/helpers'
import { GamePhase } from 'shared'

// Mock the main store
const mockMainStore = {
  getGameState: vi.fn(),
  moveUnit: vi.fn(),
  attackTarget: vi.fn(),
  attackUnit: vi.fn(), // Add missing method
  useAbility: vi.fn(),
  captureCubicle: vi.fn(),
  endTurn: vi.fn()
}

describe('AI Controller', () => {
  let aiController: AIController

  beforeEach(() => {
    aiController = new AIController('normal')
    vi.clearAllMocks()
  })

  describe('AI Initialization', () => {
    it('should create AI controller with normal difficulty', () => {
      expect(aiController).toBeDefined()
      // expect(aiController.takeTurnWithMainStore).toBeDefined() // TODO: Re-enable when mainStore is implemented
    })

    it('should create AI controller with easy difficulty', () => {
      const easyAI = new AIController('easy')
      expect(easyAI).toBeDefined()
    })

    it('should create AI controller with hard difficulty', () => {
      const hardAI = new AIController('hard')
      expect(hardAI).toBeDefined()
    })
  })

  describe('AI Turn Execution', () => {
    it('should be able to take a turn with main store', () => {
      const gameState = createMockGameState({
        units: [
          createMockUnit({ id: 'ai-unit', playerId: 'player2', actionsRemaining: 1 }),
          createMockUnit({ id: 'player-unit', playerId: 'player1', actionsRemaining: 1 })
        ],
        currentPlayerId: 'player2',
        phase: GamePhase.PLAYING
      })

      mockMainStore.getGameState.mockReturnValue(gameState)

      // The AI should be able to take a turn without throwing errors
      expect(() => {
        aiController.takeTurnWithMainStore(mockMainStore as any)
      }).not.toThrow()
    })

    it('should handle empty unit list gracefully', () => {
      const gameState = createMockGameState({
        units: [],
        currentPlayerId: 'player2',
        phase: GamePhase.PLAYING
      })

      mockMainStore.getGameState.mockReturnValue(gameState)

      expect(() => {
        aiController.takeTurnWithMainStore(mockMainStore as any)
      }).not.toThrow()
    })

    it('should handle units with no actions remaining', () => {
      const gameState = createMockGameState({
        units: [
          createMockUnit({ 
            id: 'ai-unit', 
        playerId: 'player2',
            actionsRemaining: 0,
            hasMoved: true,
            hasAttacked: true
          })
        ],
        currentPlayerId: 'player2',
        phase: GamePhase.PLAYING
      })

      mockMainStore.getGameState.mockReturnValue(gameState)

      expect(() => {
        aiController.takeTurnWithMainStore(mockMainStore as any)
      }).not.toThrow()
    })
  })

  describe('AI Decision Making', () => {
    it('should process units until they have no actions remaining', () => {
      const gameState = createMockGameState({
        units: [
          createMockUnit({ 
            id: 'ai-unit', 
            playerId: 'player2', 
            actionsRemaining: 2,
            hasMoved: false,
            hasAttacked: false
          })
        ],
        currentPlayerId: 'player2',
        phase: GamePhase.PLAYING
      })

      mockMainStore.getGameState.mockReturnValue(gameState)

      aiController.takeTurnWithMainStore(mockMainStore as any)

      // The AI should have called getGameState multiple times to get fresh state
      expect(mockMainStore.getGameState).toHaveBeenCalled()
    })

    it('should not get stuck in infinite loops', () => {
      const gameState = createMockGameState({
        units: [
          createMockUnit({ 
            id: 'ai-unit', 
            playerId: 'player2', 
            actionsRemaining: 1,
            hasMoved: false,
            hasAttacked: false
          })
        ],
        currentPlayerId: 'player2',
        phase: GamePhase.PLAYING
      })

      mockMainStore.getGameState.mockReturnValue(gameState)

      // Mock the store methods to not actually consume actions (simulating a bug)
      mockMainStore.moveUnit.mockImplementation(() => {
        // Don't actually move the unit
      })
      mockMainStore.attackTarget.mockImplementation(() => {
        // Don't actually attack
      })

      expect(() => {
        aiController.takeTurnWithMainStore(mockMainStore as any)
      }).not.toThrow()

      // The AI should have a safety limit and not call getGameState excessively
      expect(mockMainStore.getGameState).toHaveBeenCalledTimes(expect.any(Number))
      expect(mockMainStore.getGameState).toHaveBeenCalledTimes(expect.any(Number))
    })
  })

  describe('AI Integration', () => {
    it('should work with the main store interface', () => {
      const gameState = createMockGameState({
        units: [
          createMockUnit({ id: 'ai-unit', playerId: 'player2', actionsRemaining: 1 })
        ],
        currentPlayerId: 'player2',
        phase: GamePhase.PLAYING
      })

      mockMainStore.getGameState.mockReturnValue(gameState)

      // The AI should be able to call all the main store methods
      expect(() => {
        aiController.takeTurnWithMainStore(mockMainStore as any)
      }).not.toThrow()

      // Verify that the AI can access the required store methods
      expect(mockMainStore.getGameState).toBeDefined()
      expect(mockMainStore.moveUnit).toBeDefined()
      expect(mockMainStore.attackTarget).toBeDefined()
      expect(mockMainStore.useAbility).toBeDefined()
      expect(mockMainStore.captureCubicle).toBeDefined()
      expect(mockMainStore.endTurn).toBeDefined()
    })
  })

  describe('AI Attack Behavior', () => {
    it('should attack the weakest enemy when in range', () => {
      const gameState = createMockGameState({
        units: [
          createMockUnit({ 
            id: 'ai-unit', 
            playerId: 'player2', 
            actionsRemaining: 1,
            position: { x: 0, y: 0 },
            attackRange: 2
          }),
          createMockUnit({ 
            id: 'enemy-weak', 
            playerId: 'player1', 
            position: { x: 1, y: 0 },
            hp: 5,
            maxHp: 10
          }),
          createMockUnit({ 
            id: 'enemy-strong', 
            playerId: 'player1', 
            position: { x: 0, y: 1 },
            hp: 8,
            maxHp: 10
          })
        ],
        currentPlayerId: 'player2',
        phase: GamePhase.PLAYING
      })

      mockMainStore.getGameState.mockReturnValue(gameState)
      mockMainStore.attackUnit.mockImplementation(() => {})

      aiController.takeTurnWithMainStore(mockMainStore as any)

      // Should have called attackUnit with the weakest enemy
      expect(mockMainStore.attackUnit).toHaveBeenCalledWith('ai-unit', 'enemy-weak')
    })

    it('should not attack when no enemies are in range', () => {
      const gameState = createMockGameState({
        units: [
          createMockUnit({ 
            id: 'ai-unit', 
            playerId: 'player2', 
            actionsRemaining: 1,
            position: { x: 0, y: 0 },
            attackRange: 1
          }),
          createMockUnit({ 
            id: 'enemy-far', 
            playerId: 'player1', 
            position: { x: 5, y: 5 } // Out of range
          })
        ],
        currentPlayerId: 'player2',
        phase: GamePhase.PLAYING
      })

      mockMainStore.getGameState.mockReturnValue(gameState)
      mockMainStore.attackUnit.mockImplementation(() => {})

      aiController.takeTurnWithMainStore(mockMainStore as any)

      // Should not have called attackUnit
      expect(mockMainStore.attackUnit).not.toHaveBeenCalled()
    })

    it('should prioritize attacking over moving when enemies are in range', () => {
      const gameState = createMockGameState({
        units: [
          createMockUnit({ 
            id: 'ai-unit', 
            playerId: 'player2', 
            actionsRemaining: 1,
            position: { x: 0, y: 0 },
            attackRange: 2
          }),
          createMockUnit({ 
            id: 'enemy-in-range', 
            playerId: 'player1', 
        position: { x: 1, y: 0 }
      })
        ],
        currentPlayerId: 'player2',
        phase: GamePhase.PLAYING
      })

      mockMainStore.getGameState.mockReturnValue(gameState)
      mockMainStore.attackUnit.mockImplementation(() => {})
      mockMainStore.moveUnit.mockImplementation(() => {})

      aiController.takeTurnWithMainStore(mockMainStore as any)

      // Should attack, not move
      expect(mockMainStore.attackUnit).toHaveBeenCalled()
      expect(mockMainStore.moveUnit).not.toHaveBeenCalled()
    })
  })

  describe('Edge Cases', () => {
    it('should handle units with no actions remaining', () => {
      const gameState = createMockGameState({
        units: [
          createMockUnit({ 
            id: 'ai-unit', 
            playerId: 'player2', 
            actionsRemaining: 0,
            hasMoved: true,
            hasAttacked: true
          })
        ],
        currentPlayerId: 'player2',
        phase: GamePhase.PLAYING
      })

      mockMainStore.getGameState.mockReturnValue(gameState)

      expect(() => {
        aiController.takeTurnWithMainStore(mockMainStore as any)
      }).not.toThrow()
    })

    it('should handle game state with no AI units', () => {
      const gameState = createMockGameState({
        units: [
          createMockUnit({ id: 'player-unit', playerId: 'player1', actionsRemaining: 1 })
        ],
        currentPlayerId: 'player2',
        phase: GamePhase.PLAYING
      })

      mockMainStore.getGameState.mockReturnValue(gameState)

      expect(() => {
        aiController.takeTurnWithMainStore(mockMainStore as any)
      }).not.toThrow()
    })

    it('should handle different game phases', () => {
      const gameState = createMockGameState({
        units: [
          createMockUnit({ id: 'ai-unit', playerId: 'player2', actionsRemaining: 1 })
        ],
        currentPlayerId: 'player2',
        phase: GamePhase.DRAFT
      })

      mockMainStore.getGameState.mockReturnValue(gameState)

      expect(() => {
        aiController.takeTurnWithMainStore(mockMainStore as any)
      }).not.toThrow()
    })

    it('should not throw ReferenceError for undefined queryState variable', () => {
      // This test specifically addresses the bug where queryState was undefined
      // in the makeDecisionWithQueries function
      const gameState = createMockGameState({
        units: [
          createMockUnit({ 
            id: 'ai-unit', 
            playerId: 'player2', 
            actionsRemaining: 1,
            position: { x: 0, y: 0 },
            moveRange: 2
          })
        ],
        currentPlayerId: 'player2',
        phase: GamePhase.PLAYING
      })

      mockMainStore.getGameState.mockReturnValue(gameState)

      // This should not throw a ReferenceError about queryState being undefined
      expect(() => {
        aiController.takeTurnWithMainStore(mockMainStore as any)
      }).not.toThrow()
    })
  })
})
*/
===== ./src/game/visuals/UnitManager.ts =====
import Phaser from 'phaser'
import { type Unit } from 'shared'
import { useUnitStore } from '../../stores/unitStore'

// Visual configuration for units
const UNIT_VISUAL_CONFIG = {
  COLORS: {
    PLAYER1: 0xf59e0b,       // Amber-500 (Corporate gold)
    PLAYER2: 0x57534e,       // Stone-600 (Corporate gray)
    HP_BAR_BG: 0x000000,     // Black (kept for contrast)
    HP_BAR_FILL: 0x16a34a,   // Green-600 (kept for healing)
    SELECTION_BORDER: 0xf59e0b, // Amber-500 (Corporate gold)
    HOVER_BORDER: 0x78716c,  // Stone-500 (Corporate gray)
  },
  UNIT: {
    CIRCLE_RADIUS: 20,
    FONT_SIZE: '14px',
    HP_BAR_WIDTH: 40,
    HP_BAR_HEIGHT: 6,
    HP_BAR_OFFSET_Y: -28,
    SELECTION_BORDER_WIDTH: 3,
    HOVER_BORDER_WIDTH: 2,
    HOVER_ALPHA: 0.9,
  },
  ANIMATION: {
    MOVEMENT_DURATION: 250,
    CLICK_SCALE_DURATION: 100,
    CLICK_SCALE_FACTOR: 0.9,
  }
}

export class UnitManager {
  private scene: Phaser.Scene
  private unitSprites: Map<string, Phaser.GameObjects.Container> = new Map()
  private tileSizePx: number
  private tileToWorld: (tx: number, ty: number) => { x: number, y: number }
  // private worldToTile: (px: number, py: number) => { x: number, y: number } // Not used in UnitManager

  constructor(scene: Phaser.Scene, tileSizePx: number, tileToWorld: (tx: number, ty: number) => { x: number, y: number }) {
    this.scene = scene
    this.tileSizePx = tileSizePx
    this.tileToWorld = tileToWorld
  }

  updateTileSize(newTileSize: number) {
    this.tileSizePx = newTileSize
    this.updateUnitSprites()
  }

  drawUnits(units: Unit[]) {
    try {
      // Remove containers that no longer exist
      this.unitSprites.forEach((container, id) => {
        if (!units.find((u) => u.id === id)) {
          container.destroy()
          this.unitSprites.delete(id)
        }
      })

      for (const unit of units) {
        const { x: wx, y: wy } = this.tileToWorld(unit.position.x, unit.position.y)
        const targetX = wx + this.tileSizePx / 2
        const targetY = wy + this.tileSizePx / 2
        const existing = this.unitSprites.get(unit.id)
        
        if (existing) {
          this.updateExistingUnit(existing, unit, targetX, targetY)
          continue
        }

        this.createNewUnit(unit, targetX, targetY)
      }
    } catch (error) {
      console.error('Error drawing units:', error)
    }
  }

  private updateExistingUnit(container: Phaser.GameObjects.Container, unit: Unit, targetX: number, targetY: number) {
    // Animate movement
    this.scene.tweens.add({ 
      targets: container, 
      x: targetX, 
      y: targetY, 
      duration: UNIT_VISUAL_CONFIG.ANIMATION.MOVEMENT_DURATION, 
      ease: 'Power2' 
    })
    
    // Update HP bar width
    const hpFill = container.getByName('hpFill') as Phaser.GameObjects.Rectangle
    if (hpFill) {
      hpFill.width = UNIT_VISUAL_CONFIG.UNIT.HP_BAR_WIDTH * (unit.hp / unit.maxHp)
    }
    
    // Update transparency for "done" state
    const circle = container.getByName('circle') as Phaser.GameObjects.Graphics
    const label = container.getByName('label') as Phaser.GameObjects.Text
    const hpBg = container.getByName('hpBg') as Phaser.GameObjects.Rectangle
    const directionIndicator = container.getByName('directionIndicator') as Phaser.GameObjects.Triangle
    
    const alpha = unit.actionsRemaining === 0 ? 0.5 : 1.0
    if (circle) circle.setAlpha(alpha)
    if (label) label.setAlpha(alpha)
    if (hpBg) hpBg.setAlpha(alpha)
    if (hpFill) hpFill.setAlpha(alpha)
    if (directionIndicator) {
      directionIndicator.setAlpha(alpha)
      this.updateDirectionIndicator(directionIndicator, unit.direction)
    }
  }

  private createNewUnit(unit: Unit, targetX: number, targetY: number) {
    const container = this.scene.add.container(targetX, targetY).setDepth(50)
    const circleColor = unit.playerId === 'player1' ? UNIT_VISUAL_CONFIG.COLORS.PLAYER1 : UNIT_VISUAL_CONFIG.COLORS.PLAYER2
    
    // Create circle using add.circle() like the original code
    const circle = this.scene.add.circle(0, 0, UNIT_VISUAL_CONFIG.UNIT.CIRCLE_RADIUS, circleColor).setName('circle')
    
    const label = this.scene.add.text(0, 0, unit.type.charAt(0).toUpperCase(), { 
      color: '#fff', 
      fontSize: UNIT_VISUAL_CONFIG.UNIT.FONT_SIZE 
    }).setName('label')
    label.setOrigin(0.5)
    
    const hpBg = this.scene.add.rectangle(0, UNIT_VISUAL_CONFIG.UNIT.HP_BAR_OFFSET_Y, UNIT_VISUAL_CONFIG.UNIT.HP_BAR_WIDTH, UNIT_VISUAL_CONFIG.UNIT.HP_BAR_HEIGHT, UNIT_VISUAL_CONFIG.COLORS.HP_BAR_BG).setOrigin(0.5).setName('hpBg')
    const hpFill = this.scene.add.rectangle(-20, UNIT_VISUAL_CONFIG.UNIT.HP_BAR_OFFSET_Y, UNIT_VISUAL_CONFIG.UNIT.HP_BAR_WIDTH * (unit.hp / unit.maxHp), UNIT_VISUAL_CONFIG.UNIT.HP_BAR_HEIGHT, UNIT_VISUAL_CONFIG.COLORS.HP_BAR_FILL)
      .setOrigin(0, 0.5)
      .setName('hpFill')
    
    // Add direction indicator (small triangle)
    const directionIndicator = this.scene.add.triangle(0, 0, 0, -15, -8, 8, 8, 8, 0xffffff).setName('directionIndicator')
    this.updateDirectionIndicator(directionIndicator, unit.direction)
    
    // Set transparency for units with no actions remaining (visual "done" state)
    if (unit.actionsRemaining === 0) {
      circle.setAlpha(0.5)
      label.setAlpha(0.5)
      hpBg.setAlpha(0.5)
      hpFill.setAlpha(0.5)
    } else {
      circle.setAlpha(1.0)
      label.setAlpha(1.0)
      hpBg.setAlpha(1.0)
      hpFill.setAlpha(1.0)
    }
    
    container.add([circle, label, hpBg, hpFill, directionIndicator])
    
    // Make the container interactive with proper hit area
    container.setSize(this.tileSizePx, this.tileSizePx)
    container.setData('unitId', unit.id)
    
    // Enhanced interactivity for Safari compatibility
    container.setInteractive(new Phaser.Geom.Rectangle(-this.tileSizePx/2, -this.tileSizePx/2, this.tileSizePx, this.tileSizePx), Phaser.Geom.Rectangle.Contains)
    
    // Add multiple event listeners for better compatibility
    /* NOTE: This is commented out because it is handled in GameScene
    container.on('pointerdown', () => {
      // --- START OF CRITICAL FIX ---
      const uiState = useUIStore.getState()
      if (uiState.actionMode !== 'none') {
        // If we're already in an action mode (move, attack, ability),
        // let the GameScene's master handleClick handle it. Do nothing here.
        console.log('UnitManager: Click ignored, action mode is active.')
        return
      }
      // --- END OF CRITICAL FIX ---

      console.log('Unit clicked:', unit.id)
      const u = useUnitStore.getState().units.find((uu) => uu.id === unit.id)
      if (u) {
        useGameStore.getState().selectUnit(u)
      }

      // Add click feedback
      circle.setScale(UNIT_VISUAL_CONFIG.ANIMATION.CLICK_SCALE_FACTOR)
      this.scene.time.delayedCall(UNIT_VISUAL_CONFIG.ANIMATION.CLICK_SCALE_DURATION, () => {
        circle.setScale(1)
      })
    })
    */
    
    // Add visual feedback for interactivity
    container.on('pointerover', () => {
      circle.setStrokeStyle(UNIT_VISUAL_CONFIG.UNIT.HOVER_BORDER_WIDTH, UNIT_VISUAL_CONFIG.COLORS.HOVER_BORDER, UNIT_VISUAL_CONFIG.UNIT.HOVER_ALPHA)
      circle.setAlpha(0.9)
    })
    
    container.on('pointerout', () => {
      circle.setStrokeStyle(0)
      circle.setAlpha(1)
    })
    
    this.unitSprites.set(unit.id, container)
  }

  private updateUnitSprites(): void {
    // Update all unit sprites with new tile size
    this.unitSprites.forEach((container, unitId) => {
      const unit = useUnitStore.getState().units.find((u) => u.id === unitId);
      if (unit) {
        // Update container size
        container.setSize(this.tileSizePx, this.tileSizePx);
        
        // Update interactive area
        container.setInteractive(new Phaser.Geom.Rectangle(
          -this.tileSizePx/2, 
          -this.tileSizePx/2, 
          this.tileSizePx, 
          this.tileSizePx
        ), Phaser.Geom.Rectangle.Contains);
        
        // Update position
        const { x: wx, y: wy } = this.tileToWorld(unit.position.x, unit.position.y);
        container.setPosition(wx + this.tileSizePx / 2, wy + this.tileSizePx / 2);
        
        // Update unit circle radius proportionally
        const unitCircle = container.getByName('circle') as Phaser.GameObjects.Arc; // Circle object from add.circle()
        if (unitCircle && unitCircle.setRadius) {
          const newRadius = Math.max(12, this.tileSizePx * 0.4); // Proportional radius with minimum
          unitCircle.setRadius(newRadius);
        } else {
          console.warn(`UnitManager: unitCircle not found or invalid for unit ${unitId}`);
        }
        
        // Update HP bar positioning
        const hpBar = container.getByName('hpBg') as Phaser.GameObjects.Rectangle;
        if (hpBar) {
          const hpBarWidth = Math.max(30, this.tileSizePx * 0.8);
          const hpBarHeight = Math.max(4, this.tileSizePx * 0.1);
          const hpBarOffsetY = -this.tileSizePx / 2 - 8;
          
          // HP bar will be redrawn when needed, just update positioning
          container.setData('hpBarConfig', { width: hpBarWidth, height: hpBarHeight, offsetY: hpBarOffsetY });
        }
      }
    });
  }

  getUnitSprites(): Map<string, Phaser.GameObjects.Container> {
    return this.unitSprites
  }

  private updateDirectionIndicator(indicator: Phaser.GameObjects.Triangle, direction: 'up' | 'down' | 'left' | 'right') {
    switch (direction) {
      case 'up':
        indicator.setRotation(Math.PI) // 180 degrees
        break
      case 'down':
        indicator.setRotation(0)
        break
      case 'left':
        indicator.setRotation(Math.PI / 2) // 90 degrees
        break
      case 'right':
        indicator.setRotation(-Math.PI / 2) // -90 degrees
        break
    }
  }

  destroy() {
    this.unitSprites.forEach(container => {
      if (container && container.destroy) {
        container.destroy()
      }
    })
    this.unitSprites.clear()
  }
}

===== ./src/game/visuals/HighlightManager.ts =====
import Phaser from 'phaser'
import { type Unit, type Coordinate, AbilityTargetingType, type Ability, type AttackPattern } from 'shared'
import { useGameStore } from '../../stores/gameStore'
import { useUIStore } from '../../stores/uiStore'
import { useUnitStore } from '../../stores/unitStore'
import { useBoardStore } from '../../stores/boardStore'
import { getAbilityById, getValidTargets } from '../core/abilities'
import { getTilesInCone } from '../core/targeting'
import { dataManager } from '../data/DataManager'

// Visual configuration for highlights
const HIGHLIGHT_CONFIG = {
  COLORS: {
    MOVEMENT: 0x3b82f6,      // Blue for movement
    ATTACK: 0xef4444,        // Red for attack
    ATTACK_RANGE: 0xdc2626,  // Darker red for attack range
    ABILITY: 0x9333ea,       // Purple for abilities
    ABILITY_AOE: 0xec4899,   // Pink for AOE abilities
    TARGET_ENEMY: 0xef4444,  // Red for enemy targets
    TARGET_ALLY: 0x16a34a,   // Green for ally targets
    CAPTURE: 0x06b6d4,       // Cyan for capture
    INVALID: 0x6b7280,       // Gray for invalid targets
  },
  HIGHLIGHT: {
    MOVEMENT_ALPHA: 0.4,
    ATTACK_ALPHA: 0.4,
    ATTACK_RANGE_ALPHA: 0.4,
    ABILITY_ALPHA: 0.4,
    AOE_ALPHA: 0.4,
    BORDER_WIDTH: 2,
    TILE_BORDER_ALPHA: 0.5,
  }
}

export class HighlightManager {
  private scene: Phaser.Scene
  private highlightGraphics!: Phaser.GameObjects.Graphics
  private abilityTargetGraphics!: Phaser.GameObjects.Graphics
  private tileSizePx: number
  private tileToWorld: (tx: number, ty: number) => { x: number, y: number }
  private worldToTile: (px: number, py: number) => { x: number, y: number }
  private validTargets: (Unit | Coordinate)[] = []
  private targetingMode: boolean = false

  constructor(scene: Phaser.Scene, tileSizePx: number, tileToWorld: (tx: number, ty: number) => { x: number, y: number }, worldToTile: (px: number, py: number) => { x: number, y: number }) {
    this.scene = scene
    this.tileSizePx = tileSizePx
    this.tileToWorld = tileToWorld
    this.worldToTile = worldToTile
    
    // Initialize graphics
    this.highlightGraphics = this.scene.add.graphics()
    this.abilityTargetGraphics = this.scene.add.graphics()
    
    // Ensure ability graphics are drawn on top
    this.abilityTargetGraphics.setDepth(100)
    this.highlightGraphics.setDepth(10)
  }

  updateTileSize(newTileSize: number) {
    this.tileSizePx = newTileSize
    this.clearAll()
  }

  updateHighlights(highlighted: Map<string, string>, selectedUnit?: Unit) {
    try {
      if (!this.highlightGraphics) {
        console.warn('highlightGraphics not initialized, skipping highlight update')
        return
      }
      
      // ALWAYS clear first
      this.highlightGraphics.clear()

      highlighted.forEach((type, coordKey) => {
        const [x, y] = coordKey.split(',').map(Number)
        const { x: px, y: py } = this.tileToWorld(x, y)
        this.drawHighlight(px, py, this.tileSizePx, type)
      })

      // Always draw selected unit highlight last
      if (selectedUnit) {
        const { x: px, y: py } = this.tileToWorld(selectedUnit.position.x, selectedUnit.position.y)
        this.highlightGraphics.lineStyle(3, 0xfbbf24, 1) // Gold selection
        this.highlightGraphics.strokeRect(px - 1, py - 1, this.tileSizePx, this.tileSizePx)
      }
    } catch (error) {
      console.error('Error updating highlights:', error)
    }
  }

  private drawHighlight(x: number, y: number, tileSize: number, type: string) {
    try {
      if (!this.highlightGraphics) {
        console.warn('highlightGraphics not initialized, skipping highlight draw')
        return
      }
      
      let color = 0x16a34a // Default green
      let alpha = 0.3
      
      switch (type) {
        case 'movement':
          color = HIGHLIGHT_CONFIG.COLORS.MOVEMENT
          alpha = HIGHLIGHT_CONFIG.HIGHLIGHT.MOVEMENT_ALPHA
          break
        case 'attack':
          color = HIGHLIGHT_CONFIG.COLORS.ATTACK
          alpha = HIGHLIGHT_CONFIG.HIGHLIGHT.ATTACK_ALPHA
          break
        case 'ability':
          color = HIGHLIGHT_CONFIG.COLORS.ABILITY
          alpha = HIGHLIGHT_CONFIG.HIGHLIGHT.ABILITY_ALPHA
          break
        case 'attack_range':
          color = HIGHLIGHT_CONFIG.COLORS.ATTACK_RANGE
          alpha = HIGHLIGHT_CONFIG.HIGHLIGHT.ATTACK_RANGE_ALPHA
          break
        case 'ability_aoe':
          color = HIGHLIGHT_CONFIG.COLORS.ABILITY_AOE
          alpha = HIGHLIGHT_CONFIG.HIGHLIGHT.AOE_ALPHA
          break
        case 'target_enemy':
          color = HIGHLIGHT_CONFIG.COLORS.TARGET_ENEMY
          alpha = 0.6
          break
        case 'target_ally':
          color = HIGHLIGHT_CONFIG.COLORS.TARGET_ALLY
          alpha = 0.6
          break
        case 'capture':
          color = HIGHLIGHT_CONFIG.COLORS.CAPTURE
          alpha = 0.4
          break
        case 'invalid':
          color = HIGHLIGHT_CONFIG.COLORS.INVALID
          alpha = 0.5
          break
        case 'range':
          color = 0x60a5fa // Light blue for range area
          alpha = 0.2
          break
        case 'target':
          color = 0xef4444 // Red for valid targets
          alpha = 0.6
          break
        default:
          color = 0x16a34a // Default green
          alpha = 0.3
      }
      
      // Fill the tile
      this.highlightGraphics.fillStyle(color, alpha)
      this.highlightGraphics.fillRect(x, y, tileSize, tileSize)
      
      // Add border for clarity
      this.highlightGraphics.lineStyle(2, color, alpha + 0.3)
      this.highlightGraphics.strokeRect(x, y, tileSize, tileSize)
    } catch (error) {
      console.error('Error drawing highlight:', error)
    }
  }

  updateAbilityTargeting(selectedUnit?: Unit, selectedAbility?: string) {
    console.log('updateAbilityTargeting called with:', { 
      selectedUnit: selectedUnit?.id, 
      selectedAbility,
      hasGraphics: !!this.abilityTargetGraphics 
    })
    
    this.abilityTargetGraphics.clear()
    
    if (!selectedUnit || !selectedAbility) {
      console.log('No unit or ability selected, clearing targeting')
      this.targetingMode = false
      this.validTargets = []
      return
    }

    const ability = getAbilityById(selectedAbility, selectedUnit)
    if (!ability) {
      console.log('Ability not found:', selectedAbility)
      return
    }

    console.log('Found ability:', ability.name, 'with range:', ability.range)

    const unitState = useUnitStore.getState()
    const boardState = useBoardStore.getState()
    this.validTargets = getValidTargets(selectedUnit, ability, boardState.board, unitState.units)
    this.targetingMode = true
    
    console.log('Valid targets found:', this.validTargets.length)

    // Show range highlight first
    this.showAbilityRange(selectedUnit, ability)
    
    // Show attack pattern if available
    this.showAttackPattern(selectedUnit, ability)
    
    // Handle different targeting types
    switch (ability.targetingType) {
      case AbilityTargetingType.AOE_CONE:
        this.showConePreview(selectedUnit, ability)
        break
      case AbilityTargetingType.AOE_CIRCLE:
        this.showCirclePreview(selectedUnit, ability)
        break
      case AbilityTargetingType.SINGLE_TARGET:
      default:
        this.showStandardTargeting()
        break
    }
  }

  private showAbilityRange(caster: Unit, ability: Ability) {
    console.log('showAbilityRange called for:', ability.name, 'with range:', ability.range)
    console.log('Caster position:', caster.position)
    
    // Validate graphics context
    if (!this.abilityTargetGraphics) {
      console.error('abilityTargetGraphics not initialized!')
      return
    }
    
    console.log('Tile size:', this.tileSizePx, 'Board offset: (0,0) - Tiled map')
    
    // Determine if this is a positive or negative ability based on target type
    const isNegativeAbility = ability.targetType === 'enemy'
    
    console.log('Ability type:', { isPositiveAbility: false, isNegativeAbility, targetType: ability.targetType })
    
    // Use appropriate colors for range highlighting
    let rangeColor: number
    let rangeAlpha: number
    
    if (isNegativeAbility) {
      // Reddish for negative abilities (harmful to enemies)
      rangeColor = HIGHLIGHT_CONFIG.COLORS.ATTACK_RANGE
      rangeAlpha = 0.25 // Good visibility without being too opaque
      console.log('Using negative ability colors:', { rangeColor: rangeColor.toString(16), rangeAlpha })
    } else {
      // Greenish for positive abilities (helpful to allies)
      rangeColor = 0x16a34a // Green
      rangeAlpha = 0.25 // Good visibility without being too opaque
      console.log('Using positive ability colors:', { rangeColor: rangeColor.toString(16), rangeAlpha })
    }
    
    // Draw range highlight for all tiles within range
    const range = ability.range || 1
    let tilesHighlighted = 0
    
    console.log('Drawing range highlights for range:', range)
    
    for (let dx = -range; dx <= range; dx++) {
      for (let dy = -range; dy <= range; dy++) {
        // Check if this tile is within the actual range (Manhattan distance)
        if (Math.abs(dx) + Math.abs(dy) <= range) {
          const targetX = caster.position.x + dx
          const targetY = caster.position.y + dy
          
          // Check if this position is on the board
          const boardState = useBoardStore.getState()
          if (targetX >= 0 && targetX < boardState.board[0].length && 
              targetY >= 0 && targetY < boardState.board.length) {
            
            const { x: px, y: py } = this.tileToWorld(targetX, targetY)
            
            console.log(`Highlighting tile at (${targetX}, ${targetY}) -> screen (${px}, ${py})`)
            
            // Draw range highlight
            this.abilityTargetGraphics.fillStyle(rangeColor, rangeAlpha)
            this.abilityTargetGraphics.fillRect(px, py, this.tileSizePx, this.tileSizePx)
            
            // Add subtle border
            this.abilityTargetGraphics.lineStyle(1, rangeColor, rangeAlpha + 0.2)
            this.abilityTargetGraphics.strokeRect(px, py, this.tileSizePx, this.tileSizePx)
            
            tilesHighlighted++
          }
        }
      }
    }
    
    console.log(`Range highlighting complete. Tiles highlighted: ${tilesHighlighted}`)
  }

  private showStandardTargeting() {
    // Highlight valid targets with standard targeting
    const selectedUnit = useUnitStore.getState().selectedUnit
    this.validTargets.forEach(target => {
      if ('x' in target) {
        // Target is a coordinate
        const { x: px, y: py } = this.tileToWorld(target.x, target.y)
        
        // Determine if this is a positive or negative ability
        const ability = getAbilityById(useUIStore.getState().selectedAbility || '', selectedUnit)
        const isNegativeAbility = ability?.targetType === 'enemy'
        
        // Use appropriate colors for target highlighting
        let targetColor: number
        let targetAlpha: number
        
        if (isNegativeAbility) {
          // Reddish for negative abilities
          targetColor = HIGHLIGHT_CONFIG.COLORS.ATTACK
          targetAlpha = HIGHLIGHT_CONFIG.HIGHLIGHT.ATTACK_ALPHA
        } else {
          // Greenish for positive abilities
          targetColor = 0x16a34a // Green
          targetAlpha = HIGHLIGHT_CONFIG.HIGHLIGHT.ABILITY_ALPHA
        }
        
        this.abilityTargetGraphics.lineStyle(HIGHLIGHT_CONFIG.HIGHLIGHT.BORDER_WIDTH, targetColor, targetAlpha)
        this.abilityTargetGraphics.strokeRect(px, py, this.tileSizePx, this.tileSizePx)
        this.abilityTargetGraphics.fillStyle(targetColor, targetAlpha * 0.3)
        this.abilityTargetGraphics.fillRect(px, py, this.tileSizePx, this.tileSizePx)
      } else {
        // Target is a unit
        const { x: px, y: py } = this.tileToWorld(target.position.x, target.position.y)
        
        // Determine if this is a positive or negative ability
        const ability = getAbilityById(useUIStore.getState().selectedAbility || '', selectedUnit)
        const isNegativeAbility = ability?.targetType === 'enemy'
        
        // Use appropriate colors for target highlighting
        let targetColor: number
        let targetAlpha: number
        
        if (isNegativeAbility) {
          // Reddish for negative abilities
          targetColor = HIGHLIGHT_CONFIG.COLORS.ATTACK
          targetAlpha = HIGHLIGHT_CONFIG.HIGHLIGHT.ATTACK_ALPHA
        } else {
          // Greenish for positive abilities
          targetColor = 0x16a34a // Green
          targetAlpha = HIGHLIGHT_CONFIG.HIGHLIGHT.ABILITY_ALPHA
        }
        
        this.abilityTargetGraphics.lineStyle(HIGHLIGHT_CONFIG.HIGHLIGHT.BORDER_WIDTH, targetColor, targetAlpha)
        this.abilityTargetGraphics.strokeCircle(px + this.tileSizePx/2, py + this.tileSizePx/2, this.tileSizePx/2 + 2)
        this.abilityTargetGraphics.fillStyle(targetColor, targetAlpha * 0.3)
        this.abilityTargetGraphics.fillCircle(px + this.tileSizePx/2, py + this.tileSizePx/2, this.tileSizePx/2)
      }
    })
  }

  private showConePreview(caster: Unit, ability: Ability) {
    // For cone abilities, show a preview of the cone area
    // Check if this is a directional ability awaiting direction input
    const uiStore = useUIStore.getState()
    if (ability.requiresDirection && uiStore.abilityAwaitingDirection) {
      // Start listening for pointer movement to draw the preview
      this.scene.input.on('pointermove', this.updateConePreview, this)
      console.log('Cone preview mode activated - listening for mouse movement')
      return
    }
    
    // Default cone preview (facing right)
    const { x: casterX, y: casterY } = this.tileToWorld(caster.position.x, caster.position.y)
    const casterCenterX = casterX + this.tileSizePx / 2
    const casterCenterY = casterY + this.tileSizePx / 2
    
    // Draw cone preview (simplified for now - can be enhanced with mouse tracking)
    const coneRadius = (ability.range || 3) * this.tileSizePx
    const coneAngle = (ability.coneAngle || 90) * Math.PI / 180 // Convert to radians
    
    // Draw cone outline
    this.abilityTargetGraphics.lineStyle(HIGHLIGHT_CONFIG.HIGHLIGHT.BORDER_WIDTH, HIGHLIGHT_CONFIG.COLORS.ABILITY_AOE, HIGHLIGHT_CONFIG.HIGHLIGHT.ABILITY_ALPHA)
    this.abilityTargetGraphics.beginPath()
    this.abilityTargetGraphics.moveTo(casterCenterX, casterCenterY)
    
    // Draw cone arc (facing right for now)
    const startAngle = -coneAngle / 2
    const endAngle = coneAngle / 2
    this.abilityTargetGraphics.arc(casterCenterX, casterCenterY, coneRadius, startAngle, endAngle)
    this.abilityTargetGraphics.lineTo(casterCenterX, casterCenterY)
    this.abilityTargetGraphics.strokePath()
    
    // Fill cone area
    this.abilityTargetGraphics.fillStyle(HIGHLIGHT_CONFIG.COLORS.ABILITY_AOE, HIGHLIGHT_CONFIG.HIGHLIGHT.AOE_ALPHA)
    this.abilityTargetGraphics.fill()
  }

  // NEW METHOD to dynamically draw the cone preview
  private updateConePreview = (pointer: Phaser.Input.Pointer) => {
    const unitState = useUnitStore.getState()
    const uiStore = useUIStore.getState()
    const caster = unitState.selectedUnit
    const abilityId = uiStore.abilityAwaitingDirection

    if (!caster || !abilityId) {
      this.scene.input.off('pointermove', this.updateConePreview, this) // Stop listening
      return
    }

    this.abilityTargetGraphics.clear() // Clear previous preview
    const ability = getAbilityById(abilityId, caster)
    if (!ability) return

    const { x: tileX, y: tileY } = this.worldToTile(pointer.x, pointer.y)
    const direction = { x: tileX - caster.position.x, y: tileY - caster.position.y }

    const affectedTiles = getTilesInCone(caster.position, direction, ability.range, ability.coneAngle || 90)

    // Draw the highlight for all affected tiles
    this.abilityTargetGraphics.fillStyle(HIGHLIGHT_CONFIG.COLORS.ABILITY_AOE, HIGHLIGHT_CONFIG.HIGHLIGHT.AOE_ALPHA)
    affectedTiles.forEach(tile => {
      const { x: px, y: py } = this.tileToWorld(tile.x, tile.y)
      this.abilityTargetGraphics.fillRect(px, py, this.tileSizePx, this.tileSizePx)
    })
  }

  private showCirclePreview(caster: Unit, ability: Ability) {
    // For circle AOE abilities, show the area of effect
    const { x: casterX, y: casterY } = this.tileToWorld(caster.position.x, caster.position.y)
    const casterCenterX = casterX + this.tileSizePx / 2
    const casterCenterY = casterY + this.tileSizePx / 2
    
    const aoeRadius = (ability.aoeRadius || 2) * this.tileSizePx
    
    // Draw circle outline
    this.abilityTargetGraphics.lineStyle(HIGHLIGHT_CONFIG.HIGHLIGHT.BORDER_WIDTH, HIGHLIGHT_CONFIG.COLORS.ABILITY_AOE, HIGHLIGHT_CONFIG.HIGHLIGHT.ABILITY_ALPHA)
    this.abilityTargetGraphics.strokeCircle(casterCenterX, casterCenterY, aoeRadius)
    
    // Fill circle area
    this.abilityTargetGraphics.fillStyle(HIGHLIGHT_CONFIG.COLORS.ABILITY_AOE, HIGHLIGHT_CONFIG.HIGHLIGHT.AOE_ALPHA)
    this.abilityTargetGraphics.fill()
  }

  private showAttackPattern(caster: Unit, ability: Ability) {
    // Get the attack pattern from DataManager
    const attackPattern = dataManager.getAttackPattern(ability.range_pattern_key || 'single_target_melee')
    if (!attackPattern) {
      console.log('No attack pattern found for ability:', ability.id)
      return
    }

    console.log('Drawing attack pattern:', attackPattern.key, 'for ability:', ability.name)
    this.drawAttackPattern(attackPattern, caster)
  }

  private drawAttackPattern(pattern: AttackPattern, caster: Unit) {
    if (!this.abilityTargetGraphics) {
      console.error('abilityTargetGraphics not initialized!')
      return
    }

    const boardState = useBoardStore.getState()
    
    // Get the center of the pattern (where the caster is)
    const patternCenterX = Math.floor(pattern.pattern[0].length / 2)
    const patternCenterY = Math.floor(pattern.pattern.length / 2)
    
    console.log('Pattern center:', { patternCenterX, patternCenterY })
    console.log('Pattern dimensions:', { width: pattern.pattern[0].length, height: pattern.pattern.length })
    
    // Iterate through the pattern array
    for (let row = 0; row < pattern.pattern.length; row++) {
      for (let col = 0; col < pattern.pattern[row].length; col++) {
        const patternValue = pattern.pattern[row][col]
        
        // Only draw tiles marked as 1 (hit tiles)
        if (patternValue === 1) {
          // Calculate the relative position from the caster
          const relativeX = col - patternCenterX
          const relativeY = row - patternCenterY
          
          // Calculate the actual tile position
          const targetX = caster.position.x + relativeX
          const targetY = caster.position.y + relativeY
          
          // Check if this position is on the board
          if (targetX >= 0 && targetX < boardState.board[0].length && 
              targetY >= 0 && targetY < boardState.board.length) {
            
            // Check if this tile contains a valid target
            const hasValidTarget = this.validTargets.some(target => {
              if ('x' in target) {
                return target.x === targetX && target.y === targetY
              } else {
                return target.position.x === targetX && target.position.y === targetY
              }
            })
            
            // Only draw the pattern overlay if there's a valid target
            if (hasValidTarget) {
              const { x: px, y: py } = this.tileToWorld(targetX, targetY)
              
              console.log(`Drawing pattern tile at (${targetX}, ${targetY}) -> screen (${px}, ${py})`)
              
              // Draw pattern overlay with distinct color
              this.abilityTargetGraphics.fillStyle(0xff6b6b, 0.4) // Semi-transparent red
              this.abilityTargetGraphics.fillRect(px, py, this.tileSizePx, this.tileSizePx)
              
              // Add pattern border
              this.abilityTargetGraphics.lineStyle(2, 0xff6b6b, 0.8)
              this.abilityTargetGraphics.strokeRect(px, py, this.tileSizePx, this.tileSizePx)
            }
          }
        }
      }
    }
  }

  showAttackHighlights() {
    const unitState = useUnitStore.getState()
    const gameStore = useGameStore.getState()
    if (!unitState.selectedUnit) return

    // Clear existing highlights
    this.highlightGraphics.clear()
    
    // Get only enemies in attack range (use possibleTargets from store)
    const possibleTargets = gameStore.calculatePossibleTargets(unitState.selectedUnit)
    const enemies = unitState.units.filter((u) => 
      u.playerId !== unitState.selectedUnit!.playerId &&
      possibleTargets.some((target) => target.x === u.position.x && target.y === u.position.y)
    )
    
    // Highlight each enemy position with red
    enemies.forEach((enemy) => {
      const { x: px, y: py } = this.tileToWorld(enemy.position.x, enemy.position.y)
      
      // Draw red highlight for enemy targets
      this.highlightGraphics.fillStyle(HIGHLIGHT_CONFIG.COLORS.ATTACK, HIGHLIGHT_CONFIG.HIGHLIGHT.ATTACK_ALPHA)
      this.highlightGraphics.fillRect(px, py, this.tileSizePx, this.tileSizePx)
      this.highlightGraphics.lineStyle(HIGHLIGHT_CONFIG.HIGHLIGHT.BORDER_WIDTH, HIGHLIGHT_CONFIG.COLORS.ATTACK_RANGE, 1)
      this.highlightGraphics.strokeRect(px, py, this.tileSizePx, this.tileSizePx)
    })
  }

  showAbilityHighlights(abilityId: string) {
    const unitState = useUnitStore.getState()
    const boardState = useBoardStore.getState()
    if (!unitState.selectedUnit) return

    // Clear existing highlights
    this.highlightGraphics.clear()
    
    // Get valid targets for this ability
    const validTargets = getValidTargets(unitState.selectedUnit, { id: abilityId } as Ability, boardState.board, unitState.units)
    
    // Highlight each valid target with purple
    validTargets.forEach(target => {
      let px: number, py: number
      if ('x' in target) {
        // Coordinate target
        const { x: wx, y: wy } = this.tileToWorld(target.x, target.y)
        px = wx
        py = wy
      } else {
        // Unit target
        const { x: wx, y: wy } = this.tileToWorld(target.position.x, target.position.y)
        px = wx
        py = wy
      }
      
      // Draw purple highlight for ability targets
      this.highlightGraphics.fillStyle(HIGHLIGHT_CONFIG.COLORS.ABILITY, HIGHLIGHT_CONFIG.HIGHLIGHT.ABILITY_ALPHA)
      this.highlightGraphics.fillRect(px, py, this.tileSizePx, this.tileSizePx)
      this.highlightGraphics.lineStyle(HIGHLIGHT_CONFIG.HIGHLIGHT.BORDER_WIDTH, 0x7c3aed, 1)
      this.highlightGraphics.strokeRect(px, py, this.tileSizePx, this.tileSizePx)
    })
  }

  clearAll() {
    if (this.highlightGraphics) {
      this.highlightGraphics.clear()
    }
    if (this.abilityTargetGraphics) {
      this.abilityTargetGraphics.clear()
    }
  }

  getValidTargets(): (Unit | Coordinate)[] {
    return this.validTargets
  }

  isTargetingMode(): boolean {
    return this.targetingMode
  }

  destroy() {
    if (this.highlightGraphics) {
      this.highlightGraphics.destroy()
    }
    if (this.abilityTargetGraphics) {
      this.abilityTargetGraphics.destroy()
    }
  }
}

===== ./src/game/visuals/VisualEffectsPool.ts =====
import Phaser from 'phaser'
import { type Unit, type Coordinate } from 'shared'

export interface PooledGraphics {
  graphics: Phaser.GameObjects.Graphics
  isActive: boolean
  effectType: string
  tween?: Phaser.Tweens.Tween
}

export class VisualEffectsPool {
  private pools: Map<string, PooledGraphics[]> = new Map()
  private scene: Phaser.Scene
  private maxPoolSize: number = 20

  constructor(scene: Phaser.Scene) {
    this.scene = scene
    this.initializePools()
  }

  private initializePools() {
    // Initialize pools for different effect types
    const effectTypes = [
      'coffee_steam',
      'pink_slip_flash', 
      'paper_flying',
      'harass_aura',
      'overtime_glow',
      'paperclip_rain',
      'peace_aura',
      'hack_glitch',
      'tech_repair',
      'audit_glow',
      'money_sparkle',
      'legal_document',
      'shield_aura',
      'executive_aura',
      'restructure_blast'
    ]

    effectTypes.forEach(type => {
      this.pools.set(type, [])
    })
  }

  private createGraphicsForEffect(effectType: string): Phaser.GameObjects.Graphics {
    const graphics = this.scene.add.graphics()
    
    // Configure graphics based on effect type
    switch (effectType) {
      case 'coffee_steam':
        graphics.fillStyle(0x8B4513, 0.6)
        graphics.fillCircle(0, 0, 3)
        break
      case 'pink_slip_flash':
        graphics.fillStyle(0xff0000, 0.8)
        graphics.fillRect(-20, -20, 40, 40)
        break
      case 'paper_flying':
        graphics.fillStyle(0xffffff, 0.8)
        graphics.fillRect(-5, -8, 10, 16)
        break
      case 'harass_aura':
        graphics.lineStyle(2, 0xff6b6b, 0.8)
        graphics.strokeCircle(0, 0, 20)
        break
      case 'overtime_glow':
        graphics.fillStyle(0xffa500, 0.6)
        graphics.fillCircle(0, 0, 15)
        break
      case 'paperclip_rain':
        graphics.fillStyle(0xc0c0c0, 0.8)
        graphics.fillRect(-2, -6, 4, 12)
        break
      case 'peace_aura':
        graphics.fillStyle(0x90EE90, 0.6)
        graphics.fillCircle(0, 0, 18)
        break
      case 'hack_glitch':
        graphics.fillStyle(0x00ff00, 0.7)
        graphics.fillRect(-10, -10, 20, 20)
        break
      case 'tech_repair':
        graphics.fillStyle(0x4169E1, 0.6)
        graphics.fillCircle(0, 0, 12)
        break
      case 'audit_glow':
        graphics.fillStyle(0xffff00, 0.6)
        graphics.fillCircle(0, 0, 16)
        break
      case 'money_sparkle':
        graphics.fillStyle(0xffd700, 0.8)
        graphics.fillCircle(0, 0, 4)
        break
      case 'legal_document':
        graphics.fillStyle(0xffffff, 0.9)
        graphics.fillRect(-8, -12, 16, 24)
        break
      case 'shield_aura':
        graphics.lineStyle(3, 0x87CEEB, 0.8)
        graphics.strokeCircle(0, 0, 25)
        break
      case 'executive_aura':
        graphics.fillStyle(0xffd700, 0.7)
        graphics.fillCircle(0, 0, 30)
        break
      case 'restructure_blast':
        graphics.fillStyle(0xff4500, 0.8)
        graphics.fillCircle(0, 0, 35)
        break
    }

    return graphics
  }

  getEffect(effectType: string): PooledGraphics | null {
    const pool = this.pools.get(effectType)
    if (!pool) return null

    // Find an inactive effect
    let pooledEffect = pool.find(effect => !effect.isActive)
    
    if (!pooledEffect) {
      // Create new effect if pool is not full
      if (pool.length < this.maxPoolSize) {
        const graphics = this.createGraphicsForEffect(effectType)
        pooledEffect = {
          graphics,
          isActive: false,
          effectType
        }
        pool.push(pooledEffect)
      } else {
        // Reuse the oldest effect if pool is full
        pooledEffect = pool[0]
        this.returnEffect(pooledEffect)
      }
    }

    pooledEffect.isActive = true
    pooledEffect.graphics.setVisible(true)
    pooledEffect.graphics.setAlpha(1)
    pooledEffect.graphics.setScale(1)
    
    return pooledEffect
  }

  returnEffect(effect: PooledGraphics) {
    if (!effect.isActive) return

    effect.isActive = false
    effect.graphics.setVisible(false)
    
    // Stop any running tweens
    if (effect.tween) {
      effect.tween.stop()
      effect.tween = undefined
    }

    // Reset position and properties
    effect.graphics.setPosition(0, 0)
    effect.graphics.setAlpha(1)
    effect.graphics.setScale(1)
  }

  createCoffeeParticles(__target: Unit | Coordinate, position: { x: number, y: number }) {
    for (let i = 0; i < 8; i++) {
      const effect = this.getEffect('coffee_steam')
      if (!effect) continue

      effect.graphics.setPosition(position.x, position.y)
      
      effect.tween = this.scene.tweens.add({
        targets: effect.graphics,
        x: position.x + (Math.random() - 0.5) * 60,
        y: position.y - Math.random() * 80,
        alpha: 0,
        scaleX: 2,
        scaleY: 2,
        duration: 1500,
        onComplete: () => this.returnEffect(effect)
      })
    }
  }

  createPinkSlipEffect(__target: Unit | Coordinate, position: { x: number, y: number }) {
    const effect = this.getEffect('pink_slip_flash')
    if (!effect) return

    effect.graphics.setPosition(position.x, position.y)
    
    effect.tween = this.scene.tweens.add({
      targets: effect.graphics,
      alpha: 0,
      duration: 500,
      onComplete: () => this.returnEffect(effect)
    })
  }

  createPaperEffect(__target: Unit | Coordinate, position: { x: number, y: number }) {
    for (let i = 0; i < 5; i++) {
      const effect = this.getEffect('paper_flying')
      if (!effect) continue

      effect.graphics.setPosition(position.x, position.y)
      
      effect.tween = this.scene.tweens.add({
        targets: effect.graphics,
        x: position.x + (Math.random() - 0.5) * 100,
        y: position.y + (Math.random() - 0.5) * 100,
        rotation: Math.random() * Math.PI * 2,
        alpha: 0,
        duration: 2000,
        onComplete: () => this.returnEffect(effect)
      })
    }
  }

  createHarassEffect(__target: Unit | Coordinate, position: { x: number, y: number }) {
    const effect = this.getEffect('harass_aura')
    if (!effect) return

    effect.graphics.setPosition(position.x, position.y)
    
    effect.tween = this.scene.tweens.add({
      targets: effect.graphics,
      scaleX: 1.5,
      scaleY: 1.5,
      alpha: 0,
      duration: 1000,
      onComplete: () => this.returnEffect(effect)
    })
  }

  createOvertimeGlow(_target: Unit | Coordinate, position: { x: number, y: number }) {
    const effect = this.getEffect('overtime_glow')
    if (!effect) return

    effect.graphics.setPosition(position.x, position.y)
    
    effect.tween = this.scene.tweens.add({
      targets: effect.graphics,
      scaleX: 1.3,
      scaleY: 1.3,
      alpha: 0,
      duration: 1200,
      onComplete: () => this.returnEffect(effect)
    })
  }

  createPaperclipRain(_target: Unit | Coordinate, position: { x: number, y: number }) {
    for (let i = 0; i < 10; i++) {
      const effect = this.getEffect('paperclip_rain')
      if (!effect) continue

      effect.graphics.setPosition(position.x, position.y)
      
      effect.tween = this.scene.tweens.add({
        targets: effect.graphics,
        x: position.x + (Math.random() - 0.5) * 120,
        y: position.y + Math.random() * 100,
        rotation: Math.random() * Math.PI * 2,
        alpha: 0,
        duration: 1500,
        onComplete: () => this.returnEffect(effect)
      })
    }
  }

  createPeaceAura(_target: Unit | Coordinate, position: { x: number, y: number }) {
    const effect = this.getEffect('peace_aura')
    if (!effect) return

    effect.graphics.setPosition(position.x, position.y)
    
    effect.tween = this.scene.tweens.add({
      targets: effect.graphics,
      scaleX: 1.2,
      scaleY: 1.2,
      alpha: 0,
      duration: 1500,
      onComplete: () => this.returnEffect(effect)
    })
  }

  createHackGlitch(_target: Unit | Coordinate, position: { x: number, y: number }) {
    const effect = this.getEffect('hack_glitch')
    if (!effect) return

    effect.graphics.setPosition(position.x, position.y)
    
    effect.tween = this.scene.tweens.add({
      targets: effect.graphics,
      alpha: 0,
      scaleX: 1.5,
      scaleY: 1.5,
      duration: 800,
      onComplete: () => this.returnEffect(effect)
    })
  }

  createTechRepair(_target: Unit | Coordinate, position: { x: number, y: number }) {
    const effect = this.getEffect('tech_repair')
    if (!effect) return

    effect.graphics.setPosition(position.x, position.y)
    
    effect.tween = this.scene.tweens.add({
      targets: effect.graphics,
      scaleX: 1.4,
      scaleY: 1.4,
      alpha: 0,
      duration: 1000,
      onComplete: () => this.returnEffect(effect)
    })
  }

  createAuditGlow(_target: Unit | Coordinate, position: { x: number, y: number }) {
    const effect = this.getEffect('audit_glow')
    if (!effect) return

    effect.graphics.setPosition(position.x, position.y)
    
    effect.tween = this.scene.tweens.add({
      targets: effect.graphics,
      scaleX: 1.3,
      scaleY: 1.3,
      alpha: 0,
      duration: 1200,
      onComplete: () => this.returnEffect(effect)
    })
  }

  createMoneySparkle(_target: Unit | Coordinate, position: { x: number, y: number }) {
    for (let i = 0; i < 6; i++) {
      const effect = this.getEffect('money_sparkle')
      if (!effect) continue

      effect.graphics.setPosition(position.x, position.y)
      
      effect.tween = this.scene.tweens.add({
        targets: effect.graphics,
        x: position.x + (Math.random() - 0.5) * 80,
        y: position.y + (Math.random() - 0.5) * 80,
        alpha: 0,
        scaleX: 2,
        scaleY: 2,
        duration: 1000,
        onComplete: () => this.returnEffect(effect)
      })
    }
  }

  createLegalDocument(_target: Unit | Coordinate, position: { x: number, y: number }) {
    const effect = this.getEffect('legal_document')
    if (!effect) return

    effect.graphics.setPosition(position.x, position.y)
    
    effect.tween = this.scene.tweens.add({
      targets: effect.graphics,
      y: position.y - 50,
      alpha: 0,
      rotation: Math.PI * 0.1,
      duration: 1500,
      onComplete: () => this.returnEffect(effect)
    })
  }

  createShieldAura(_target: Unit | Coordinate, position: { x: number, y: number }) {
    const effect = this.getEffect('shield_aura')
    if (!effect) return

    effect.graphics.setPosition(position.x, position.y)
    
    effect.tween = this.scene.tweens.add({
      targets: effect.graphics,
      scaleX: 1.2,
      scaleY: 1.2,
      alpha: 0,
      duration: 1200,
      onComplete: () => this.returnEffect(effect)
    })
  }

  createExecutiveAura(_target: Unit | Coordinate, position: { x: number, y: number }) {
    const effect = this.getEffect('executive_aura')
    if (!effect) return

    effect.graphics.setPosition(position.x, position.y)
    
    effect.tween = this.scene.tweens.add({
      targets: effect.graphics,
      scaleX: 1.1,
      scaleY: 1.1,
      alpha: 0,
      duration: 2000,
      onComplete: () => this.returnEffect(effect)
    })
  }

  createRestructureBlast(_target: Unit | Coordinate, position: { x: number, y: number }) {
    const effect = this.getEffect('restructure_blast')
    if (!effect) return

    effect.graphics.setPosition(position.x, position.y)
    
    effect.tween = this.scene.tweens.add({
      targets: effect.graphics,
      scaleX: 1.5,
      scaleY: 1.5,
      alpha: 0,
      duration: 1000,
      onComplete: () => this.returnEffect(effect)
    })
  }

  destroy() {
    // Clean up all pooled graphics
    this.pools.forEach(pool => {
      pool.forEach(effect => {
        if (effect.tween) {
          effect.tween.stop()
        }
        effect.graphics.destroy()
      })
    })
    this.pools.clear()
  }
}

===== ./src/game/config.ts =====
export const GRID_CONFIG = {
  width: 10,
  height: 8,
  tile: 48,
}

export type Vec2 = { x: number; y: number }

export function manhattan(a: Vec2, b: Vec2) {
  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y)
}

export function isAdjacent(a: Vec2, b: Vec2) {
  return manhattan(a, b) === 1
}



===== ./src/game/systems/ai.ts =====
import { type GameState, type Unit, type Coordinate, TileType } from 'shared'
import { type Ability } from 'shared'
import { getUnitAbilities, canUseAbility, getValidTargets } from '../core/abilities'

interface AIActions {
  moveUnit: (unitId: string, to: Coordinate) => void
  attackTarget: (attackerId: string, targetId: string) => void
  captureCubicle: (unitId: string, coord: Coordinate) => void
  useAbility: (unitId: string, abilityId: string, target?: Unit | Coordinate) => void
  endTurn: () => void
}

export class AIController {
  private difficulty: 'easy' | 'normal' | 'hard'
  
  constructor(difficulty: 'easy' | 'normal' | 'hard' = 'normal') {
    this.difficulty = difficulty
  }

  takeTurn(state: GameState, actions: AIActions, getState: () => GameState): void {
    const myUnits = state.units.filter((u) => u.playerId === state.currentPlayerId)
    console.log('AI takeTurn called with', myUnits.length, 'units')
    
    // Process each unit
    for (const unit of myUnits) {
      console.log('Processing AI unit:', unit.id, 'actions remaining:', unit.actionsRemaining)
      
      // Process this unit until it has no actions left
      let shouldContinue = true
      let iterationCount = 0
      const maxIterations = 5 // Safety limit to detect infinite loops
      
      while (shouldContinue) {
        iterationCount++
        
        if (iterationCount > maxIterations) {
          console.error('ðM-^_M-^Z¨ INFINITE LOOP DETECTED! Unit', unit.id, 'has been processed', iterationCount, 'times without consuming actions')
          console.error('This indicates a bug in the action execution or state update logic')
          shouldContinue = false
          break
        }
        // Get fresh state before making decision
        const freshState = getState()
        const currentUnit = freshState.units.find(u => u.id === unit.id)
        
        if (!currentUnit || currentUnit.actionsRemaining <= 0) {
          console.log('Unit', unit.id, 'has no actions remaining or was destroyed, moving to next unit')
          break
        }
        
        const decision = this.makeDecision(currentUnit, freshState)
        console.log('AI decision for unit', currentUnit.id, ':', decision)
        
        if (!decision) {
          console.log('No decision found for unit', currentUnit.id)
          break
        }
        
        // Execute the decision through the action callbacks
        switch (decision.type) {
          case 'attack':
            console.log('Executing attack decision')
            actions.attackTarget(currentUnit.id, decision.targetId!)
            break
          case 'move':
            console.log('Executing move decision')
            actions.moveUnit(currentUnit.id, decision.position!)
            break
          case 'ability':
            console.log('Executing ability decision')
            actions.useAbility(currentUnit.id, decision.abilityId!, decision.target)
            break
          default:
            console.log('Unknown decision type:', decision.type)
            shouldContinue = false // Skip if no valid action
        }
        
        // After executing an action, check if we should continue
        // Get fresh state to see if actions were consumed
        const updatedState = getState()
        const updatedUnit = updatedState.units.find(u => u.id === unit.id)
        
        console.log('After action execution - Unit:', unit.id, 'Actions before:', currentUnit.actionsRemaining, 'Actions after:', updatedUnit?.actionsRemaining)
        
        if (!updatedUnit || updatedUnit.actionsRemaining <= 0) {
          console.log('Unit', unit.id, 'actions consumed, stopping processing')
          shouldContinue = false
        } else {
          console.log('Unit', unit.id, 'still has actions, continuing...')
        }
        
        // Small delay to allow state to update
        setTimeout(() => {}, 10)
      }
    }
    
    console.log('AI turn completed')
    // End the AI turn to return control to the player
    actions.endTurn()
  }

  private makeDecision(unit: Unit, state: GameState): { action: string; target?: Unit | { x: number; y: number }; priority: number; type?: string; targetId?: string; position?: { x: number; y: number }; abilityId?: string } | null {
    console.log('makeDecision called for unit:', unit.id, 'at position:', unit.position, 'actions:', unit.actionsRemaining)
    
    // Check if unit can still perform actions
    if (unit.actionsRemaining === 0) {
      console.log('Unit has no actions remaining')
      return null
    }
    
    // Priority order:
    // 1. Use abilities strategically
    // 2. Attack low-health enemies in range
    // 3. Capture nearby unowned cubicles
    // 4. Move toward objectives (enemies or cubicles)
    
    // Check for ability usage opportunities
    const abilityDecision = this.evaluateAbilityUsage(unit, state)
    if (abilityDecision) {
      console.log('Ability decision:', abilityDecision)
      return abilityDecision
    }
    
    // Check for attack opportunities
    const enemiesInRange = this.getEnemiesInRange(unit, state)
    console.log('Enemies in range:', enemiesInRange.length)
    if (enemiesInRange.length > 0 && !unit.hasAttacked && unit.actionsRemaining > 0) {
      // Sort by HP (attack weakest first)
      enemiesInRange.sort((a, b) => a.hp - b.hp)
      console.log('Attack decision: target', enemiesInRange[0].id)
      return { 
        action: 'attack', 
        target: enemiesInRange[0], 
        priority: 8, 
        type: 'attack', 
        targetId: enemiesInRange[0].id 
      }
    }
    
    // Check for capture opportunities (move to cubicles)
    const capturableTiles = this.getCapturableTiles(unit, state)
    console.log('Capturable tiles:', capturableTiles.length)
    if (capturableTiles.length > 0 && unit.actionsRemaining > 0 && !unit.hasMoved) {
      console.log('Move to capture decision: position', capturableTiles[0])
      return { 
        action: 'move', 
        target: capturableTiles[0], 
        priority: 6, 
        type: 'move', 
        position: capturableTiles[0] 
      }
    }
    
    // Move toward nearest objective
    if (!unit.hasMoved && unit.actionsRemaining > 0) {
      const moveTarget = this.getBestMovePosition(unit, state)
      console.log('Move target:', moveTarget)
      if (moveTarget) {
        console.log('Move decision: position', moveTarget)
        return { 
          action: 'move', 
          target: moveTarget, 
          priority: 4, 
          type: 'move', 
          position: moveTarget 
        }
      }
    }
    
    console.log('No decision found')
    return null
  }

  private evaluateAbilityUsage(unit: Unit, state: GameState): { action: string; target?: Unit | { x: number; y: number }; priority: number; type?: string; targetId?: string; position?: { x: number; y: number }; abilityId?: string } | null {
    // Check if unit has abilities and enough actions to use them
    if (!unit.abilities || unit.abilities.length === 0 || unit.actionsRemaining < 1) {
      return null
    }

    const availableAbilities = getUnitAbilities(unit).filter(ability => 
      canUseAbility(unit, ability.id)
    )

    if (availableAbilities.length === 0) {
      return null
    }

    // Score each ability based on strategic value
    let bestAbility = null
    let bestScore = -Infinity
    let bestTarget = null

    for (const ability of availableAbilities) {
              const validTargets = getValidTargets(unit, ability, state.board, state.units)
      
      for (const target of validTargets) {
        const score = this.scoreAbilityUsage(ability, target, unit)
        
        if (score > bestScore) {
          bestScore = score
          bestAbility = ability
          bestTarget = target
        }
      }
    }

    if (bestAbility && bestScore > 5) { // Threshold for using ability
      return {
        action: 'ability',
        target: bestTarget || undefined,
        priority: 9,
        type: 'ability',
        abilityId: bestAbility.id
      }
    }

    return null
  }

  private scoreAbilityUsage(ability: Ability, target: Unit | Coordinate, caster: Unit): number {
    let score = 0

    // Base score for different ability types
    switch (ability.id) {
      case 'pink_slip':
        // High value for execution abilities
        if ('hp' in target && target.hp <= 2) {
          score += 20
        }
        break
      case 'fetch_coffee':
        // Good for supporting allies
        if ('playerId' in target && target.playerId === caster.playerId) {
          score += 8
        }
        break
      case 'overtime':
        // Good when actions are needed
        if (caster.actionsRemaining <= 1) {
          score += 10
        }
        break
      case 'file_it':
        // Good for debuffing enemies
        if ('playerId' in target && target.playerId !== caster.playerId) {
          score += 6
        }
        break
      case 'harass':
        // Good for preventing captures
        if ('playerId' in target && target.playerId !== caster.playerId) {
          score += 7
        }
        break
      default:
        score += 3
    }

    // Bonus for targeting low HP enemies
    if ('hp' in target && target.hp <= 3) {
      score += 5
    }

    // Bonus for targeting high-value units (HR Managers, Executives)
    if ('type' in target) {
      if (target.type === 'hr_manager' || target.type === 'executive') {
        score += 4
      }
    }

    return score
  }

  private getEnemiesInRange(unit: Unit, state: GameState): Unit[] {
    const enemies = state.units.filter(enemy => {
      if (enemy.playerId === unit.playerId) return false
      const distance = Math.abs(enemy.position.x - unit.position.x) + 
                      Math.abs(enemy.position.y - unit.position.y)
      const inRange = distance <= unit.attackRange
      console.log('Enemy', enemy.id, 'at', enemy.position, 'distance:', distance, 'in range:', inRange, 'unit attack range:', unit.attackRange)
      return inRange
    })
    
    console.log('Enemies in range for unit', unit.id, ':', enemies.map(e => ({ id: e.id, position: e.position, hp: e.hp })))
    return enemies
  }

  private getCapturableTiles(unit: Unit, state: GameState): Coordinate[] {
    // AI now moves TO cubicles instead of capturing from adjacent positions
    // The actual capture happens at turn end when the unit is on the tile
    const possibleMoves = this.calculatePossibleMoves(unit, state)
    
    const capturable = possibleMoves.filter(coord => {
      const tile = state.board[coord.y]?.[coord.x]
      console.log('Checking moveable tile at', coord, 'type:', tile?.type, 'owner:', tile?.owner, 'unit player:', unit.playerId)
      
      // Check if it's a cubicle and not owned by this unit's player
      return tile?.type === TileType.CUBICLE && tile.owner !== unit.playerId
    })
    
    console.log('Capturable tiles found (AI will move to):', capturable)
    return capturable
  }

  private getBestMovePosition(unit: Unit, state: GameState): Coordinate | null {
    // Find all possible move positions
    const possibleMoves = this.calculatePossibleMoves(unit, state)
    console.log('Possible moves for unit', unit.id, ':', possibleMoves)
    
    if (possibleMoves.length === 0) {
      console.log('No possible moves found for unit', unit.id)
      return null
    }
    
    // Score each position based on proximity to objectives
    let bestMove = possibleMoves[0]
    let bestScore = -Infinity
    
    for (const move of possibleMoves) {
      let score = 0
      
      // Score based on proximity to enemies
      const nearestEnemy = this.findNearestEnemy(move, unit.playerId, state)
      if (nearestEnemy) {
        const distance = Math.abs(nearestEnemy.position.x - move.x) + 
                        Math.abs(nearestEnemy.position.y - move.y)
        score += (10 - distance) * 2 // Closer is better
      }
      
      // Score based on proximity to uncaptured cubicles
      const nearestCubicle = this.findNearestCubicle(move, unit.playerId, state)
      if (nearestCubicle) {
        const distance = Math.abs(nearestCubicle.x - move.x) + 
                        Math.abs(nearestCubicle.y - move.y)
        score += (10 - distance) // Closer is better
      }
      
      // Add randomness based on difficulty
      if (this.difficulty === 'easy') score += Math.random() * 5
      if (this.difficulty === 'normal') score += Math.random() * 2
      
      if (score > bestScore) {
        bestScore = score
        bestMove = move
      }
    }
    
    console.log('Best move for unit', unit.id, ':', bestMove, 'score:', bestScore)
    return bestMove
  }

  private calculatePossibleMoves(unit: Unit, state: GameState): Coordinate[] {
    const moves: Coordinate[] = []
    const visited = new Set<string>()
    const queue: { coord: Coordinate; distance: number }[] = [
      { coord: unit.position, distance: 0 }
    ]
    
    console.log('Calculating moves for unit', unit.id, 'at', unit.position, 'move range:', unit.moveRange)
    
    while (queue.length > 0) {
      const { coord, distance } = queue.shift()!
      const key = `${coord.x},${coord.y}`
      
      if (visited.has(key)) continue
      visited.add(key)
      
      if (distance > 0 && distance <= unit.moveRange) {
        const tile = state.board[coord.y]?.[coord.x]
        const occupied = state.units.some(u => 
          u.position.x === coord.x && u.position.y === coord.y
        )
        
        if (tile && tile.type !== TileType.OBSTACLE && !occupied) {
          moves.push(coord)
          console.log('Valid move found at', coord, 'distance:', distance)
        } else {
          console.log('Invalid move at', coord, 'tile type:', tile?.type, 'occupied:', occupied)
        }
      }
      
      if (distance < unit.moveRange) {
        const neighbors = [
          { x: coord.x + 1, y: coord.y },
          { x: coord.x - 1, y: coord.y },
          { x: coord.x, y: coord.y + 1 },
          { x: coord.x, y: coord.y - 1 },
        ]
        
        for (const neighbor of neighbors) {
          if (neighbor.x >= 0 && neighbor.x < state.board[0].length &&
              neighbor.y >= 0 && neighbor.y < state.board.length) {
            queue.push({ coord: neighbor, distance: distance + 1 })
          }
        }
      }
    }
    
    console.log('Total valid moves found:', moves.length)
    return moves
  }

  private findNearestEnemy(position: Coordinate, playerId: string, state: GameState): Unit | null {
    const enemies = state.units.filter(u => u.playerId !== playerId)
    if (enemies.length === 0) return null
    
    return enemies.reduce((nearest, enemy) => {
      const distToEnemy = Math.abs(enemy.position.x - position.x) + 
                         Math.abs(enemy.position.y - position.y)
      const distToNearest = Math.abs(nearest.position.x - position.x) + 
                           Math.abs(nearest.position.y - position.y)
      return distToEnemy < distToNearest ? enemy : nearest
    })
  }

  private findNearestCubicle(position: Coordinate, playerId: string, state: GameState): Coordinate | null {
    let nearest: Coordinate | null = null
    let minDistance = Infinity
    
    for (let y = 0; y < state.board.length; y++) {
      for (let x = 0; x < state.board[y].length; x++) {
        const tile = state.board[y][x]
        if (tile.type === TileType.CUBICLE && tile.owner !== playerId) {
          const distance = Math.abs(x - position.x) + Math.abs(y - position.y)
          if (distance < minDistance) {
            minDistance = distance
            nearest = { x, y }
          }
        }
      }
    }
    
    return nearest
  }
}



===== ./src/game/systems/ai.test.ts =====
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { AIController } from './ai'
import { createMockUnit, createMockGameState } from '../test/helpers.ts'
import { TileType, type Unit } from 'shared'

describe('AI Controller', () => {
  let aiController: AIController
  let mockActions: {
    moveUnit: (unitId: string, to: { x: number; y: number }) => void
    attackTarget: (attackerId: string, targetId: string) => void
    captureCubicle: (unitId: string, coord: { x: number; y: number }) => void
    useAbility: (unitId: string, abilityId: string, target?: Unit | { x: number; y: number }) => void
    endTurn: () => void
  }
  let mockGetState: ReturnType<typeof vi.fn>

  beforeEach(() => {
    aiController = new AIController('normal')
    mockActions = {
      moveUnit: vi.fn(),
      attackTarget: vi.fn(),
      captureCubicle: vi.fn(),
      useAbility: vi.fn(),
      endTurn: vi.fn()
    }
    mockGetState = vi.fn()
  })

  describe('AI Initialization', () => {
    it('should create AI controller with correct difficulty', () => {
      const easyAI = new AIController('easy')
      const hardAI = new AIController('hard')
      
      expect(easyAI).toBeInstanceOf(AIController)
      expect(hardAI).toBeInstanceOf(AIController)
    })
  })

  describe('AI Decision Making', () => {
    it('should prioritize ability usage when available', () => {
      const unit = createMockUnit({
        abilities: ['fetch_coffee'],
        actionsRemaining: 2,
        abilityCooldowns: {}
      })
      
      const ally = createMockUnit({
        playerId: 'player1',
        position: { x: 1, y: 0 }
      })
      
      const gameState = createMockGameState({
        units: [unit, ally],
        currentPlayerId: 'player1'
      })
      
      mockGetState.mockReturnValue(gameState)
      
      // Mock the private method by accessing it through the class
      const decision = (aiController as any).makeDecision(unit, gameState)
      
      expect(decision).toBeDefined()
      if (decision && decision.type === 'ability') {
        expect(decision.abilityId).toBe('fetch_coffee')
      }
    })

    it('should prioritize attacking low-health enemies', () => {
      const unit = createMockUnit({
        position: { x: 0, y: 0 },
        attackRange: 2,
        actionsRemaining: 1,
        hasAttacked: false
      })
      
      const weakEnemy = createMockUnit({
        playerId: 'player2',
        position: { x: 1, y: 0 },
        hp: 1
      })
      
      const strongEnemy = createMockUnit({
        playerId: 'player2',
        position: { x: 2, y: 0 },
        hp: 10
      })
      
      const gameState = createMockGameState({
        units: [unit, weakEnemy, strongEnemy],
        currentPlayerId: 'player1'
      })
      
      const decision = (aiController as any).makeDecision(unit, gameState)
      
      expect(decision).toBeDefined()
      if (decision && decision.type === 'attack') {
        expect(decision.targetId).toBe(weakEnemy.id)
      }
    })

    it('should prioritize capturing unowned cubicles', () => {
      const unit = createMockUnit({
        position: { x: 0, y: 0 },
        actionsRemaining: 1,
        hasMoved: false
      })
      
      const gameState = createMockGameState({
        units: [unit],
        currentPlayerId: 'player1'
      })
      
      // Set up adjacent unowned cubicle
      gameState.board[0][1] = {
        x: 1,
        y: 0,
        type: TileType.CUBICLE,
        owner: 'player2',
        occupied: undefined
      }
      
      const decision = (aiController as any).makeDecision(unit, gameState)
      
      expect(decision).toBeDefined()
      if (decision && decision.type === 'capture') {
        expect(decision.position).toEqual({ x: 1, y: 0 })
      }
    })

    it('should move toward objectives when no immediate actions available', () => {
      const unit = createMockUnit({
        position: { x: 0, y: 0 },
        moveRange: 2,
        actionsRemaining: 1,
        hasMoved: false
      })
      
      const enemy = createMockUnit({
        playerId: 'player2',
        position: { x: 3, y: 0 }
      })
      
      const gameState = createMockGameState({
        units: [unit, enemy],
        currentPlayerId: 'player1'
      })
      
      const decision = (aiController as any).makeDecision(unit, gameState)
      
      expect(decision).toBeDefined()
      if (decision && decision.type === 'move') {
        expect(decision.position).toBeDefined()
        // Should move toward enemy
        expect(decision.position.x).toBeGreaterThan(0)
      }
    })
  })

  describe('AI Ability Usage', () => {
    it('should use abilities strategically based on scoring', () => {
      const unit = createMockUnit({
        abilities: ['pink_slip'],
        actionsRemaining: 2,
        abilityCooldowns: {}
      })
      
      const lowHpEnemy = createMockUnit({
        playerId: 'player2',
        position: { x: 1, y: 0 },
        hp: 1
      })
      
      const gameState = createMockGameState({
        units: [unit, lowHpEnemy],
        currentPlayerId: 'player1'
      })
      
      const abilityDecision = (aiController as any).evaluateAbilityUsage(unit, gameState)
      
      expect(abilityDecision).toBeDefined()
      if (abilityDecision) {
        expect(abilityDecision.type).toBe('ability')
        expect(abilityDecision.abilityId).toBe('pink_slip')
        expect(abilityDecision.target).toBe(lowHpEnemy)
      }
    })

    it('should score abilities based on strategic value', () => {
      const unit = createMockUnit()
      const target = createMockUnit({ playerId: 'player2', hp: 1 })
      
      const score = (aiController as any).scoreAbilityUsage(
        { id: 'pink_slip' } as any,
        target,
        unit
      )
      
      expect(score).toBeGreaterThan(20) // High score for execution ability on low HP target
    })

    it('should not use abilities when cooldowns are active', () => {
      const unit = createMockUnit({
        abilities: ['fetch_coffee'],
        actionsRemaining: 2,
        abilityCooldowns: { 'fetch_coffee': 2 }
      })
      
      const gameState = createMockGameState({
        units: [unit],
        currentPlayerId: 'player1'
      })
      
      const abilityDecision = (aiController as any).evaluateAbilityUsage(unit, gameState)
      
      expect(abilityDecision).toBeNull()
    })
  })

  describe('AI Movement and Positioning', () => {
    it('should calculate valid move positions correctly', () => {
      const unit = createMockUnit({
        position: { x: 1, y: 1 },
        moveRange: 2
      })
      
      const gameState = createMockGameState({
        units: [unit],
        currentPlayerId: 'player1'
      })
      
              // Add obstacles
        gameState.board[0][1] = { x: 1, y: 0, type: TileType.OBSTACLE, owner: undefined, occupied: undefined }
        gameState.board[2][1] = { x: 1, y: 2, type: TileType.OBSTACLE, owner: undefined, occupied: undefined }
      
      const possibleMoves = (aiController as any).calculatePossibleMoves(unit, gameState)
      
      expect(possibleMoves.length).toBeGreaterThan(0)
      // Should not include obstacle positions
      expect(possibleMoves.some((move: { x: number; y: number }) => move.x === 1 && move.y === 0)).toBe(false)
      expect(possibleMoves.some((move: { x: number; y: number }) => move.x === 1 && move.y === 2)).toBe(false)
    })

    it('should find best move position based on objectives', () => {
      const unit = createMockUnit({
        position: { x: 0, y: 0 },
        moveRange: 2
      })
      
      const enemy = createMockUnit({
        playerId: 'player2',
        position: { x: 3, y: 0 }
      })
      
      const gameState = createMockGameState({
        units: [unit, enemy],
        currentPlayerId: 'player1'
      })
      
      const bestMove = (aiController as any).getBestMovePosition(unit, gameState)
      
      expect(bestMove).toBeDefined()
      if (bestMove) {
        // Should move toward enemy
        expect(bestMove.x).toBeGreaterThan(0)
      }
    })
  })

  describe('AI Target Selection', () => {
    it('should find enemies in attack range', () => {
      const unit = createMockUnit({
        position: { x: 0, y: 0 },
        attackRange: 2
      })
      
      const nearbyEnemy = createMockUnit({
        playerId: 'player2',
        position: { x: 1, y: 0 }
      })
      
      const farEnemy = createMockUnit({
        playerId: 'player2',
        position: { x: 3, y: 0 }
      })
      
      const gameState = createMockGameState({
        units: [unit, nearbyEnemy, farEnemy],
        currentPlayerId: 'player1'
      })
      
      const enemiesInRange = (aiController as any).getEnemiesInRange(unit, gameState)
      
      expect(enemiesInRange).toContain(nearbyEnemy)
      expect(enemiesInRange).not.toContain(farEnemy)
    })

    it('should find capturable tiles', () => {
      const unit = createMockUnit({
        position: { x: 1, y: 1 }
      })
      
      const gameState = createMockGameState({
        units: [unit],
        currentPlayerId: 'player1'
      })
      
      // Set up adjacent unowned cubicle
      gameState.board[1][2] = {
        x: 2,
        y: 1,
        type: TileType.CUBICLE,
        owner: 'player2',
        occupied: undefined
      }
      
      const capturableTiles = (aiController as any).getCapturableTiles(unit, gameState)
      
      expect(capturableTiles).toContainEqual({ x: 2, y: 1 })
    })
  })

  describe('AI Turn Execution', () => {
    it('should process all units during turn', () => {
      const unit1 = createMockUnit({ id: 'unit1', actionsRemaining: 1 })
      const unit2 = createMockUnit({ id: 'unit2', actionsRemaining: 1 })
      
      const gameState = createMockGameState({
        units: [unit1, unit2],
        currentPlayerId: 'player1'
      })
      
      mockGetState.mockReturnValue(gameState)
      
      aiController.takeTurn(gameState, mockActions, mockGetState)
      
      // Should call endTurn after processing all units
      expect(mockActions.endTurn).toHaveBeenCalled()
    })

    it('should continue processing unit until no actions remain', () => {
      const unit = createMockUnit({
        actionsRemaining: 3,
        hasMoved: false,
        hasAttacked: false
      })
      
      const gameState = createMockGameState({
        units: [unit],
        currentPlayerId: 'player1'
      })
      
      mockGetState.mockReturnValue(gameState)
      
      // Mock decision to return move action
      vi.spyOn(aiController as any, 'makeDecision').mockReturnValue({
        type: 'move',
        position: { x: 1, y: 0 }
      })
      
      aiController.takeTurn(gameState, mockActions, mockGetState)
      
      // Should call moveUnit
      expect(mockActions.moveUnit).toHaveBeenCalled()
    })
  })

  describe('AI Difficulty Settings', () => {
    it('should add randomness based on difficulty level', () => {
      const easyAI = new AIController('easy')
      const normalAI = new AIController('normal')
      const hardAI = new AIController('hard')
      
      const unit = createMockUnit({
        position: { x: 0, y: 0 },
        moveRange: 2
      })
      
      const gameState = createMockGameState({
        units: [unit],
        currentPlayerId: 'player1'
      })
      
      // Test that different difficulties produce different scores
      const easyScore = (easyAI as any).getBestMovePosition(unit, gameState)
      const normalScore = (normalAI as any).getBestMovePosition(unit, gameState)
      const hardScore = (hardAI as any).getBestMovePosition(unit, gameState)
      
      // All should return valid moves
      expect(easyScore).toBeDefined()
      expect(normalScore).toBeDefined()
      expect(hardScore).toBeDefined()
    })
  })

  describe('Edge Cases', () => {
    it('should handle units with no actions remaining', () => {
      const unit = createMockUnit({ actionsRemaining: 0 })
      const gameState = createMockGameState({
        units: [unit],
        currentPlayerId: 'player1'
      })
      
      const decision = (aiController as any).makeDecision(unit, gameState)
      
      expect(decision).toBeNull()
    })

    it('should handle units with no valid moves', () => {
      const unit = createMockUnit({
        position: { x: 0, y: 0 },
        moveRange: 1
      })
      
      const gameState = createMockGameState({
        units: [unit],
        currentPlayerId: 'player1'
      })
      
      // Surround with obstacles
      gameState.board[0][1] = { x: 1, y: 0, type: TileType.OBSTACLE, owner: undefined, occupied: undefined }
      gameState.board[1][0] = { x: 0, y: 1, type: TileType.OBSTACLE, owner: undefined, occupied: undefined }
      
      const bestMove = (aiController as any).getBestMovePosition(unit, gameState)
      
      expect(bestMove).toBeNull()
    })

    it('should handle empty game state gracefully', () => {
      const emptyGameState = createMockGameState({
        units: [],
        currentPlayerId: 'player1'
      })
      
      expect(() => {
        aiController.takeTurn(emptyGameState, mockActions, mockGetState)
      }).not.toThrow()
      
      expect(mockActions.endTurn).toHaveBeenCalled()
    })
  })
})

===== ./src/game/data/DataManager.ts =====
import { type Employee, type DataAbility, type AttackPattern, type StatusEffect, type GameConfig, type Unit, UnitType } from 'shared'

interface LoadedData {
  employees: Map<string, Employee>
  abilities: Map<string, DataAbility>
  attackPatterns: Map<string, AttackPattern>
  statusEffects: Map<string, StatusEffect>
  gameConfig: GameConfig
}

export class DataManager {
  private static instance: DataManager
  private data: LoadedData
  private isLoaded: boolean = false
  private loadingPromise: Promise<void> | null = null

  private constructor() {
    this.data = {
      employees: new Map(),
      abilities: new Map(),
      attackPatterns: new Map(),
      statusEffects: new Map(),
      gameConfig: {} as GameConfig
    }
  }

  public static getInstance(): DataManager {
    if (!DataManager.instance) {
      DataManager.instance = new DataManager()
    }
    return DataManager.instance
  }

  public async loadAll(): Promise<void> {
    if (this.loadingPromise) {
      return this.loadingPromise
    }
    console.log('DataManager: Starting to load all game data...')

    this.loadingPromise = (async () => {
      try {
        // Load all data files in parallel
        await Promise.all([
          this.loadEmployees(),
          this.loadAbilities(),
          this.loadAttackPatterns(),
          this.loadStatusEffects(),
          this.loadGameConfig()
        ])
        
        this.isLoaded = true
        console.log('DataManager: All game data loaded successfully!')
      } catch (error) {
        console.error('DataManager: Failed to load all game data:', error)
        this.loadingPromise = null // Reset on failure
        throw error
      }
    })()

    return this.loadingPromise
  }

  private async loadEmployees(): Promise<void> {
    try {
      const response = await fetch('/data/employees.json')
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const jsonData = await response.json()
      const employees = jsonData.employees as Employee[]
      
      // Convert array to Map for O(1) lookup
      employees.forEach(employee => {
        this.data.employees.set(employee.key, employee)
      })
      
      console.log(`DataManager: Loaded ${employees.length} employees`)
    } catch (error) {
      console.error("Error loading 'employees.json':", error)
      throw error
    }
  }

  private async loadAbilities(): Promise<void> {
    try {
      const response = await fetch('/data/abilities.json')
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const jsonData = await response.json()
      const abilities = jsonData.abilities as DataAbility[]
      
      // Convert array to Map for O(1) lookup
      abilities.forEach(ability => {
        this.data.abilities.set(ability.key, ability)
      })
      
      console.log(`DataManager: Loaded ${abilities.length} abilities`)
    } catch (error) {
      console.error("Error loading 'abilities.json':", error)
      throw error
    }
  }

  private async loadAttackPatterns(): Promise<void> {
    try {
      const response = await fetch('/data/attack_patterns.json')
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const jsonData = await response.json()
      const attackPatterns = jsonData.attack_patterns as AttackPattern[]
      
      // Convert array to Map for O(1) lookup
      attackPatterns.forEach(pattern => {
        this.data.attackPatterns.set(pattern.key, pattern)
      })
      
      console.log(`DataManager: Loaded ${attackPatterns.length} attack patterns`)
    } catch (error) {
      console.error("Error loading 'attack_patterns.json':", error)
      throw error
    }
  }

  private async loadStatusEffects(): Promise<void> {
    try {
      const response = await fetch('/data/status_effects.json')
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const jsonData = await response.json()
      const statusEffects = jsonData.status_effects as StatusEffect[]
      
      // Convert array to Map for O(1) lookup
      statusEffects.forEach(effect => {
        this.data.statusEffects.set(effect.key, effect)
      })
      
      console.log(`DataManager: Loaded ${statusEffects.length} status effects`)
    } catch (error) {
      console.error("Error loading 'status_effects.json':", error)
      throw error
    }
  }

  private async loadGameConfig(): Promise<void> {
    try {
      const response = await fetch('/data/game_config.json')
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const jsonData = await response.json()
      this.data.gameConfig = jsonData as GameConfig
      
      console.log('DataManager: Loaded game configuration')
    } catch (error) {
      console.error("Error loading 'game_config.json':", error)
      throw error
    }
  }

  // Getter methods for easy access
  public getEmployee(key: string): Employee | undefined {
    if (!this.isLoaded) {
      console.warn('DataManager: Data not loaded yet, returning undefined for employee:', key)
      return undefined
    }
    return this.data.employees.get(key)
  }

  public getAbility(key: string): DataAbility | undefined {
    if (!this.isLoaded) {
      console.warn('DataManager: Data not loaded yet, returning undefined for ability:', key)
      return undefined
    }
    return this.data.abilities.get(key)
  }

  public getAttackPattern(key: string): AttackPattern | undefined {
    if (!this.isLoaded) {
      console.warn('DataManager: Data not loaded yet, returning undefined for attack pattern:', key)
      return undefined
    }
    return this.data.attackPatterns.get(key)
  }

  public getStatusEffect(key: string): StatusEffect | undefined {
    if (!this.isLoaded) {
      console.warn('DataManager: Data not loaded yet, returning undefined for status effect:', key)
      return undefined
    }
    return this.data.statusEffects.get(key)
  }

  public getConfig(): GameConfig {
    if (!this.isLoaded) {
      console.warn('DataManager: Data not loaded yet, returning empty config')
      return {} as GameConfig
    }
    return this.data.gameConfig
  }

  public getAllEmployees(): Employee[] {
    if (!this.isLoaded) {
      console.warn('DataManager: Data not loaded yet, returning empty array')
      return []
    }
    return Array.from(this.data.employees.values())
  }

  public getAllAbilities(): DataAbility[] {
    if (!this.isLoaded) {
      console.warn('DataManager: Data not loaded yet, returning empty array')
      return []
    }
    return Array.from(this.data.abilities.values())
  }

  public getAllAttackPatterns(): AttackPattern[] {
    if (!this.isLoaded) {
      console.warn('DataManager: Data not loaded yet, returning empty array')
      return []
    }
    return Array.from(this.data.attackPatterns.values())
  }

  public getAllStatusEffects(): StatusEffect[] {
    if (!this.isLoaded) {
      console.warn('DataManager: Data not loaded yet, returning empty array')
      return []
    }
    return Array.from(this.data.statusEffects.values())
  }

  public isDataLoaded(): boolean {
    return this.isLoaded
  }

  public async ensureLoaded(): Promise<void> {
    if (this.isLoaded) {
      return Promise.resolve()
    }
    if (!this.loadingPromise) {
      // This will also handle the case where loading failed and was reset
      return this.loadAll()
    }
    return this.loadingPromise
  }

  // Utility method to get employee by ID (for backward compatibility)
  public getEmployeeById(id: number): Employee | undefined {
    if (!this.isLoaded) {
      console.warn('DataManager: Data not loaded yet, returning undefined for employee ID:', id)
      return undefined
    }
    return Array.from(this.data.employees.values()).find(emp => emp.id === id)
  }

  // Convert Employee data to Unit data for game logic
  public createUnitFromEmployee(employee: Employee, id: string, playerId: string, position: { x: number; y: number }): Unit {
    // Get abilities directly from employee's ability_keys array
    const abilities = employee.ability_keys || []
    
    return {
      id,
      playerId,
      type: this.mapEmployeeKeyToUnitType(employee.key),
      position,
      hp: employee.stats.health,
      maxHp: employee.stats.health,
      moveRange: employee.stats.speed,
      attackRange: employee.attack.range,
      attackDamage: employee.stats.attack_power,
      actionsRemaining: 2, // Default actions
      maxActions: 2,
      status: [],
      cost: employee.cost,
      hasMoved: false,
      hasAttacked: false,
      abilities: abilities,
      abilityCooldowns: {},
      movementUsed: 0,
      remainingMovement: employee.stats.speed,
      direction: 'down', // Default direction
    }
  }


  // Map employee keys to UnitType enum
  private mapEmployeeKeyToUnitType(employeeKey: string): UnitType {
    const keyMap: Record<string, UnitType> = {
      'salesman': UnitType.SALES_REP,
      'secretary': UnitType.SECRETARY,
      'manager': UnitType.HR_MANAGER,
      'it_guy': UnitType.IT_SPECIALIST,
    }
    return keyMap[employeeKey] || UnitType.INTERN
  }
}

// Export singleton instance
export const dataManager = DataManager.getInstance()
===== ./src/game/debug/GridOverlay.ts =====
import Phaser from "phaser";

export class GridOverlay {
  private layerLines: Phaser.GameObjects.Graphics;
  private labels: Phaser.GameObjects.Text[] = [];
  private visible = false;
  private scene: Phaser.Scene;
  private cols: number;
  private rows: number;
  private tile: number;

  constructor(
    scene: Phaser.Scene,
    cols: number,
    rows: number,
    tile: number
  ) {
    this.scene = scene;
    this.cols = cols;
    this.rows = rows;
    this.tile = tile;
    this.layerLines = scene.add.graphics().setDepth(200);
    scene.input.keyboard?.on("keydown-G", () => this.toggle());
  }

  toggle() {
    this.visible = !this.visible;
    this.layerLines.clear();
    this.labels.forEach(t => t.destroy());
    this.labels.length = 0;

    if (!this.visible) return;

    this.layerLines.lineStyle(1, 0xffffff, 0.17);
    for (let x = 0; x <= this.cols; x++) {
      const px = x * this.tile;
      this.layerLines.lineBetween(px, 0, px, this.rows * this.tile);
    }
    for (let y = 0; y <= this.rows; y++) {
      const py = y * this.tile;
      this.layerLines.lineBetween(0, py, this.cols * this.tile, py);
    }

    for (let y = 0; y < this.rows; y++) {
      for (let x = 0; x < this.cols; x++) {
        const tx = x * this.tile + 4;
        const ty = y * this.tile + 2;
        const t = this.scene.add.text(tx, ty, `${x},${y}`, { fontSize: "10px", color: "#ffffffaa" })
          .setDepth(201);
        this.labels.push(t);
      }
    }
  }
}

===== ./src/components/BottomSheet.tsx =====
import React, { useState, useEffect, useRef, useCallback } from 'react'

interface BottomSheetProps {
  isOpen: boolean
  onClose: () => void
  children: React.ReactNode
  title?: string
  className?: string
  snapPoints?: number[] // Heights in pixels for different snap points
  initialSnapPoint?: number // Index of initial snap point
}

export function BottomSheet({
  isOpen,
  onClose,
  children,
  title,
  className = '',
  snapPoints = [200, 400, 600], // Default snap points
  initialSnapPoint = 0
}: BottomSheetProps) {
  const [currentSnapPoint, setCurrentSnapPoint] = useState(initialSnapPoint)
  const [isDragging, setIsDragging] = useState(false)
  const [startY, setStartY] = useState(0)
  const [currentY, setCurrentY] = useState(0)
  const [translateY, setTranslateY] = useState(0)
  
  const sheetRef = useRef<HTMLDivElement>(null)
  const backdropRef = useRef<HTMLDivElement>(null)

  // Handle touch start
  const handleTouchStart = useCallback((e: React.TouchEvent) => {
    setIsDragging(true)
    setStartY(e.touches[0].clientY)
    setCurrentY(e.touches[0].clientY)
  }, [])

  // Handle touch move
  const handleTouchMove = useCallback((e: React.TouchEvent) => {
    if (!isDragging) return
    
    const deltaY = e.touches[0].clientY - startY
    const newTranslateY = Math.max(0, deltaY)
    setTranslateY(newTranslateY)
    setCurrentY(e.touches[0].clientY)
  }, [isDragging, startY])

  // Handle touch end
  const handleTouchEnd = useCallback(() => {
    if (!isDragging) return
    
    setIsDragging(false)
    const deltaY = currentY - startY
    
    // Determine which snap point to go to
    if (deltaY > 100) {
      // Swipe down - close or go to lower snap point
      if (currentSnapPoint > 0) {
        setCurrentSnapPoint(currentSnapPoint - 1)
      } else {
        onClose()
      }
    } else if (deltaY < -100) {
      // Swipe up - go to higher snap point
      if (currentSnapPoint < snapPoints.length - 1) {
        setCurrentSnapPoint(currentSnapPoint + 1)
      }
    }
    
    setTranslateY(0)
  }, [isDragging, currentY, startY, currentSnapPoint, snapPoints.length, onClose])

  // Handle backdrop click
  const handleBackdropClick = useCallback((e: React.MouseEvent) => {
    if (e.target === backdropRef.current) {
      onClose()
    }
  }, [onClose])

  // Handle escape key
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        onClose()
      }
    }

    if (isOpen) {
      document.addEventListener('keydown', handleEscape)
      document.body.style.overflow = 'hidden' // Prevent background scroll
    }

    return () => {
      document.removeEventListener('keydown', handleEscape)
      document.body.style.overflow = 'unset'
    }
  }, [isOpen, onClose])

  // Calculate current height based on snap point
  const currentHeight = snapPoints[currentSnapPoint] || snapPoints[0]

  if (!isOpen) return null

  return (
    <>
      {/* Backdrop */}
      <div
        ref={backdropRef}
        className="fixed inset-0 bg-black bg-opacity-50 z-40 transition-opacity duration-300"
        onClick={handleBackdropClick}
      />
      
      {/* Bottom Sheet */}
      <div
        ref={sheetRef}
        className={`fixed bottom-0 left-0 right-0 bg-slate-800 border-t border-slate-700 rounded-t-xl shadow-2xl z-50 transition-all duration-300 ease-out ${className}`}
        style={{
          height: `${currentHeight}px`,
          transform: `translateY(${translateY}px)`,
          touchAction: 'none'
        }}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
      >
        {/* Handle bar */}
        <div className="flex justify-center pt-3 pb-2">
          <div className="w-12 h-1 bg-slate-600 rounded-full" />
        </div>

        {/* Header */}
        {title && (
          <div className="px-6 pb-4 border-b border-slate-700">
            <h3 className="text-lg font-semibold text-slate-100">{title}</h3>
          </div>
        )}

        {/* Content */}
        <div className="flex-1 overflow-y-auto px-6 py-4">
          {children}
        </div>

        {/* Snap point indicators */}
        <div className="flex justify-center gap-2 pb-4">
          {snapPoints.map((_, index) => (
            <button
              key={index}
              onClick={() => setCurrentSnapPoint(index)}
              className={`w-2 h-2 rounded-full transition-colors ${
                index === currentSnapPoint ? 'bg-blue-500' : 'bg-slate-600'
              }`}
            />
          ))}
        </div>
      </div>
    </>
  )
}

===== ./src/components/ui/Modal.tsx =====
import React, { useEffect, useRef } from 'react'
import { createPortal } from 'react-dom'

interface ModalProps {
  isOpen: boolean
  onClose: () => void
  title: string
  children: React.ReactNode
  size?: 'sm' | 'md' | 'lg' | 'xl'
  className?: string
}

const sizeClasses = {
  sm: 'max-w-sm',
  md: 'max-w-md',
  lg: 'max-w-lg',
  xl: 'max-w-xl'
}

export function Modal({ 
  isOpen, 
  onClose, 
  title, 
  children, 
  size = 'md',
  className = ''
}: ModalProps) {
  const modalRef = useRef<HTMLDivElement>(null)
  const previousActiveElement = useRef<HTMLElement | null>(null)

  // Handle ESC key
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose()
      }
    }

    if (isOpen) {
      document.addEventListener('keydown', handleEscape)
      // Store the currently active element for focus restoration
      previousActiveElement.current = document.activeElement as HTMLElement
      // Prevent body scroll
      document.body.style.overflow = 'hidden'
    }

    return () => {
      document.removeEventListener('keydown', handleEscape)
      // Restore body scroll
      document.body.style.overflow = 'unset'
      // Restore focus to the previous element
      if (previousActiveElement.current) {
        previousActiveElement.current.focus()
      }
    }
  }, [isOpen, onClose])

  // Focus trap
  useEffect(() => {
    if (isOpen && modalRef.current) {
      const focusableElements = modalRef.current.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      )
      
      if (focusableElements.length > 0) {
        const firstElement = focusableElements[0] as HTMLElement
        firstElement.focus()
      }
    }
  }, [isOpen])

  if (!isOpen) return null

  return createPortal(
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
      {/* Backdrop */}
      <div 
        className="absolute inset-0 bg-black bg-opacity-50 transition-opacity"
        onClick={onClose}
        aria-hidden="true"
      />
      
      {/* Modal */}
      <div
        ref={modalRef}
        className={`relative bg-slate-800 rounded-lg border border-slate-700 shadow-2xl w-full ${sizeClasses[size]} ${className}`}
        role="dialog"
        aria-modal="true"
        aria-labelledby="modal-title"
      >
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-slate-700">
          <h2 id="modal-title" className="text-xl font-semibold text-slate-100">
            {title}
          </h2>
          <button
            onClick={onClose}
            className="text-slate-400 hover:text-slate-200 transition-colors p-1 rounded-full hover:bg-slate-700"
            aria-label="Close modal"
          >
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        
        {/* Content */}
        <div className="p-6">
          {children}
        </div>
      </div>
    </div>,
    document.body
  )
}

===== ./src/components/GameView.tsx =====
import { useEffect, useRef, useState } from 'react'
import Phaser from 'phaser'
import { GameScene } from '../game/scenes/GameScene'
import { PauseMenu } from './PauseMenu'
import { ResponsiveGameManager } from '../game/responsive/ResponsiveGameManager'

// Type definitions for Phaser extensions
interface ExtendedGameScene extends Phaser.Scene {
  key: string
}

interface ExtendedWindow extends Window {
  gameScene?: ExtendedGameScene
}

declare const window: ExtendedWindow

export function GameView() {
  const containerRef = useRef<HTMLDivElement | null>(null)
  const gameRef = useRef<Phaser.Game | null>(null)
  const responsiveManagerRef = useRef<ResponsiveGameManager | null>(null)
  const [isPaused, setIsPaused] = useState(false)
  const [currentTileSize, setCurrentTileSize] = useState(48)



  useEffect(() => {
    if (!containerRef.current || gameRef.current) return

    // Simple initial dimensions - ResponsiveGameManager will handle the rest
    const initialWidth = 640  // 16 * 40px tiles
    const initialHeight = 480 // 12 * 40px tiles

    const game = new Phaser.Game({
      type: Phaser.AUTO,
      parent: containerRef.current,
      backgroundColor: '#0f172a',
      scale: {
        mode: Phaser.Scale.RESIZE, // Better for responsive resizing
        autoCenter: Phaser.Scale.CENTER_BOTH, // Center the game in the container
        width: initialWidth,
        height: initialHeight,
        min: {
          width: 400,
          height: 300
        },
        max: {
          width: 1600,
          height: 1200
        }
      },
      scene: [GameScene],
      physics: { default: 'arcade' },
    })

    gameRef.current = game

    // Initialize ResponsiveGameManager after game is ready
    game.events.once('ready', () => {
      console.log('Game ready, initializing ResponsiveGameManager')
      responsiveManagerRef.current = new ResponsiveGameManager(game)
      
      // Also try to attach GameScene when game is ready
      const readyScene = game.scene.getScene('GameScene') as ExtendedGameScene
      if (readyScene && !window.gameScene) {
        attachGameScene(readyScene, 'game ready event')
      }
    })

    // Multiple ways to detect when GameScene is ready
    const attachGameScene = (scene: ExtendedGameScene, method: string) => {
      if (scene && scene.key === 'GameScene') {
        console.log(`GameScene ready via ${method}, attaching to window.gameScene`)
        window.gameScene = scene
        return true
      }
      return false
    }

    // Method 1: Listen for scene start
    game.events.once('scene-start', (scene: Phaser.Scene) => {
      attachGameScene(scene as ExtendedGameScene, 'scene-start event')
    })

    // Method 2: Listen for scene wake
    game.events.once('scene-wake', (scene: Phaser.Scene) => {
      attachGameScene(scene as ExtendedGameScene, 'scene-wake event')
    })

    // Method 3: Try immediate access
    const immediateScene = game.scene.getScene('GameScene') as ExtendedGameScene
    if (immediateScene) {
      attachGameScene(immediateScene, 'immediate access')
    }

    // Method 4: Fallback timer - check every 100ms for up to 5 seconds
    let attempts = 0
    const maxAttempts = 50
    const checkScene = () => {
      attempts++
      const scene = game.scene.getScene('GameScene') as ExtendedGameScene
      if (scene && !window.gameScene) {
        if (attachGameScene(scene, `fallback timer (attempt ${attempts})`)) {
          return // Success!
        }
      }
      
      if (attempts < maxAttempts) {
        setTimeout(checkScene, 100)
      } else {
        console.warn('GameScene not available after 5 seconds - action menu may not work')
        // Try one more time with a different approach
        const finalScene = game.scene.getScene('GameScene') as ExtendedGameScene
        if (finalScene) {
          console.log('Final attempt: Found GameScene, forcing attachment')
          window.gameScene = finalScene
        }
      }
    }
    
    // Start the fallback check
    setTimeout(checkScene, 100)



    // NOTE: ResponsiveGameManager now handles all game resizing
    // The old resize handler has been removed to prevent conflicts
    
    // Handle keyboard events for pause
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        setIsPaused(prev => !prev)
      }
    }

    document.addEventListener('keydown', handleKeyDown)

    // Add event listener for ResponsiveGameManager
    const handleGameBoardResized = (event: CustomEvent) => {
      const { tileSize: newTileSize, width, height } = event.detail
      console.log(`GameView: Game board resized to ${width}x${height}, tile size: ${newTileSize}px`)
      setCurrentTileSize(newTileSize)
    }

    window.addEventListener('gameBoardResized', handleGameBoardResized as EventListener)

    return () => {
      document.removeEventListener('keydown', handleKeyDown)
      window.removeEventListener('gameBoardResized', handleGameBoardResized as EventListener)
      
      // Clean up ResponsiveGameManager
      responsiveManagerRef.current?.destroy()
      responsiveManagerRef.current = null
      
      game.destroy(true)
      gameRef.current = null
    }
  }, [])

  const handleResume = () => {
    setIsPaused(false)
  }

  const handleQuit = () => {
    // For now, just unpause. Later this could navigate to main menu
    setIsPaused(false)
  }

  return (
    <div className="flex justify-center items-center rounded-md border border-slate-800 p-2 bg-slate-950 w-full h-full">
      <div 
        ref={containerRef} 
        className="relative flex justify-center items-center"
        style={{ 
          width: '100%',
          height: '100%',
          minHeight: '400px'
        }}
      />
      
      {/* Debug info for responsive testing */}
      {process.env.NODE_ENV === 'development' && (
        <div className="absolute bottom-2 left-2 bg-slate-800 text-slate-200 text-xs p-2 rounded border border-slate-600">
          <div>Tile Size: {currentTileSize}px</div>
          <div>Board: {gameRef.current?.scale.width || 0}ÃM-^W{gameRef.current?.scale.height || 0}</div>
          <div>Screen: {window.innerWidth}ÃM-^W{window.innerHeight}</div>
          <div>Map: 16ÃM-^W12 tiles</div>
          <div>Expected: {16 * currentTileSize}ÃM-^W{12 * currentTileSize}px</div>
          <button 
            onClick={() => {
              if (responsiveManagerRef.current) {
                console.log('GameView: Manually testing ResponsiveGameManager');
                const tileSize = responsiveManagerRef.current.getCurrentTileSize();
                console.log(`GameView: Current tile size: ${tileSize}px`);
                console.log(`GameView: Expected board size: ${16 * tileSize}ÃM-^W${12 * tileSize}px`);
                console.log(`GameView: Actual board size: ${gameRef.current?.scale.width}ÃM-^W${gameRef.current?.scale.height}px`);
              } else {
                console.log('GameView: ResponsiveGameManager not initialized');
              }
            }}
            className="mt-2 px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700"
          >
            Test Responsive
          </button>
        </div>
      )}
      
      <PauseMenu 
        isPaused={isPaused}
        onResume={handleResume}
        onQuit={handleQuit}
      />
    </div>
  )
}



===== ./src/components/DraftScreen.tsx =====
import { useGameStore } from '../stores/gameStore'
import { dataManager } from '../game/data/DataManager'

export function DraftScreen() {
  // Use selectors for state that causes re-renders
  const draftState = useGameStore(state => state.draftState)
  
  // Actions don't need selectors as they don't cause re-renders
  const addUnitToDraft = useGameStore(state => state.addUnitToDraft)
  const removeUnitFromDraft = useGameStore(state => state.removeUnitFromDraft)
  const confirmDraft = useGameStore(state => state.confirmDraft)
  
  const totalCost = draftState.selectedUnits.reduce((sum, unit) => {
    const employee = dataManager.getEmployee(unit.employeeKey)
    return sum + (employee?.cost || 0)
  }, 0)
  const remainingBudget = draftState.playerBudget - totalCost
  const canAddMore = draftState.selectedUnits.length < draftState.maxHeadcount && remainingBudget >= 20
  
  const handleAddUnit = (employeeKey: string) => {
    if (canAddMore) {
      addUnitToDraft(employeeKey)
    }
  }
  
  const handleRemoveUnit = (index: number) => {
    removeUnitFromDraft(index)
  }
  
  const handleConfirmDraft = () => {
    if (draftState.selectedUnits.length >= 3) {
      confirmDraft()
    }
  }
  
  const canStartBattle = draftState.selectedUnits.length >= 3
  
  return (
    <div className="min-h-screen bg-slate-900 text-slate-100 p-4 sm:p-6 lg:p-8">
      <div className="max-w-7xl mx-auto">
        <header className="text-center mb-6 sm:mb-8">
          <h1 className="text-2xl sm:text-3xl lg:text-4xl font-bold text-blue-400 mb-2">Team Drafting</h1>
          <p className="text-slate-300 text-sm sm:text-base">Build your dream team for the ultimate HR battle!</p>
        </header>
        
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 sm:gap-6 lg:gap-8">
          {/* Left: Available Units */}
          <div className="lg:col-span-2">
            <div className="bg-slate-800 rounded-lg border border-slate-700 p-4 sm:p-6">
              <h2 className="text-xl sm:text-2xl font-semibold mb-4 text-green-400">Available Units</h2>
              <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3 sm:gap-4">
                {dataManager.getAllEmployees().map((employee) => {
                  const canAfford = employee.cost <= remainingBudget
                  const canAdd = canAddMore && canAfford
                  
                  return (
                    <div
                      key={employee.key}
                      className={`bg-slate-700 rounded-lg p-3 sm:p-4 border-2 transition-all ${
                        canAdd ? 'border-green-500 hover:border-green-400' : 'border-slate-600 opacity-60'
                      }`}
                    >
                      <div className="text-center">
                        <div className="w-12 h-12 sm:w-16 sm:h-16 mx-auto mb-2 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold text-sm sm:text-lg">
                          {employee.name.charAt(0).toUpperCase()}
                        </div>
                        <h3 className="font-semibold text-xs sm:text-sm mb-1">
                          {employee.name}
                        </h3>
                        <p className="text-green-400 font-mono text-xs sm:text-sm mb-2">${employee.cost}k</p>
                        
                        <div className="text-xs text-slate-300 space-y-1 mb-3">
                          <div>HP: {employee.stats.health}</div>
                          <div>Move: {employee.stats.speed}</div>
                          <div>Attack: {employee.attack.range}/{employee.stats.attack_power}</div>
                        </div>
                        
                        <button
                          onClick={() => handleAddUnit(employee.key)}
                          disabled={!canAdd}
                          className={`w-full py-2 px-2 sm:px-3 rounded text-xs sm:text-sm font-medium transition-colors min-h-[44px] ${
                            canAdd
                              ? 'bg-green-600 hover:bg-green-500 text-white'
                              : 'bg-slate-600 text-slate-400 cursor-not-allowed'
                          }`}
                        >
                          {canAdd ? 'Add Unit' : 'Cannot Add'}
                        </button>
                      </div>
                    </div>
                  )
                })}
              </div>
            </div>
          </div>
          
          {/* Right: Team Roster & Controls */}
          <div className="space-y-4 sm:space-y-6">
            {/* Budget & Headcount */}
            <div className="bg-slate-800 rounded-lg border border-slate-700 p-4 sm:p-6">
              <h2 className="text-lg sm:text-xl font-semibold mb-4 text-blue-400">Team Status</h2>
              <div className="space-y-3">
                <div className="flex justify-between">
                  <span>Budget:</span>
                  <span className={`font-mono ${remainingBudget >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                    ${remainingBudget}k
                  </span>
                </div>
                <div className="flex justify-between">
                  <span>Headcount:</span>
                  <span className="font-mono">
                    {draftState.selectedUnits.length}/{draftState.maxHeadcount}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span>Total Cost:</span>
                  <span className="font-mono text-green-400">${totalCost}k</span>
                </div>
              </div>
            </div>
            
            {/* Selected Units */}
            <div className="bg-slate-800 rounded-lg border border-slate-700 p-4 sm:p-6">
              <h2 className="text-lg sm:text-xl font-semibold mb-4 text-purple-400">Your Team</h2>
              {draftState.selectedUnits.length === 0 ? (
                <p className="text-slate-400 text-center py-8">No units selected yet</p>
              ) : (
                <div className="space-y-3">
                  {draftState.selectedUnits.map((unit, index) => {
                    const employee = dataManager.getEmployee(unit.employeeKey)
                    if (!employee) return null
                    
                    return (
                      <div key={index} className="flex items-center justify-between bg-slate-700 rounded p-3">
                        <div className="flex items-center space-x-3">
                          <div className="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center text-white text-xs font-bold">
                            {employee.name.charAt(0).toUpperCase()}
                          </div>
                          <div>
                            <div className="font-medium text-sm">
                              {employee.name}
                            </div>
                            <div className="text-xs text-slate-400">
                              ${employee.cost}k
                            </div>
                          </div>
                        </div>
                        <button
                          onClick={() => handleRemoveUnit(index)}
                          className="text-red-400 hover:text-red-300 text-sm font-medium"
                        >
                          Remove
                        </button>
                      </div>
                    )
                  })}
                </div>
              )}
            </div>
            
            {/* AI Team Preview */}
            <div className="bg-slate-800 rounded-lg border border-slate-700 p-4 sm:p-6">
              <h2 className="text-lg sm:text-xl font-semibold mb-4 text-red-400">AI Team</h2>
              <div className="space-y-2">
                {draftState.aiUnits.map((unit, index) => {
                  const employee = dataManager.getEmployee(unit.employeeKey)
                  if (!employee) return null
                  
                  return (
                    <div key={index} className="flex items-center space-x-3 bg-slate-700 rounded p-2">
                      <div className="w-6 h-6 bg-red-500 rounded-full flex items-center justify-center text-white text-xs font-bold">
                        {employee.name.charAt(0).toUpperCase()}
                      </div>
                      <div className="text-sm">
                        {employee.name}
                      </div>
                    </div>
                  )
                })}
              </div>
            </div>
            
            {/* Start Battle Button */}
            <button
              onClick={handleConfirmDraft}
              disabled={!canStartBattle}
              className={`w-full py-3 sm:py-4 px-4 sm:px-6 rounded-lg text-base sm:text-lg font-bold transition-all min-h-[56px] ${
                canStartBattle
                  ? 'bg-blue-600 hover:bg-blue-500 text-white shadow-lg hover:shadow-xl'
                  : 'bg-slate-600 text-slate-400 cursor-not-allowed'
              }`}
            >
              {canStartBattle ? 'Start Battle!' : 'Need at least 3 units'}
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

===== ./src/components/PauseMenu.tsx =====
import { useState } from 'react'

interface PauseMenuProps {
  isPaused: boolean
  onResume: () => void
  onQuit: () => void
}

export function PauseMenu({ isPaused, onResume, onQuit }: PauseMenuProps) {
  const [showInstructions, setShowInstructions] = useState(false)

  if (!isPaused) return null

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
      <div className="bg-slate-900 border border-slate-700 rounded-lg p-6 max-w-2xl mx-4">
        <h2 className="text-3xl font-bold text-white mb-6 text-center">
          âM-^O¸ï¸M-^O Game Paused
        </h2>
        
        <div className="flex flex-col gap-4">
          <button
            onClick={onResume}
            className="bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors"
          >
            âM-^V¶ï¸M-^O Resume Game
          </button>
          
          <button
            onClick={() => setShowInstructions(!showInstructions)}
            className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors"
          >
            ðM-^_M-^SM-^V {showInstructions ? 'Hide' : 'Show'} Instructions
          </button>
          
          <button
            onClick={onQuit}
            className="bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors"
          >
            ðM-^_M-^Zª Quit to Menu
          </button>
        </div>

        {showInstructions && (
          <div className="mt-6 p-4 bg-slate-800 rounded-lg border border-slate-600">
            <h3 className="text-xl font-semibold text-white mb-4">ðM-^_M-^N® How to Play HRmageddon</h3>
            
            <div className="space-y-4 text-slate-300">
              <div>
                <h4 className="font-semibold text-white">ðM-^_M-^N¯ Objective</h4>
                <p>Capture cubicles and eliminate enemy units to control the office floor!</p>
              </div>
              
              <div>
                <h4 className="font-semibold text-white">ðM-^_M-^N² Turn System</h4>
                <p>Each turn you have action points to move units and attack enemies. Units can move and attack once per turn.</p>
              </div>
              
              <div>
                <h4 className="font-semibold text-white">ðM-^_M-^Q¥ Your Units</h4>
                <ul className="list-disc list-inside space-y-1 ml-4">
                  <li><span className="text-blue-400">ðM-^_M-^Tµ Blue Units</span> - These are YOUR units</li>
                  <li><span className="text-red-400">ðM-^_M-^T´ Red Units</span> - These are ENEMY units</li>
                </ul>
              </div>
              
              <div>
                <h4 className="font-semibold text-white">ðM-^_M-^N® Controls</h4>
                <ul className="list-disc list-inside space-y-1 ml-4">
                  <li><strong>Click a unit</strong> to select it (highlighted in yellow)</li>
                  <li><strong>Click a tile</strong> to move the selected unit there</li>
                  <li><strong>Click an enemy</strong> to attack (if in range)</li>
                  <li><strong>Press ESC</strong> to pause/unpause</li>
                  <li><strong>Press SPACE</strong> to end your turn</li>
                </ul>
              </div>
              
              <div>
                <h4 className="font-semibold text-white">ðM-^_M-^R° Resources</h4>
                <p>Capture cubicles (gray tiles) to earn income each turn. Use this to buy new units!</p>
              </div>
              
              <div>
                <h4 className="font-semibold text-white">ðM-^_M-^OM-^F Victory</h4>
                <p>Win by eliminating all enemy units or capturing their headquarters (HQ tile).</p>
              </div>
              
              <div>
                <h4 className="font-semibold text-white">ðM-^_M-^R¡ Tips</h4>
                <ul className="list-disc list-inside space-y-1 ml-4">
                  <li>Use cover and obstacles to your advantage</li>
                  <li>Capture cubicles early to build income</li>
                  <li>Focus fire on weak enemy units</li>
                  <li>Don't forget to end your turn when done!</li>
                </ul>
              </div>
            </div>
          </div>
        )}
        
        <div className="mt-4 text-center text-slate-400 text-sm">
          Press <kbd className="bg-slate-700 px-2 py-1 rounded">ESC</kbd> to resume
        </div>
      </div>
    </div>
  )
}

===== ./src/components/test/TileSizeTestGame.tsx =====
import { useEffect, useRef, useState } from 'react'
import Phaser from 'phaser'
import { MAPS } from '../../game/map/registry'

interface TileSizeTestGameProps {
  tileSize: 48 | 32 | 24
  showTileGraphics: boolean
}

// Create a simplified test scene that only handles the specified tile size
class TileSizeTestScene extends Phaser.Scene {
  private tileSizePx: number
  private showTileGraphics: boolean
  private tileGraphics: Phaser.GameObjects.Graphics | null = null
  private unitGraphics: Phaser.GameObjects.Graphics | null = null
  private tilemap: Phaser.Tilemaps.Tilemap | null = null
  private tileset: Phaser.Tilemaps.Tileset | null = null

  constructor(tileSize: number, showTileGraphics: boolean = false) {
    super({ key: 'TileSizeTestScene' })
    this.tileSizePx = tileSize
    this.showTileGraphics = showTileGraphics
  }

  create() {
    console.log(`TileSizeTestScene: Creating test scene with ${this.tileSizePx}px tiles`)
    
    // Calculate board dimensions
    const boardWidth = 16
    const boardHeight = 12
    const canvasWidth = boardWidth * this.tileSizePx
    const canvasHeight = boardHeight * this.tileSizePx
    
    console.log(`TileSizeTestScene: Board dimensions: ${canvasWidth}x${canvasHeight}`)
    
    // Create graphics for tiles
    this.tileGraphics = this.add.graphics()
    this.unitGraphics = this.add.graphics()
    
    // Draw the board grid (only if tile graphics are disabled)
    if (!this.showTileGraphics) {
      this.drawBoard()
    } else {
      // Draw actual tile graphics
      this.drawTileGraphics()
    }
    
    // Draw some test units
    this.drawTestUnits()
    
    // Add some debug text
    this.add.text(10, 10, `Test Scene: ${this.tileSizePx}px tiles`, {
      fontSize: '16px',
      color: '#ffffff',
      backgroundColor: '#000000',
      padding: { x: 8, y: 4 }
    })
  }

  private drawBoard() {
    if (!this.tileGraphics) return
    
    this.tileGraphics.clear()
    this.tileGraphics.lineStyle(1, 0x666666, 0.5)
    
    const boardWidth = 16
    const boardHeight = 12
    
    // Draw grid lines
    for (let x = 0; x <= boardWidth; x++) {
      const xPos = x * this.tileSizePx
      this.tileGraphics.moveTo(xPos, 0)
      this.tileGraphics.lineTo(xPos, boardHeight * this.tileSizePx)
    }
    
    for (let y = 0; y <= boardHeight; y++) {
      const yPos = y * this.tileSizePx
      this.tileGraphics.moveTo(0, yPos)
      this.tileGraphics.lineTo(boardWidth * this.tileSizePx, yPos)
    }
    
    this.tileGraphics.strokePath()
    
    // Draw some sample tiles
    this.tileGraphics.fillStyle(0x1e40af, 0.3) // Blue for player 1 area
    this.tileGraphics.fillRect(0, 0, 6 * this.tileSizePx, 3 * this.tileSizePx)
    
    this.tileGraphics.fillStyle(0x1e3a8a, 0.3) // Darker blue for player 2 area
    this.tileGraphics.fillRect(10 * this.tileSizePx, 9 * this.tileSizePx, 6 * this.tileSizePx, 3 * this.tileSizePx)
    
    // Draw capture points
    this.tileGraphics.fillStyle(0xfbbf24, 0.6) // Yellow for capture points
    const capturePoints = [
      { x: 10, y: 1 }, { x: 6, y: 4 }, { x: 12, y: 5 },
      { x: 4, y: 6 }, { x: 1, y: 7 }, { x: 9, y: 7 },
      { x: 14, y: 7 }, { x: 5, y: 10 }
    ]
    
    capturePoints.forEach(point => {
      const x = point.x * this.tileSizePx + this.tileSizePx / 2
      const y = point.y * this.tileSizePx + this.tileSizePx / 2
      const radius = Math.max(8, this.tileSizePx * 0.3)
      this.tileGraphics?.fillCircle(x, y, radius)
    })
  }

  private drawTileGraphics() {
    if (!this.showTileGraphics) return
    
    try {
      // Clear any existing fallback graphics first
      if (this.tileGraphics) {
        this.tileGraphics.clear()
      }
      
      // Load the tilemap if not already loaded
      if (!this.tilemap) {
        this.loadTilemap()
        return
      }
      
      // Create layers with proper scaling
      this.createTilemapLayers()
      
      console.log('TileSizeTestScene: Tilemap layers created successfully')
      
    } catch (error) {
      console.warn('TileSizeTestScene: Could not load tilemap:', error)
      // Fallback to simple graphics if tilemap fails
      this.drawFallbackGraphics()
    }
  }

  preload() {
    // Load assets in preload phase (like the real game does)
    console.log(`TileSizeTestScene: Preloading assets for ${this.tileSizePx}px tiles`)
    
    // Load tilemap JSON
    this.load.tilemapTiledJSON('OfficeLayout16x12', '/assets/tilemaps/OfficeLayout16x12.json')
    
    // Load tileset image (correct path from tilesets folder)
    this.load.image('inside', '/assets/tilesets/inside.png')
    
    console.log('TileSizeTestScene: Assets preloaded successfully')
  }

  private loadTilemap() {
    try {
      console.log(`TileSizeTestScene: Creating tilemap with ${this.tileSizePx}px tiles`)
      
      // Create tilemap from preloaded JSON
      this.tilemap = this.make.tilemap({ key: 'OfficeLayout16x12' })
      
      console.log('TileSizeTestScene: Tilemap created:', this.tilemap)
      
      // Create tileset from preloaded image
      this.tileset = this.tilemap.addTilesetImage('OfficeLayout', 'inside', 16, 16, 0, 0)
      
      console.log('TileSizeTestScene: Tileset created:', this.tileset)
      
      if (!this.tileset) {
        throw new Error('Failed to create tileset')
      }
      
      console.log(`TileSizeTestScene: Tilemap loaded successfully with ${this.tileSizePx}px tiles`)
      
    } catch (error) {
      console.error('TileSizeTestScene: Error loading tilemap:', error)
      throw error
    }
  }

  private createTilemapLayers() {
    if (!this.tilemap || !this.tileset) {
      console.warn('TileSizeTestScene: Cannot create layers - tilemap or tileset missing')
      return
    }
    
    try {
      // Create background layer (floor tiles)
      const backgroundLayer = this.tilemap.createLayer('Background', this.tileset, 0, 0)
      if (backgroundLayer) {
        backgroundLayer.setScale(this.tileSizePx / 16) // Scale from 16px to target size
        backgroundLayer.setDepth(10) // Above fallback graphics
      }
      
      // Create foreground layer (walls, obstacles)
      const foregroundLayer = this.tilemap.createLayer('Foreground', this.tileset, 0, 0)
      if (foregroundLayer) {
        foregroundLayer.setScale(this.tileSizePx / 16)
        foregroundLayer.setDepth(110) // Above background
      }
      
      // Create capture points layer
      const captureLayer = this.tilemap.createLayer('CapturePoints', this.tileset, 0, 0)
      if (captureLayer) {
        captureLayer.setScale(this.tileSizePx / 16)
        captureLayer.setDepth(210) // Above foreground
      }
      
      // Create starting positions layer
      const startingLayer = this.tilemap.createLayer('StartingPositions', this.tileset, 0, 0)
      if (startingLayer) {
        startingLayer.setScale(this.tileSizePx / 16)
        startingLayer.setDepth(160) // Above background, below foreground
      }
      
      console.log(`TileSizeTestScene: All tilemap layers created with ${this.tileSizePx}px scaling`)
      
    } catch (error) {
      console.error('TileSizeTestScene: Error creating layers:', error)
      throw error
    }
  }

  private drawFallbackGraphics() {
    // Fallback to simple colored rectangles if tilemap fails
    if (!this.tileGraphics) {
      this.tileGraphics = this.add.graphics()
    }
    
    this.tileGraphics.clear()
    this.tileGraphics.setDepth(1) // Below tilemap layers
    
    const boardWidth = 16
    const boardHeight = 12
    
    // Draw basic grid with fallback colors
    this.tileGraphics.lineStyle(1, 0x666666, 0.5)
    for (let x = 0; x <= boardWidth; x++) {
      const xPos = x * this.tileSizePx
      this.tileGraphics.moveTo(xPos, 0)
      this.tileGraphics.lineTo(xPos, boardHeight * this.tileSizePx)
    }
    for (let y = 0; y <= boardHeight; y++) {
      const yPos = y * this.tileSizePx
      this.tileGraphics.moveTo(0, yPos)
      this.tileGraphics.lineTo(boardWidth * this.tileSizePx, yPos)
    }
    this.tileGraphics.strokePath()
    
    console.log('TileSizeTestScene: Using fallback graphics')
  }

  private drawTestUnits() {
    if (!this.unitGraphics) return
    
    this.unitGraphics.clear()
    
    // Player 1 units (top-left area)
    const player1Units = [
      { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 3, y: 1 },
      { x: 4, y: 1 }, { x: 5, y: 1 }, { x: 2, y: 2 },
      { x: 3, y: 2 }, { x: 4, y: 2 }
    ]
    
    player1Units.forEach((unit, index) => {
      const x = unit.x * this.tileSizePx + this.tileSizePx / 2
      const y = unit.y * this.tileSizePx + this.tileSizePx / 2
      const radius = Math.max(12, this.tileSizePx * 0.4)
      
      // Unit circle
      this.unitGraphics?.fillStyle(0xfbbf24, 1) // Gold
      this.unitGraphics?.fillCircle(x, y, radius)
      
      // Unit number
      this.add.text(x - 4, y - 8, `${index + 1}`, {
        fontSize: `${Math.max(10, this.tileSizePx * 0.25)}px`,
        color: '#000000',
        fontStyle: 'bold'
      }).setOrigin(0.5)
    })
    
    // Player 2 units (bottom-right area)
    const player2Units = [
      { x: 11, y: 9 }, { x: 12, y: 9 }, { x: 13, y: 9 },
      { x: 10, y: 10 }, { x: 11, y: 10 }, { x: 12, y: 10 },
      { x: 13, y: 10 }, { x: 14, y: 10 }
    ]
    
    player2Units.forEach((unit, index) => {
      const x = unit.x * this.tileSizePx + this.tileSizePx / 2
      const y = unit.y * this.tileSizePx + this.tileSizePx / 2
      const radius = Math.max(12, this.tileSizePx * 0.4)
      
      // Unit circle
      this.unitGraphics?.fillStyle(0x1e3a8a, 1) // Navy
      this.unitGraphics?.fillCircle(x, y, radius)
      
      // Unit number
      this.add.text(x - 4, y - 8, `${index + 1}`, {
        fontSize: `${Math.max(10, this.tileSizePx * 0.25)}px`,
        color: '#ffffff',
        fontStyle: 'bold'
      }).setOrigin(0.5)
    })
  }
}

export function TileSizeTestGame({ tileSize, showTileGraphics }: TileSizeTestGameProps) {
  const gameRef = useRef<Phaser.Game | null>(null)
  const containerRef = useRef<HTMLDivElement | null>(null)
  const [gameInfo, setGameInfo] = useState({
    tileSize,
    boardWidth: 16 * tileSize,
    boardHeight: 12 * tileSize,
    status: 'Initializing...'
  })

  useEffect(() => {
    if (!containerRef.current || gameRef.current) return

    console.log(`TileSizeTestGame: Creating test game with ${tileSize}px tiles`)
    
    const boardWidth = 16 * tileSize
    const boardHeight = 12 * tileSize
    
    setGameInfo({
      tileSize,
      boardWidth,
      boardHeight,
      status: 'Creating game...'
    })

    const game = new Phaser.Game({
      type: Phaser.AUTO,
      parent: containerRef.current,
      backgroundColor: '#0f172a',
      scale: {
        mode: Phaser.Scale.NONE,
        autoCenter: Phaser.Scale.NO_CENTER,
        width: boardWidth,
        height: boardHeight,
        min: { width: 400, height: 300 },
        max: { width: MAPS['OfficeLayout'].width * 64, height: MAPS['OfficeLayout'].height * 64 }
      },
      scene: [new TileSizeTestScene(tileSize, showTileGraphics)],
      physics: { default: 'arcade' }
    })

    gameRef.current = game

    // Listen for scene creation
    game.events.once('scene-start', () => {
      setGameInfo(prev => ({ ...prev, status: 'Game ready!' }))
      console.log(`TileSizeTestGame: Test game ready with ${tileSize}px tiles`)
    })

    return () => {
      if (gameRef.current) {
        gameRef.current.destroy(true)
        gameRef.current = null
      }
    }
  }, [tileSize, showTileGraphics])

  return (
    <div className="bg-slate-800 rounded-lg p-6">
      <div className="mb-4">
        <h3 className="text-lg font-semibold mb-2">Test Game Board</h3>
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
          <div>
            <span className="text-slate-400">Tile Size:</span>
            <span className="ml-2 font-mono">{gameInfo.tileSize}px</span>
          </div>
          <div>
            <span className="text-slate-400">Width:</span>
            <span className="ml-2 font-mono">{gameInfo.boardWidth}px</span>
          </div>
          <div>
            <span className="text-slate-400">Height:</span>
            <span className="ml-2 font-mono">{gameInfo.boardHeight}px</span>
          </div>
          <div>
            <span className="text-slate-400">Status:</span>
            <span className="ml-2 text-green-400">{gameInfo.status}</span>
          </div>
        </div>
      </div>
      
      <div className="flex justify-center">
        <div 
          ref={containerRef}
          className="border-2 border-slate-600 rounded-lg"
          style={{
            width: gameInfo.boardWidth,
            height: gameInfo.boardHeight,
            maxWidth: '100%'
          }}
        />
      </div>
      
      <div className="mt-4 text-center text-sm text-slate-400">
        <p>This test board uses fixed {tileSize}px tiles to compare with the responsive system</p>
        <p>Check console for detailed logging and compare behavior with main game</p>
      </div>
    </div>
  )
}

===== ./src/components/test/TileSizeTestPage.tsx =====
import { useState } from 'react'
import { TileSizeTestGame } from './TileSizeTestGame'
import { useGameStore } from '../../stores/gameStore'
import { MAPS } from '../../game/map/registry'

export function TileSizeTestPage() {
  const [selectedTileSize, setSelectedTileSize] = useState<48 | 32 | 24>(48)
  const [showTileGraphics, setShowTileGraphics] = useState(false)
  // Actions don't need selectors as they don't cause re-renders
  const returnToMenu = useGameStore(state => state.returnToMenu)

  return (
    <div className="min-h-screen bg-slate-900 text-white p-4">
      <div className="max-w-7xl mx-auto">
        <div className="flex justify-between items-center mb-8">
          <button
            onClick={returnToMenu}
            className="px-4 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg transition-colors"
          >
            âM-^FM-^P Back to Menu
          </button>
          <h1 className="text-3xl font-bold">
            ðM-^_§ª Tile Size Test Page
          </h1>
          <div className="w-24"></div> {/* Spacer for centering */}
        </div>
        
        {/* Game Board and Controls - Moved up for easier screenshot sharing */}
        <div className="mb-6">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-xl font-semibold text-slate-200">Test Game Board</h2>
            <label className="flex items-center space-x-3 cursor-pointer">
              <input
                type="checkbox"
                checked={showTileGraphics}
                onChange={(e) => setShowTileGraphics(e.target.checked)}
                className="w-5 h-5 text-blue-600 bg-slate-700 border-slate-600 rounded focus:ring-blue-500 focus:ring-2"
              />
              <span className="text-slate-300 font-medium">
                Show Tile Graphics (Office Layout)
              </span>
            </label>
          </div>
          <TileSizeTestGame tileSize={selectedTileSize} showTileGraphics={showTileGraphics} />
        </div>
        
        <div className="text-center mb-6">
          <p className="text-lg text-slate-300 mb-4">
            Testing different tile sizes to debug responsive system
          </p>
          <div className="flex justify-center gap-4">
            <button
              onClick={() => setSelectedTileSize(48)}
              className={`px-6 py-3 rounded-lg font-semibold transition-colors ${
                selectedTileSize === 48
                  ? 'bg-blue-600 text-white'
                  : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
            >
              48px Tiles
            </button>
            <button
              onClick={() => setSelectedTileSize(32)}
              className={`px-6 py-3 rounded-lg font-semibold transition-colors ${
                selectedTileSize === 32
                  ? 'bg-green-600 text-white'
                      : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
            >
              32px Tiles
            </button>
            <button
              onClick={() => setSelectedTileSize(24)}
              className={`px-6 py-3 rounded-lg font-semibold transition-colors ${
                selectedTileSize === 24
                  ? 'bg-purple-600 text-white'
                  : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
            >
              24px Tiles
            </button>
          </div>
          

        </div>

        <div className="bg-slate-800 rounded-lg p-6">
          <h2 className="text-xl font-semibold mb-4 text-center">
            Current Test: {selectedTileSize}px Tiles
          </h2>
          
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div className="bg-slate-700 rounded-lg p-4">
              <h3 className="font-semibold mb-2">Board Info</h3>
              <p>Size: {MAPS['OfficeLayout'].width}ÃM-^W{MAPS['OfficeLayout'].height} tiles</p>
              <p>Tile Size: {selectedTileSize}px</p>
              <p>Canvas: {MAPS['OfficeLayout'].width * selectedTileSize}ÃM-^W{MAPS['OfficeLayout'].height * selectedTileSize}px</p>
            </div>
            
            <div className="bg-slate-700 rounded-lg p-4">
              <h3 className="font-semibold mb-2">Expected Behavior</h3>
              <p>âM-^@¢ Full board visible</p>
              <p>âM-^@¢ Units properly sized</p>
              <p>âM-^@¢ No clipping or overflow</p>
            </div>
            
            <div className="bg-slate-700 rounded-lg p-4">
              <h3 className="font-semibold mb-2">Debug Info</h3>
              <p>âM-^@¢ Check console logs</p>
              <p>âM-^@¢ Verify tile rendering</p>
              <p>âM-^@¢ Compare with responsive</p>
              <p>âM-^@¢ Toggle tile graphics</p>
            </div>
          </div>
        </div>


        
        {/* Tile Graphics Legend */}
        {showTileGraphics && (
          <div className="mt-6 p-4 bg-slate-800 rounded-lg border border-slate-700">
            <h4 className="font-semibold text-slate-200 mb-3 text-center">Tile Graphics Legend</h4>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
              <div className="flex items-center space-x-2">
                <div className="w-4 h-4 bg-blue-300 rounded opacity-30"></div>
                <span className="text-slate-300">Cubicles</span>
              </div>
              <div className="flex items-center space-x-2">
                <div className="w-4 h-4 bg-gray-600 rounded opacity-60"></div>
                <span className="text-slate-300">Obstacles</span>
              </div>
              <div className="flex items-center space-x-2">
                <div className="w-4 h-4 bg-purple-600 rounded opacity-40"></div>
                <span className="text-slate-300">Conference Rooms</span>
              </div>
              <div className="flex items-center space-x-2">
                <div className="w-4 h-4 bg-gray-300 rounded opacity-20"></div>
                <span className="text-slate-300">Hallways</span>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}

===== ./src/components/MobileGameHUD.tsx =====
import { useEffect, useState } from 'react'
import { useGameStore } from '../stores/gameStore'
import { useUnitStore } from '../stores/unitStore'
import { usePlayerStore } from '../stores/playerStore'
import { BottomSheet } from './BottomSheet'

export function MobileGameHUD() {
  // Use selectors to prevent unnecessary re-renders
  const players = usePlayerStore(state => state.players)
  const selectedUnit = useUnitStore(state => state.selectedUnit)
  const currentPlayerId = usePlayerStore(state => state.currentPlayerId)
  const turnNumber = usePlayerStore(state => state.turnNumber)
  
  // Actions don't need selectors as they don't cause re-renders
  const endTurn = useGameStore(state => state.endTurn)

  const [isBottomSheetOpen, setIsBottomSheetOpen] = useState(false)
  const [activeSection, setActiveSection] = useState<'game-status' | 'unit-info' | 'help'>('game-status')
  
  const isPlayerTurn = currentPlayerId === 'player1'
  const player1 = players.find((p) => p.id === 'player1')
  const player2 = players.find((p) => p.id === 'player2')

  // Open bottom sheet when unit is selected
  useEffect(() => {
    if (selectedUnit) {
      setIsBottomSheetOpen(true)
      setActiveSection('unit-info')
    } else {
      setIsBottomSheetOpen(false)
    }
  }, [selectedUnit])

  return (
    <>
      {/* Mobile Game Status Bar - Always Visible */}
      <div className="fixed top-16 left-0 right-0 bg-slate-800 border-b border-slate-700 p-3 z-30 lg:hidden">
        <div className="flex items-center justify-between">
          {/* Turn Info */}
          <div className="flex items-center space-x-3">
            <div className="text-sm font-semibold">Turn {turnNumber}</div>
            <div className={`px-2 py-1 rounded text-xs font-medium ${
              isPlayerTurn ? 'bg-amber-600 text-white' : 'bg-stone-600 text-white'
            }`}>
              {isPlayerTurn ? 'Your Turn' : 'AI Turn'}
            </div>
          </div>
          
          {/* Cubicle Count */}
          <div className="flex items-center space-x-2 text-xs">
            <span className="text-amber-400">Gold: {player1?.controlledCubicles || 0}</span>
            <span className="text-blue-400">Navy: {player2?.controlledCubicles || 0}</span>
          </div>
          
          {/* End Turn Button */}
          {isPlayerTurn && (
            <button
              onClick={endTurn}
              className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs font-medium rounded transition-colors"
            >
              End Turn
            </button>
          )}
        </div>
      </div>

      {/* Bottom Sheet for Game Info */}
      <BottomSheet
        isOpen={isBottomSheetOpen}
        onClose={() => setIsBottomSheetOpen(false)}
        title="Game Information"
        snapPoints={[200, 400, 600]}
        initialSnapPoint={1}
      >
        {/* Section Navigation */}
        <div className="flex space-x-2 mb-4">
          <button
            onClick={() => setActiveSection('game-status')}
            className={`px-3 py-2 rounded text-sm font-medium transition-colors ${
              activeSection === 'game-status' 
                ? 'bg-blue-600 text-white' 
                : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
            }`}
          >
            Status
          </button>
          <button
            onClick={() => setActiveSection('unit-info')}
            className={`px-3 py-2 rounded text-sm font-medium transition-colors ${
              activeSection === 'unit-info' 
                ? 'bg-blue-600 text-white' 
                : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
            }`}
          >
            Unit
          </button>
          <button
            onClick={() => setActiveSection('help')}
            className={`px-3 py-2 rounded text-sm font-medium transition-colors ${
              activeSection === 'help' 
                ? 'bg-blue-600 text-white' 
                : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
            }`}
          >
            Help
          </button>
        </div>

        {/* Game Status Section */}
        {activeSection === 'game-status' && (
          <div className="space-y-4">
            <div className="text-center">
              <div className="text-xl font-bold mb-2">Turn {turnNumber}</div>
              <div className={`px-4 py-2 rounded-lg text-white font-semibold ${isPlayerTurn ? 'bg-amber-600' : 'bg-stone-600'}`}>
                {isPlayerTurn ? 'Your Turn' : 'AI Turn'}
              </div>
            </div>

            {/* Player Resources */}
            <div className="space-y-3">
              <h3 className="text-md font-semibold text-center">Resources</h3>
              
              {/* Player 1 (Gold) */}
              <div className="bg-amber-900/20 border border-amber-700 rounded-lg p-3">
                <div className="text-amber-400 font-semibold text-sm">Gold Team (You)</div>
                <div className="text-xs space-y-1 mt-2 text-amber-300">
                  <div>Budget: ${player1?.budget || 0}</div>
                  <div>Income: +${player1?.income || 0}/turn</div>
                  <div>Cubicles: {player1?.controlledCubicles || 0}</div>
                </div>
              </div>

              {/* Player 2 (Navy) */}
              <div className="bg-blue-900/20 border border-blue-700 rounded-lg p-3">
                <div className="text-blue-400 font-semibold text-sm">Navy Team (AI)</div>
                <div className="text-xs space-y-1 mt-2 text-blue-300">
                  <div>Budget: ${player2?.budget || 0}</div>
                  <div>Income: +${player2?.income || 0}/turn</div>
                  <div>Cubicles: {player2?.controlledCubicles || 0}</div>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Unit Info Section */}
        {activeSection === 'unit-info' && selectedUnit && (
          <div className="space-y-4">
            {/* Unit Info Header */}
            <div className="border-b border-slate-600 pb-3">
              <div className="flex items-center justify-between">
                <h3 className="text-lg font-bold text-amber-400 capitalize">
                  {selectedUnit.type.replace('_', ' ')}
                </h3>
                <div className="flex items-center space-x-2">
                  <div className={`w-3 h-3 rounded-full ${selectedUnit.playerId === 'player1' ? 'bg-amber-500' : 'bg-stone-500'}`} />
                  <span className="text-xs text-slate-400">
                    {selectedUnit.playerId === 'player1' ? 'Player' : 'Enemy'}
                  </span>
                </div>
              </div>
              
              {selectedUnit.actionsRemaining > 0 && (
                <div className="text-xs text-green-400 mt-1">
                  Controlling - {selectedUnit.actionsRemaining} action{selectedUnit.actionsRemaining !== 1 ? 's' : ''} remaining
                </div>
              )}
            </div>

            {/* Unit Stats */}
            <div className="space-y-2 text-sm">
              <div className="flex justify-between">
                <span className="text-slate-400">HP:</span>
                <span className="text-white">{selectedUnit.hp}/{selectedUnit.maxHp}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-slate-400">Actions:</span>
                <span className="text-white">{selectedUnit.actionsRemaining}/{selectedUnit.maxActions}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-slate-400">Move Range:</span>
                <span className="text-white">{selectedUnit.moveRange}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-slate-400">Attack Range:</span>
                <span className="text-white">{selectedUnit.attackRange}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-slate-400">Attack Damage:</span>
                <span className="text-white">{selectedUnit.attackDamage}</span>
              </div>
            </div>
          </div>
        )}

        {/* Help Section */}
        {activeSection === 'help' && (
          <div className="space-y-3 text-sm">
            <h3 className="text-lg font-bold text-center">How to Play</h3>
            <div className="space-y-2 text-slate-300">
              <div>âM-^@¢ Click any unit to view their stats</div>
              <div>âM-^@¢ Click player units (gold) to control them</div>
              <div>âM-^@¢ Click highlighted tiles to move/attack</div>
              <div>âM-^@¢ Select abilities to use them on targets</div>
              <div>âM-^@¢ Capture cubicles to increase income</div>
              <div>âM-^@¢ End turn when you're done</div>
            </div>
          </div>
        )}
      </BottomSheet>
    </>
  )
}

===== ./src/components/layout/Hero.tsx =====
import React from "react";

type Props = {
  /** e.g., "/img/home-hero-01.jpg" âM-^@M-^T from public/ */
  bgSrc?: string;
  className?: string;
  children?: React.ReactNode;
  /** optional overlay opacity (0âM-^@M-^S100) */
  overlay?: number;
  /** content positioning: 'start', 'center', 'end' */
  contentPosition?: 'start' | 'center' | 'end';
};

export default function Hero({ 
  bgSrc = "/img/home-hero-01.jpg", 
  className = "", 
  children, 
  overlay = 30,
  contentPosition = 'center'
}: Props) {
  const positionClasses = {
    start: 'justify-start',
    center: 'justify-center',
    end: 'justify-end'
  };

  return (
    <section className={`relative w-full min-h-[70vh] lg:min-h-[80vh] overflow-hidden ${className}`}>
      {/* Background image */}
      <div
        className="absolute inset-0 bg-center bg-cover"
        style={{ backgroundImage: `url(${bgSrc})` }}
        aria-hidden="true"
      />
      {/* Subtle vignette + brand tint */}
      <div
        className="absolute inset-0"
        style={{
          background:
            "radial-gradient(80% 60% at 50% 40%, rgba(0,0,0,0) 0%, rgba(0,0,0,0.45) 100%)"
        }}
        aria-hidden="true"
      />
      {/* Color wash */}
      <div
        className="absolute inset-0"
        style={{ backgroundColor: `rgba(20,40,80,${overlay/100})` }}
        aria-hidden="true"
      />

      {/* Foreground content */}
      <div className={`relative z-10 mx-auto max-w-6xl px-6 py-16 flex flex-col items-center ${positionClasses[contentPosition]} h-full text-white`}>
        {children}
      </div>
    </section>
  );
}

===== ./src/components/LoadingScreen.tsx =====
import { useState, useEffect } from 'react';
import { initializeMapRegistry } from '../game/map/registry';
import { mapRegistry } from '../game/map/MapRegistry';
import { dataManager } from '../game/data/DataManager';

interface LoadingScreenProps {
  onLoadingComplete: () => void;
  minDisplayTime?: number; // Minimum time to show loading screen (ms)
}

export function LoadingScreen({ onLoadingComplete }: LoadingScreenProps) {
  const [isComplete, setIsComplete] = useState(false);
  const [isFadingOut, setIsFadingOut] = useState(false);

  useEffect(() => {
    const loadAllData = async () => {
      try {
        // Initialize the MapRegistry with all available maps
        initializeMapRegistry();
        
        // CRITICAL: Pre-populate starting positions from tilemap JSON
        // This eliminates the race condition between LoadingScreen and GameScene
        await preloadStartingPositions();
        
        // Use the new, robust data loading method
        await dataManager.ensureLoaded();
        
        console.log('LoadingScreen: All data loaded successfully');
        
        // Mark as complete
        setIsComplete(true);
        setIsFadingOut(true);
        setTimeout(() => {
          onLoadingComplete();
        }, 500); // Small delay for fade out animation
      } catch (error) {
        console.error('LoadingScreen: Failed to load data:', error);
        // Still complete loading even if data fails to load
        setIsComplete(true);
        setIsFadingOut(true);
        setTimeout(() => {
          onLoadingComplete();
        }, 500);
      }
    };

    loadAllData();
  }, [onLoadingComplete]);


  // Function to pre-parse starting positions from tilemap JSON
  const preloadStartingPositions = async () => {
    try {
      // Fetch the tilemap JSON directly
      const response = await fetch('/assets/tilemaps/OfficeLayout16x12.json');
      const tilemapData = await response.json();
      
      // Parse starting positions from the "StartingPoints" layer
      const startingPointsLayer = tilemapData.layers.find((layer: { name: string; data?: number[]; width: number; height: number }) => layer.name === 'StartingPoints');
      
      if (startingPointsLayer && startingPointsLayer.data) {
        const startingPositionsData: { x: number; y: number; gid: number }[] = [];
        
        // Convert 1D array to 2D grid and find non-zero tiles
        for (let y = 0; y < startingPointsLayer.height; y++) {
          for (let x = 0; x < startingPointsLayer.width; x++) {
            const index = y * startingPointsLayer.width + x;
            const gid = startingPointsLayer.data[index];
            
            if (gid > 0) {
              startingPositionsData.push({ x, y, gid });
            }
          }
        }
        
        // Separate by team based on GID
        const goldTeamPositions = startingPositionsData.filter(pos => pos.gid === 595);
        const navyTeamPositions = startingPositionsData.filter(pos => pos.gid === 563);
        
        // Populate MapRegistry immediately
        mapRegistry.setStartingPositions('OfficeLayout', {
          goldTeam: goldTeamPositions,
          navyTeam: navyTeamPositions
        });
        
        console.log('LoadingScreen: Pre-populated starting positions:', {
          goldTeam: goldTeamPositions.length,
          navyTeam: navyTeamPositions.length,
          total: startingPositionsData.length
        });
      }

      // Parse capture points from the "CapturePoints" layer
      const capturePointsLayer = tilemapData.layers.find((layer: { name: string; data?: number[]; width: number; height: number }) => layer.name === 'CapturePoints');
      
      if (capturePointsLayer && capturePointsLayer.data) {
        const capturePointsData: { x: number; y: number; gid: number }[] = [];
        
        // Convert 1D array to 2D grid and find non-zero tiles
        for (let y = 0; y < capturePointsLayer.height; y++) {
          for (let x = 0; x < capturePointsLayer.width; x++) {
            const index = y * capturePointsLayer.width + x;
            const gid = capturePointsLayer.data[index];
            
            if (gid > 0) {
              capturePointsData.push({ x, y, gid });
            }
          }
        }
        
        // Store capture points in MapRegistry for later use
        mapRegistry.setCapturePoints('OfficeLayout', capturePointsData);
        
        console.log('LoadingScreen: Pre-populated capture points:', {
          total: capturePointsData.length,
          positions: capturePointsData
        });
      }

      // Parse blocked tiles from the "Foreground" layer
      const foregroundLayer = tilemapData.layers.find((layer: { name: string; data?: number[]; width: number; height: number }) => layer.name === 'Foreground');
      
      if (foregroundLayer && foregroundLayer.data) {
        const blockedTilesData: { x: number; y: number; gid: number }[] = [];
        
        // Convert 1D array to 2D grid and find non-zero tiles (these are obstacles)
        for (let y = 0; y < foregroundLayer.height; y++) {
          for (let x = 0; x < foregroundLayer.width; x++) {
            const index = y * foregroundLayer.width + x;
            const gid = foregroundLayer.data[index];
            
            if (gid > 0) {
              blockedTilesData.push({ x, y, gid });
            }
          }
        }
        
        // Store blocked tiles in MapRegistry for movement validation
        mapRegistry.setBlockedTiles('OfficeLayout', blockedTilesData);
        
        console.log('LoadingScreen: Pre-populated blocked tiles:', {
          total: blockedTilesData.length,
          positions: blockedTilesData
        });
      }
    } catch (error) {
      console.warn('LoadingScreen: Failed to preload tilemap data:', error);
    }
  };

  return (
    <div className={`fixed inset-0 z-50 bg-slate-900 flex items-center justify-center transition-opacity duration-500 ${isFadingOut ? 'opacity-0' : 'opacity-100'}`}>
      {/* Background with loading image */}
      <div className="relative w-full h-full">
        {/* Background image */}
        <div 
          className="absolute inset-0 bg-center bg-cover opacity-20"
          style={{ backgroundImage: 'url(/img/loading-01.jpg)' }}
        />
        
        {/* Dark overlay */}
        <div className="absolute inset-0 bg-slate-900/80" />
        
        {/* Content */}
        <div className="relative z-10 flex flex-col items-center justify-center h-full">
          {/* ID Badge Container */}
          <div className="mb-6 sm:mb-8 transform scale-50 sm:scale-75 lg:scale-100 animate-slide-in">
            <div className="relative">
              {/* Lanyard */}
              <div className="absolute -top-8 left-1/2 transform -translate-x-1/2">
                <div className="w-1 h-8 bg-blue-800 rounded-full shadow-lg" />
                <div className="w-3 h-3 bg-blue-700 rounded-full -mt-1 ml-[-4px] shadow-lg" />
              </div>
              
              {/* ID Badge */}
              <div className="bg-blue-800 rounded-xl p-1 shadow-2xl">
                <div className="bg-white rounded-lg p-2 sm:p-4 w-48 sm:w-64 h-24 sm:h-32 flex items-center">
                  {/* Profile Placeholder */}
                  <div className="flex-shrink-0 mr-2 sm:mr-4">
                    <div className="w-12 h-12 sm:w-16 sm:h-16 bg-gray-300 rounded-full flex items-center justify-center">
                      <svg className="w-6 h-6 sm:w-8 sm:h-8 text-gray-500" fill="currentColor" viewBox="0 0 20 20">
                        <path fillRule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clipRule="evenodd" />
                      </svg>
                    </div>
                    <div className="mt-1 sm:mt-2 space-y-1">
                      <div className="h-1.5 sm:h-2 bg-gray-300 rounded w-12 sm:w-16"></div>
                      <div className="h-1.5 sm:h-2 bg-gray-300 rounded w-8 sm:w-12"></div>
                    </div>
                  </div>
                  
                  {/* HRMAGEDDON Text */}
                  <div className="flex-1 text-center">
                    <div className="text-lg sm:text-2xl font-bold">
                      <span className="text-orange-500">HR</span>
                      <span className="text-orange-600">MAGEDDON</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          {/* Loading Text */}
          <div className="text-2xl sm:text-3xl font-bold text-white mb-4 sm:mb-6 tracking-wider animate-fade-in px-4">
            LOADING
          </div>

          {/* Loading Bar */}
          <div className="w-64 sm:w-80 bg-slate-700 rounded-full h-2 sm:h-3 mb-6 sm:mb-8 overflow-hidden shadow-lg animate-fade-in mx-4">
            <div 
              className="h-full bg-gradient-to-r from-blue-500 to-blue-400 rounded-full transition-all duration-300 ease-out shadow-lg shimmer-effect"
              style={{ width: isComplete ? '100%' : '0%' }}
            />
          </div>

          {/* Progress Percentage */}
          <div className="text-base sm:text-lg text-slate-300 font-mono animate-fade-in">
            {isComplete ? '100%' : 'Loading...'}
          </div>

          {/* Loading Dots */}
          <div className="flex space-x-2 mt-4 sm:mt-6 animate-fade-in">
            <div className={`w-2 h-2 rounded-full transition-all duration-300 ${isComplete ? 'bg-blue-400 animate-pulse-slow' : 'bg-slate-600'}`} />
            <div className={`w-2 h-2 rounded-full transition-all duration-300 ${isComplete ? 'bg-blue-400 animate-pulse-slow' : 'bg-slate-600'}`} />
            <div className={`w-2 h-2 rounded-full transition-all duration-300 ${isComplete ? 'bg-blue-400 animate-pulse-slow' : 'bg-slate-600'}`} />
          </div>
        </div>
      </div>
    </div>
  );
}

===== ./src/components/ActionMenu.tsx =====
import { useGameStore } from '../stores/gameStore'
import { getUnitAbilities, canUseAbility } from '../game/core/abilities.ts'
import { type Unit } from 'shared'
import { UI_CONFIG } from '../config/uiConfig'

interface ActionMenuProps {
  unit: Unit
  position: { x: number; y: number }
  onActionSelect: (action: 'move' | 'attack' | string) => void
  onClose: () => void
}

export function ActionMenu({ unit, position, onActionSelect, onClose }: ActionMenuProps) {
  // Actions don't need selectors as they don't cause re-renders
  const canUnitMove = useGameStore(state => state.canUnitMove)
  const canUnitAttack = useGameStore(state => state.canUnitAttack)
  const getEnemiesInRange = useGameStore(state => state.getEnemiesInRange)
  const abilities = getUnitAbilities(unit)

  // Smart positioning logic - position tooltip to avoid screen edges
  const getTooltipPosition = () => {
    const { x, y } = position
    const tooltipWidth = UI_CONFIG.ACTION_MENU.POSITIONING.MIN_WIDTH
    const tooltipHeight = 200 // Estimate based on content
    const margin = UI_CONFIG.ACTION_MENU.POSITIONING.MARGIN
    
    // Default to bottom-right
    let posX = x + UI_CONFIG.ACTION_MENU.POSITIONING.OFFSET
    let posY = y + UI_CONFIG.ACTION_MENU.POSITIONING.OFFSET
    
    // If too close to right edge, show on left
    if (x + tooltipWidth + margin > window.innerWidth) {
      posX = x - tooltipWidth - UI_CONFIG.ACTION_MENU.POSITIONING.OFFSET
    }
    
    // If too close to bottom edge, show above  
    if (y + tooltipHeight + margin > window.innerHeight) {
      posY = y - tooltipHeight - UI_CONFIG.ACTION_MENU.POSITIONING.OFFSET
    }
    
    return { left: posX, top: posY }
  }

  const tooltipPos = getTooltipPosition()
  
  // Action availability checks (keep existing logic)
  const canMove = canUnitMove(unit)
  const enemiesInRange = getEnemiesInRange(unit)
  const canAttack = canUnitAttack(unit) && enemiesInRange.length > 0

  // Removed handleActionClick and handleEndTurn - now using direct prop calls

  return (
    <div 
      className={`fixed z-50 ${UI_CONFIG.ACTION_MENU.STYLE.BACKGROUND} ${UI_CONFIG.ACTION_MENU.STYLE.BORDER} rounded shadow-lg p-2 min-w-[${UI_CONFIG.ACTION_MENU.POSITIONING.MIN_WIDTH}px]`}
      style={{
        left: tooltipPos.left,
        top: tooltipPos.top,
        fontFamily: UI_CONFIG.ACTION_MENU.FONT.FAMILY,
        fontSize: UI_CONFIG.ACTION_MENU.FONT.SIZE
      }}
    >
      {/* Action Buttons - Simple List */}
      <div className="space-y-1">
        
        {/* Move Button */}
        {canMove && (
          <button
            onClick={() => onActionSelect('move')}
            className={`w-full text-left px-2 py-1 ${UI_CONFIG.ACTION_MENU.STYLE.HOVER} ${UI_CONFIG.ACTION_MENU.STYLE.TEXT} font-medium`}
          >
            Move
          </button>
        )}
        
        {/* Attack Button */}
        {canAttack && (
          <button
            onClick={() => onActionSelect('attack')}
            className={`w-full text-left px-2 py-1 ${UI_CONFIG.ACTION_MENU.STYLE.HOVER} ${UI_CONFIG.ACTION_MENU.STYLE.TEXT} font-medium`}
          >
            Attack
          </button>
        )}
        
        {/* Ability Buttons */}
        {abilities.map((ability) => {
          const canUse = canUseAbility(unit, ability.id)
          if (!canUse) return null
          
          return (
            <button
              key={ability.id}
              onClick={() => onActionSelect(ability.id)}
              className={`w-full text-left px-2 py-1 ${UI_CONFIG.ACTION_MENU.STYLE.HOVER} ${UI_CONFIG.ACTION_MENU.STYLE.TEXT} font-medium`}
            >
              {ability.name}
            </button>
          )
        })}
        
        {/* Separator Line */}
        <div className={`border-t ${UI_CONFIG.ACTION_MENU.STYLE.SEPARATOR} my-1`}></div>
        
        {/* End Turn Button */}
        <button
          onClick={onClose}
          className={`w-full text-left px-2 py-1 ${UI_CONFIG.ACTION_MENU.STYLE.END_BUTTON} ${UI_CONFIG.ACTION_MENU.STYLE.TEXT} font-medium`}
        >
          End
        </button>
      </div>
    </div>
  )
}
===== ./src/components/HowItWorksModal.tsx =====
interface HowItWorksModalProps {
  isOpen: boolean
  onClose: () => void
}

export function HowItWorksModal({ isOpen, onClose }: HowItWorksModalProps) {
  return (
    <>
      {isOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
          {/* Backdrop */}
          <div 
            className="absolute inset-0 bg-black bg-opacity-50 transition-opacity"
            onClick={onClose}
            aria-hidden="true"
          />
          
          {/* Modal */}
          <div className="relative bg-slate-800 rounded-lg border border-slate-700 shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
            {/* Header */}
            <div className="flex items-center justify-between p-6 border-b border-slate-700 sticky top-0 bg-slate-800">
              <h2 className="text-xl font-semibold text-blue-300">How to Play</h2>
              <button
                onClick={onClose}
                className="text-slate-400 hover:text-slate-200 transition-colors p-1 rounded-full hover:bg-slate-700"
                aria-label="Close modal"
              >
                <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
            
            {/* Content */}
            <div className="p-6 space-y-6">
              {/* Game Overview */}
              <div className="bg-slate-700/50 rounded-lg p-4">
                <h3 className="text-lg font-semibold text-slate-100 mb-3">Game Overview</h3>
                <p className="text-slate-300 text-sm leading-relaxed">
                  HRmageddon is a turn-based tactical strategy game where you wage cubicle warfare for control of the office floor. 
                  Build your team, capture strategic positions, and outmaneuver your opponent in this satirical office battle.
                </p>
              </div>

              {/* Team Information */}
              <div className="space-y-4">
                <h3 className="text-lg font-semibold text-slate-100">Teams & Units</h3>
                
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div className="bg-blue-900/20 border border-blue-700/30 rounded-lg p-4">
                    <h4 className="text-blue-300 font-semibold mb-2">Blue Team (You)</h4>
                    <p className="text-slate-300 text-sm">You control the blue units. Each unit has unique abilities and stats.</p>
                  </div>
                  
                  <div className="bg-red-900/20 border border-red-700/30 rounded-lg p-4">
                    <h4 className="text-red-300 font-semibold mb-2">Red Team (AI)</h4>
                    <p className="text-slate-300 text-sm">AI controls the red units. They will use strategic tactics against you.</p>
                  </div>
                </div>
              </div>

              {/* Gameplay Instructions */}
              <div className="space-y-4">
                <h3 className="text-lg font-semibold text-slate-100">How to Play</h3>
                
                <div className="space-y-3">
                  <div className="flex items-start space-x-3">
                    <span className="text-blue-400 text-lg mt-1">âM-^@¢</span>
                    <div>
                      <strong className="text-slate-200">Objective:</strong>
                      <span className="text-slate-300 text-sm ml-2">Capture cubicles and eliminate enemy units to achieve victory.</span>
                    </div>
                  </div>
                  
                  <div className="flex items-start space-x-3">
                    <span className="text-green-400 text-lg mt-1">âM-^@¢</span>
                    <div>
                      <strong className="text-slate-200">Controls:</strong>
                      <span className="text-slate-300 text-sm ml-2">Tap units to select, tap tiles to move/attack.</span>
                    </div>
                  </div>
                  
                  <div className="flex items-start space-x-3">
                    <span className="text-yellow-400 text-lg mt-1">âM-^@¢</span>
                    <div>
                      <strong className="text-slate-200">End Turn:</strong>
                      <span className="text-slate-300 text-sm ml-2">Tap "End Turn" when you're done with your actions.</span>
                    </div>
                  </div>
                  
                  <div className="flex items-start space-x-3">
                    <span className="text-purple-400 text-lg mt-1">âM-^@¢</span>
                    <div>
                      <strong className="text-slate-200">Abilities:</strong>
                      <span className="text-slate-300 text-sm ml-2">Select units to see their special abilities and costs.</span>
                    </div>
                  </div>
                </div>
              </div>

              {/* Mobile-Specific Tips */}
              <div className="bg-yellow-900/20 border border-yellow-700/30 rounded-lg p-4">
                <h3 className="text-lg font-semibold text-yellow-300 mb-3">ðM-^_M-^S± Mobile Tips</h3>
                <div className="space-y-2 text-sm text-slate-300">
                  <p>âM-^@¢ <strong>Touch-Friendly:</strong> All buttons and tiles are optimized for touch interaction</p>
                  <p>âM-^@¢ <strong>Responsive Design:</strong> Game automatically adapts to your screen size</p>
                  <p>âM-^@¢ <strong>Gesture Support:</strong> Swipe and tap gestures for smooth gameplay</p>
                  <p>âM-^@¢ <strong>Orientation:</strong> Works in both portrait and landscape modes</p>
                </div>
              </div>

              {/* Victory Conditions */}
              <div className="bg-green-900/20 border border-green-700/30 rounded-lg p-4">
                <h3 className="text-lg font-semibold text-green-300 mb-3">ðM-^_M-^OM-^F Victory Conditions</h3>
                <div className="space-y-2 text-sm text-slate-300">
                  <p>âM-^@¢ <strong>Capture Points:</strong> Control 51% of available cubicles</p>
                  <p>âM-^@¢ <strong>Elimination:</strong> Destroy all enemy units</p>
                  <p>âM-^@¢ <strong>Strategic Positioning:</strong> Use terrain and abilities to your advantage</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </>
  )
}

===== ./src/components/GameHUD.tsx =====
import { useState, useEffect, useCallback } from 'react'
import { useGameStore } from '../stores/gameStore'
import { useUIStore } from '../stores/uiStore'
import { useUnitStore } from '../stores/unitStore'
import { usePlayerStore } from '../stores/playerStore'
import { actionHandlers } from '../stores/actionHandlers'
import { ActionMenu } from './ActionMenu'
import { BottomSheet } from './BottomSheet'
// ABILITIES import removed - now handled by actionHandlers

// Type definitions for window extensions
interface GameScene {
  getTileSize?: () => number
  getBoardOffsetX?: () => number
  getBoardOffsetY?: () => number
  clearActionMode?: () => void
  setActionMode?: (mode: string, ability?: string) => void
  getActionMode?: () => string
}

interface ExtendedWindow extends Window {
  gameScene?: GameScene
}

declare const window: ExtendedWindow

import { HUD_CONFIG } from '../config/hudConfig'

export function GameHUD() {
  // Use selectors to prevent unnecessary re-renders
  const selectedUnit = useUnitStore(state => state.selectedUnit)
  const currentPlayerId = usePlayerStore(state => state.currentPlayerId)
  const players = usePlayerStore(state => state.players)
  const turnNumber = usePlayerStore(state => state.turnNumber)
  
  // Get game store for calculations
  const gameStore = useGameStore()
  
  // UI state from UI store
  const actionMode = useUIStore(state => state.actionMode)
  const selectedAbility = useUIStore(state => state.selectedAbility)
  const actionMenuPosition = useUIStore(state => state.actionMenuPosition)
  
  // Actions don't need selectors as they don't cause re-renders
  const endTurn = useGameStore(state => state.endTurn)
  const getAbilityTargets = useGameStore(state => state.getAbilityTargets)
  const canUnitMove = useGameStore(state => state.canUnitMove)
  const canUnitAttack = useGameStore(state => state.canUnitAttack)
  const getEnemiesInRange = useGameStore(state => state.getEnemiesInRange)

  const [actionFeedback, setActionFeedback] = useState<{ type: 'success' | 'error', message: string } | null>(null)
  
  // Mobile bottom sheet state
  const [isBottomSheetOpen, setIsBottomSheetOpen] = useState(false)
  const [activeSection, setActiveSection] = useState<'game-status' | 'unit-info' | 'help'>('game-status')
  
  // Desktop unified control panel state
  const [activeTab, setActiveTab] = useState<'status' | 'unit' | 'actions'>('status')

  // Mobile: Auto-open bottom sheet when unit is selected
  useEffect(() => {
    if (selectedUnit) {
      setIsBottomSheetOpen(true)
      setActiveSection('unit-info')
    } else {
      setIsBottomSheetOpen(false)
    }
  }, [selectedUnit])
  
  const isPlayerUnit = selectedUnit && selectedUnit.playerId === 'player1'
  const canControl = selectedUnit && selectedUnit.playerId === 'player1' && selectedUnit.actionsRemaining > 0
  const isPlayerTurn = currentPlayerId === 'player1'

  // Get player references
  const player1 = players.find((p) => p.id === 'player1')
  const player2 = players.find((p) => p.id === 'player2')

  

  // Reset action mode when selected unit changes or when unit has no actions remaining
  useEffect(() => {
    if (!selectedUnit || selectedUnit.actionsRemaining <= 0) {
      console.log('Resetting action mode: no unit selected or no actions remaining')
      actionHandlers.cancelAction()
      
      // Clear action mode in GameScene if available
      const gameScene = (window as ExtendedWindow).gameScene
      if (gameScene && gameScene.clearActionMode) {
        gameScene.clearActionMode()
      }
    }
  }, [selectedUnit])

  // Listen for action completion events from the game store
  useEffect(() => {
    const handleActionCompleted = () => {
      console.log('Action completed, resetting action mode')
      actionHandlers.cancelAction()
      
      // Clear action mode in GameScene if available
      const gameScene = (window as ExtendedWindow).gameScene
      if (gameScene && gameScene.clearActionMode) {
        gameScene.clearActionMode()
      }
    }

    // Listen for custom events when actions complete
    window.addEventListener('actionCompleted', handleActionCompleted)
    
    return () => {
      window.removeEventListener('actionCompleted', handleActionCompleted)
    }
  }, [])

  const handleActionSelect = (action: string) => {
    console.log('handleActionSelect called with action:', action)
    if (!selectedUnit) {
      console.log('No selected unit, returning')
      return;
    }

    if (action === 'move') {
      actionHandlers.enterMoveMode(selectedUnit)
    } else if (action === 'attack') {
      actionHandlers.enterAttackMode(selectedUnit)
    } else {
      // This is an ability
      actionHandlers.enterAbilityMode(selectedUnit, action)
    }

    // Set GameScene action mode with retry mechanism
    const setGameSceneActionMode = (retryCount = 0) => {
      const gameScene = (window as ExtendedWindow).gameScene
      
      if (gameScene && gameScene.setActionMode) {
        if (action !== 'move' && action !== 'attack') {
          gameScene.setActionMode('ability', action)
        } else {
          gameScene.setActionMode(action)
        }
      } else if (retryCount < 3) {
        // Retry after a short delay if GameScene isn't ready yet
        setTimeout(() => setGameSceneActionMode(retryCount + 1), 100)
      } else {
        console.log('GameScene not available after retries, action mode set locally only')
      }
    }
    
    setGameSceneActionMode()
    
    // Immediately hide the action menu after action selection
    useUIStore.getState().setActionMenu(null)
  }

  // Handle tile clicks for actions
  const handleTileClick = useCallback((coord: { x: number, y: number }) => {
    if (!selectedUnit || !canControl) return

    console.log('Tile clicked:', coord, 'Action mode:', actionMode)

    // Calculate possible moves and targets inside the callback
    const possibleMoves = gameStore.calculatePossibleMoves(selectedUnit)
    const possibleTargets = gameStore.calculatePossibleTargets(selectedUnit)

    switch (actionMode) {
      case 'move': {
        // Check if this is a valid move
        const isValidMove = possibleMoves.some((move) => move.x === coord.x && move.y === coord.y)
        if (isValidMove) {
          console.log('Executing move to:', coord)
          actionHandlers.executeMove(selectedUnit, coord)
          
          // Clear action mode in game scene
          const gameScene = (window as ExtendedWindow).gameScene
          if (gameScene && gameScene.clearActionMode) {
            gameScene.clearActionMode()
          }
          
          setActionFeedback({ type: 'success', message: 'Unit moved successfully!' })
          setTimeout(() => setActionFeedback(null), HUD_CONFIG.FEEDBACK.DURATION)
        } else {
          setActionFeedback({ type: 'error', message: 'Invalid move location' })
          setTimeout(() => setActionFeedback(null), HUD_CONFIG.FEEDBACK.DURATION)
        }
        break
      }

      case 'attack': {
        // Check if this tile has a valid attack target
        const isValidTarget = possibleTargets.some((target) => target.x === coord.x && target.y === coord.y)
        const targetUnit = useUnitStore.getState().units.find((u) => 
          u.position.x === coord.x && 
          u.position.y === coord.y && 
          u.playerId !== selectedUnit.playerId
        )
        
        if (isValidTarget && targetUnit) {
          console.log('Executing attack on:', targetUnit.id)
          actionHandlers.executeAttack(selectedUnit, targetUnit)
          
          // Clear action mode in game scene
          const gameScene = (window as ExtendedWindow).gameScene
          if (gameScene && gameScene.clearActionMode) {
            gameScene.clearActionMode()
          }
          
          setActionFeedback({ type: 'success', message: 'Attack executed!' })
          setTimeout(() => setActionFeedback(null), HUD_CONFIG.FEEDBACK.DURATION)
        } else {
          setActionFeedback({ type: 'error', message: 'No enemy unit at this location' })
          setTimeout(() => setActionFeedback(null), HUD_CONFIG.FEEDBACK.DURATION)
        }
        break
      }

      case 'ability': {
        if (selectedAbility) {
          // Get valid targets for this ability
          const validTargets = getAbilityTargets(selectedUnit.id, selectedAbility)
          const clickedTarget = validTargets.find(target => {
            if ('x' in target) {
              return target.x === coord.x && target.y === coord.y
            } else {
              return target.position.x === coord.x && target.position.y === coord.y
            }
          })

          if (clickedTarget) {
            console.log('Executing ability:', selectedAbility, 'on target:', clickedTarget)
            actionHandlers.executeAbility(selectedUnit, selectedAbility, clickedTarget)
            
            // Clear action mode in game scene
            const gameScene = (window as ExtendedWindow).gameScene
            if (gameScene && gameScene.clearActionMode) {
              gameScene.clearActionMode()
            }
            
            setActionFeedback({ type: 'success', message: 'Ability used successfully!' })
            setTimeout(() => setActionFeedback(null), HUD_CONFIG.FEEDBACK.DURATION)
          } else {
            setActionFeedback({ type: 'error', message: 'Invalid target for this ability' })
            setTimeout(() => setActionFeedback(null), HUD_CONFIG.FEEDBACK.DURATION)
          }
        }
        break
      }
    }
  }, [selectedUnit, canControl, actionMode, selectedAbility, getAbilityTargets, gameStore])

  // Listen for tile clicks from the game scene
  useEffect(() => {
    const handleGameTileClick = (event: CustomEvent) => {
      const { coord } = event.detail
      handleTileClick(coord)
    }

    const handleAbilityUsed = (event: CustomEvent) => {
      console.log('Ability used:', event.detail?.abilityId)
      actionHandlers.cancelAction()
      setActionFeedback({ type: 'success', message: 'Ability used successfully!' })
      setTimeout(() => setActionFeedback(null), HUD_CONFIG.FEEDBACK.DURATION)
    }

    const handleAbilityCancelled = () => {
      console.log('Ability cancelled')
      actionHandlers.cancelAction()
      setActionFeedback({ type: 'error', message: 'Ability cancelled - invalid target' })
      setTimeout(() => setActionFeedback(null), HUD_CONFIG.FEEDBACK.DURATION)
    }

    window.addEventListener('gameTileClick', handleGameTileClick as EventListener)
    window.addEventListener('abilityUsed', handleAbilityUsed as EventListener)
    window.addEventListener('abilityCancelled', handleAbilityCancelled as EventListener)
    
    return () => {
      window.removeEventListener('gameTileClick', handleGameTileClick as EventListener)
      window.removeEventListener('abilityUsed', handleAbilityUsed as EventListener)
      window.removeEventListener('abilityCancelled', handleAbilityCancelled as EventListener)
    }
  }, [selectedUnit, actionMode, selectedAbility, canControl, handleTileClick])

  // Listen for unit selection blocked events
  useEffect(() => {
    const handleUnitSelectionBlocked = () => {
      setActionFeedback({ 
        type: 'error', 
        message: 'Complete or cancel current action before selecting other units' 
      })
      setTimeout(() => {
        setActionFeedback(null)
      }, HUD_CONFIG.FEEDBACK.DURATION * 1.5)
    }

    window.addEventListener('unitSelectionBlocked', handleUnitSelectionBlocked as EventListener)
    return () => {
      window.removeEventListener('unitSelectionBlocked', handleUnitSelectionBlocked as EventListener)
    }
  }, [])


  // Mobile: Open bottom sheet when unit is selected
  useEffect(() => {
    if (selectedUnit) {
      setIsBottomSheetOpen(true)
      setActiveSection('unit-info')
    } else {
      setIsBottomSheetOpen(false)
    }
  }, [selectedUnit])

  return (
    <>
      {/* Action Feedback Toast */}
      {actionFeedback && (
        <div className={`${HUD_CONFIG.FEEDBACK.POSITION} px-6 py-3 rounded-lg shadow-lg transition-all duration-300 ${
          actionFeedback.type === 'success' 
            ? 'bg-green-600 text-white' 
            : 'bg-red-600 text-white'
        }`}>
          {actionFeedback.message}
        </div>
      )}

      {/* Mobile Layout: Bottom Sheet */}
      <div className="lg:hidden">
        {/* Mobile Game Status Bar - Always Visible */}
        <div className="fixed top-16 left-0 right-0 bg-slate-800 border-b border-slate-700 p-3 z-30">
          <div className="flex items-center justify-between">
            {/* Turn Info */}
            <div className="flex items-center space-x-3">
              <div className="text-sm font-semibold">Turn {turnNumber}</div>
              <div className={`px-2 py-1 rounded text-xs font-medium ${
                isPlayerTurn ? 'bg-amber-600 text-white' : 'bg-stone-600 text-white'
              }`}>
                {isPlayerTurn ? 'Your Turn' : 'AI Turn'}
              </div>
            </div>
            
            {/* Cubicle Count */}
            <div className="flex items-center space-x-2 text-xs">
              <span className="text-amber-400">Gold: {player1?.controlledCubicles || 0}</span>
              <span className="text-blue-400">Navy: {player2?.controlledCubicles || 0}</span>
            </div>
            
            {/* End Turn Button */}
            {isPlayerTurn && (
              <button
                onClick={endTurn}
                className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs font-medium rounded transition-colors"
              >
                End Turn
              </button>
            )}
            
            {/* Toggle Bottom Sheet Button */}
            <button
              onClick={() => setIsBottomSheetOpen(!isBottomSheetOpen)}
              className="px-3 py-1 bg-slate-600 hover:bg-slate-700 text-white text-xs font-medium rounded transition-colors"
            >
              {isBottomSheetOpen ? 'Hide' : 'Show'} Info
            </button>
          </div>
        </div>

        {/* Bottom Sheet for Game Info */}
        <BottomSheet
          isOpen={isBottomSheetOpen}
          onClose={() => setIsBottomSheetOpen(false)}
          title="Game Information"
          snapPoints={[200, 400, 600]}
          initialSnapPoint={1}
        >
          {/* Section Navigation */}
          <div className="flex space-x-2 mb-4">
            <button
              onClick={() => setActiveSection('game-status')}
              className={`px-3 py-2 rounded text-sm font-medium transition-colors ${
                activeSection === 'game-status' 
                  ? 'bg-blue-600 text-white' 
                  : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
            >
              Status
            </button>
            <button
              onClick={() => setActiveSection('unit-info')}
              className={`px-3 py-2 rounded text-sm font-medium transition-colors ${
                activeSection === 'unit-info' 
                  ? 'bg-blue-600 text-white' 
                  : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
            >
              Unit
            </button>
            <button
              onClick={() => setActiveSection('help')}
              className={`px-3 py-2 rounded text-sm font-medium transition-colors ${
                activeSection === 'help' 
                  ? 'bg-blue-600 text-white' 
                  : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
            >
              Help
            </button>
          </div>

          {/* Game Status Section */}
          {activeSection === 'game-status' && (
            <div className="space-y-4">
              <div className="text-center">
                <div className="text-xl font-bold mb-2">Turn {turnNumber}</div>
                <div className={`px-4 py-2 rounded-lg text-white font-semibold ${isPlayerTurn ? 'bg-amber-600' : 'bg-stone-600'}`}>
                  {isPlayerTurn ? 'Your Turn' : 'AI Turn'}
                </div>
              </div>

              {/* Player Resources */}
              <div className="space-y-3">
                <h3 className="text-md font-semibold text-center">Resources</h3>
                
                {/* Player 1 (Gold) */}
                <div className="bg-amber-900/20 border border-amber-700 rounded-lg p-3">
                  <div className="text-amber-400 font-semibold text-sm">Gold Team (You)</div>
                  <div className="text-xs space-y-1 mt-2 text-amber-300">
                    <div>Budget: ${player1?.budget || 0}</div>
                    <div>Income: +${player1?.income || 0}/turn</div>
                    <div>Cubicles: {player1?.controlledCubicles || 0}</div>
                  </div>
                </div>

                {/* Player 2 (Navy) */}
                <div className="bg-blue-900/20 border border-blue-700 rounded-lg p-3">
                  <div className="text-blue-400 font-semibold text-sm">Navy Team (AI)</div>
                  <div className="text-xs space-y-1 mt-2 text-blue-300">
                    <div>Budget: ${player2?.budget || 0}</div>
                    <div>Income: +${player2?.income || 0}/turn</div>
                    <div>Cubicles: {player2?.controlledCubicles || 0}</div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Unit Info Section */}
          {activeSection === 'unit-info' && selectedUnit && (
            <div className="space-y-4">
              {/* Unit Info Header */}
              <div className="border-b border-slate-600 pb-3">
                <div className="flex items-center justify-between">
                  <h3 className="text-lg font-bold text-amber-400 capitalize">
                    {selectedUnit.type.replace('_', ' ')}
                  </h3>
                  <div className="flex items-center space-x-2">
                    <div className={`w-3 h-3 rounded-full ${isPlayerUnit ? 'bg-amber-500' : 'bg-stone-500'}`} />
                    <span className="text-xs text-slate-400">
                      {isPlayerUnit ? 'Player' : 'Enemy'}
                    </span>
                  </div>
                </div>
                
                {canControl && (
                  <div className="text-xs text-green-400 mt-1">
                    Controlling - {selectedUnit.actionsRemaining} action{selectedUnit.actionsRemaining !== 1 ? 's' : ''} remaining
                  </div>
                )}
              </div>

              {/* Unit Stats */}
              <div className="space-y-2 text-sm">
                <div className="flex justify-between">
                  <span className="text-slate-400">HP:</span>
                  <span className="text-white">{selectedUnit.hp}/{selectedUnit.maxHp}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-slate-400">Actions:</span>
                  <span className="text-white">{selectedUnit.actionsRemaining}/{selectedUnit.maxActions}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-slate-400">Move Range:</span>
                  <span className="text-white">{selectedUnit.moveRange}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-slate-400">Attack Range:</span>
                  <span className="text-white">{selectedUnit.attackRange}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-slate-400">Attack Damage:</span>
                  <span className="text-white">{selectedUnit.attackDamage}</span>
                </div>
              </div>
            </div>
          )}

          {/* Help Section */}
          {activeSection === 'help' && (
            <div className="space-y-3 text-sm">
              <h3 className="text-lg font-bold text-center">How to Play</h3>
              <div className="space-y-2 text-slate-300">
                <div>âM-^@¢ Click any unit to view their stats</div>
                <div>âM-^@¢ Click player units (gold) to control them</div>
                <div>âM-^@¢ Click highlighted tiles to move/attack</div>
                <div>âM-^@¢ Select abilities to use them on targets</div>
                <div>âM-^@¢ Capture cubicles to increase income</div>
                <div>âM-^@¢ End turn when you're done</div>
              </div>
            </div>
          )}
        </BottomSheet>
      </div>

      {/* Desktop Layout: Flash Game Unified Control Panel */}
      <div className="hidden lg:block">
        <div className="h-full bg-slate-800 border-l-2 border-slate-700 flex flex-col">
          {/* Tab Navigation */}
          <div className="flex border-b border-slate-700 bg-slate-900">
            <button 
              className={`flex-1 px-4 py-3 text-sm font-medium transition-colors cursor-pointer border-r border-slate-700 hover:bg-slate-800 ${
                activeTab === 'status' ? 'bg-slate-700 text-blue-400 border-b-2 border-blue-400' : 'text-slate-300'
              }`}
              onClick={() => setActiveTab('status')}
            >
              Game Status
            </button>
            <button 
              className={`flex-1 px-4 py-3 text-sm font-medium transition-colors cursor-pointer border-r border-slate-700 hover:bg-slate-800 ${
                activeTab === 'unit' ? 'bg-slate-700 text-blue-400 border-b-2 border-blue-400' : 'text-slate-300'
              }`}
              onClick={() => setActiveTab('unit')}
            >
              Unit Info
            </button>
            <button 
              className={`flex-1 px-4 py-3 text-sm font-medium transition-colors cursor-pointer hover:bg-slate-800 ${
                activeTab === 'actions' ? 'bg-slate-700 text-blue-400 border-b-2 border-blue-400' : 'text-slate-300'
              }`}
              onClick={() => setActiveTab('actions')}
            >
              Actions
            </button>
          </div>
          
          {/* Tab Content */}
          <div className="flex-1 overflow-y-auto p-4">
            {/* Game Status Tab */}
            {activeTab === 'status' && (
              <div className="space-y-4">
                <h2 className="text-lg font-bold text-center text-slate-100">Game Status</h2>
                <div className="text-center">
                  <div className="text-2xl font-bold mb-2 text-slate-100">Turn {turnNumber}</div>
                  <div className={`px-4 py-2 rounded-lg text-white font-semibold ${isPlayerTurn ? 'bg-amber-600' : 'bg-stone-600'}`}>
                    {isPlayerTurn ? 'Your Turn (Gold)' : 'AI Turn (Navy)'}
                  </div>
                </div>

                {/* Player Resources */}
                <div className="space-y-3">
                  <h3 className="text-md font-semibold text-center text-slate-200">Resources</h3>
                  
                  {/* Player 1 (Gold) */}
                  <div className="bg-blue-900/20 border border-blue-700/30 rounded-lg p-3">
                    <div className="text-blue-300 font-semibold text-sm">Gold Team (You)</div>
                    <div className="text-xs space-y-1 mt-2 text-slate-300">
                      <div>Budget: ${player1?.budget || 0}</div>
                      <div>Income: +${player1?.income || 0}/turn</div>
                      <div>Cubicles: {player1?.controlledCubicles || 0}</div>
                    </div>
                  </div>

                  {/* Player 2 (Navy) */}
                  <div className="bg-red-900/20 border border-red-700/30 rounded-lg p-3">
                    <div className="text-red-300 font-semibold text-sm">Navy Team (AI)</div>
                    <div className="text-xs space-y-1 mt-2 text-slate-300">
                      <div>Budget: ${player2?.budget || 0}</div>
                      <div>Income: +${player2?.income || 0}/turn</div>
                      <div>Cubicles: {player2?.controlledCubicles || 0}</div>
                    </div>
                  </div>
                </div>

                {/* End Turn Button */}
                {isPlayerTurn && (
                  <div className="text-center">
                    <button
                      onClick={endTurn}
                      className="w-full px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-lg transition-colors duration-200 shadow-lg hover:shadow-xl"
                    >
                      End Turn
                    </button>
                    <p className="text-xs text-slate-400 mt-2">
                      Pass control to the AI opponent
                    </p>
                  </div>
                )}
              </div>
            )}

            {/* Unit Info Tab */}
            {activeTab === 'unit' && (
              <div className="space-y-4">
                {selectedUnit ? (
                  <>
                    <h2 className="text-lg font-bold text-center text-slate-100">Unit Information</h2>
                    
                    {/* Unit Header */}
                    <div className="border-b border-slate-600 pb-3">
                      <div className="flex items-center justify-between">
                        <h3 className="text-lg font-bold text-blue-400 capitalize">
                          {selectedUnit.type.replace('_', ' ')}
                        </h3>
                        <div className="flex items-center space-x-2">
                          <div className={`w-3 h-3 rounded-full ${isPlayerUnit ? 'bg-amber-500' : 'bg-stone-500'}`} />
                          <span className="text-xs text-slate-400">
                            {isPlayerUnit ? 'Player' : 'Enemy'}
                          </span>
                        </div>
                      </div>
                      
                      {/* Control indicator */}
                      {canControl ? (
                        <div className="text-xs text-green-400 mt-1">
                          Controlling - {selectedUnit.actionsRemaining} action{selectedUnit.actionsRemaining !== 1 ? 's' : ''} remaining
                        </div>
                      ) : (
                        <div className="text-xs text-slate-400 mt-1">
                          Viewing
                        </div>
                      )}
                    </div>

                    {/* Unit Stats */}
                    <div className="space-y-2 text-sm">
                      <div className="flex justify-between">
                        <span className="text-slate-400">HP:</span>
                        <span className="text-white">{selectedUnit.hp}/{selectedUnit.maxHp}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-slate-400">Actions:</span>
                        <span className="text-white">{selectedUnit.actionsRemaining}/{selectedUnit.maxActions}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-slate-400">Move Range:</span>
                        <span className="text-white">{selectedUnit.moveRange}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-slate-400">Attack Range:</span>
                        <span className="text-white">{selectedUnit.attackRange}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-slate-400">Attack Damage:</span>
                        <span className="text-white">{selectedUnit.attackDamage}</span>
                      </div>
                    </div>
                  </>
                ) : (
                  <div className="text-center text-slate-400 py-8">
                    <p>No unit selected</p>
                    <p className="text-sm mt-2">Click on a unit to view its information</p>
                  </div>
                )}
              </div>
            )}

            {/* Actions Tab */}
            {activeTab === 'actions' && (
              <div className="space-y-4">
                <h2 className="text-lg font-bold text-center text-slate-100">Available Actions</h2>
                
                {selectedUnit && canControl ? (
                  <div className="space-y-3">
                    {/* Basic Actions */}
                    <div className="space-y-2">
                      <h4 className="text-sm font-semibold text-blue-400 border-b border-slate-600 pb-1">
                        Basic Actions
                      </h4>
                      
                      <div className="grid grid-cols-2 gap-2">
                        {canUnitMove(selectedUnit) && (
                          <button
                            onClick={() => handleActionSelect('move')}
                            className="px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded transition-colors"
                          >
                            Move
                          </button>
                        )}
                        
                        {canUnitAttack(selectedUnit) && getEnemiesInRange(selectedUnit).length > 0 && (
                          <button
                            onClick={() => handleActionSelect('attack')}
                            className="px-3 py-2 bg-red-600 hover:bg-red-700 text-white text-sm font-medium rounded transition-colors"
                          >
                            Attack
                          </button>
                        )}
                      </div>
                    </div>

                    {/* Action Menu Instructions */}
                    <div className="bg-blue-900/20 border border-blue-700/30 rounded-lg p-3">
                      <div className="text-blue-300 font-semibold text-sm mb-2">
                        Action Menu Available
                      </div>
                      <div className="text-xs text-blue-200">
                        The action menu will appear when you select an action above, or you can use the floating action menu that appears on the game board.
                      </div>
                    </div>

                    {/* Action Menu Instructions */}
                    <div className="bg-blue-900/20 border border-blue-700/30 rounded-lg p-3">
                      <div className="text-blue-300 font-semibold text-sm mb-2">
                        Action Menu Available
                      </div>
                      <div className="text-xs text-blue-200">
                        The action menu will appear when you select an action above, or you can use the floating action menu that appears on the game board.
                      </div>
                    </div>

                    {/* Action Mode Display */}
                    {actionMode !== 'none' && (
                      <div className="bg-slate-700/50 border border-slate-600 rounded-lg p-3">
                        <div className="text-yellow-300 font-semibold text-sm">
                          Current Mode: {actionMode.toUpperCase()}
                          {selectedAbility && ` - ${selectedAbility.replace('_', ' ')}`}
                        </div>
                        <div className="text-xs text-slate-300 mt-1">
                          {actionMode === 'move' && 'Click a highlighted tile to move'}
                          {actionMode === 'attack' && 'Click an enemy to attack'}
                          {actionMode === 'ability' && selectedAbility && `Select a target for ${selectedAbility.replace('_', ' ')}`}
                        </div>
                        <button
                          onClick={() => {
                            actionHandlers.cancelAction()
                            const gameScene = (window as ExtendedWindow).gameScene
                            if (gameScene && gameScene.clearActionMode) {
                              gameScene.clearActionMode()
                            }
                          }}
                          className="mt-2 px-3 py-1 bg-slate-600 hover:bg-slate-700 text-white text-xs rounded transition-colors"
                        >
                          Cancel Action
                        </button>
                      </div>
                    )}

                    {/* Help Text */}
                    <div className="text-xs text-slate-400 space-y-1 pt-2 border-t border-slate-600">
                      <div>âM-^@¢ Click any unit to view their stats</div>
                      <div>âM-^@¢ Click player units (gold) to control them</div>
                      <div>âM-^@¢ Click highlighted tiles to move/attack</div>
                      <div>âM-^@¢ Select abilities to use them on targets</div>
                      <div>âM-^@¢ Capture cubicles to increase income</div>
                      <div>âM-^@¢ End turn when you're done</div>
                    </div>
                  </div>
                ) : (
                  <div className="text-center text-slate-400 py-8">
                    <p>No unit selected or unit cannot be controlled</p>
                    <p className="text-sm mt-2">Select a player unit to see available actions</p>
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Action Menu Modal - Show on both mobile and desktop when needed */}
      {actionMenuPosition && actionMenuPosition.isVisible && selectedUnit && (
        <>
          {console.log('Rendering ActionMenu with:', { actionMenuPosition, selectedUnit })}
          <ActionMenu
            unit={selectedUnit}
            position={actionMenuPosition}
            onActionSelect={handleActionSelect}
            onClose={() => {
              // Deselect the unit when closing the action menu
              useGameStore.getState().selectUnit(undefined)
            }}
          />
        </>
      )}
    </>
  )
}
===== ./src/components/MainMenu.tsx =====
import { useState } from 'react'
import { useGameStore } from '../stores/gameStore'
import Hero from "./layout/Hero"
import { HowItWorksModal } from './HowItWorksModal'
import { dataManager } from '../game/data/DataManager'

export function MainMenu() {
  // Actions don't need selectors as they don't cause re-renders
  const initializeDraft = useGameStore(state => state.initializeDraft)
  const setGameMode = useGameStore(state => state.setGameMode)
  const initializeGame = useGameStore(state => state.initializeGame)
  const [showHowItWorks, setShowHowItWorks] = useState(false)

  const handleStartGame = async (mode: 'ai' | 'multiplayer') => {
    try {
      await dataManager.ensureLoaded() // Wait for data
      setGameMode(mode)
      initializeDraft() // Now this is safe to call
    } catch (error) {
      console.error("Failed to start game due to data loading error:", error)
      // Optionally, show an error message to the user here
    }
  }

  const handleQuickStart = async () => {
    try {
      await dataManager.ensureLoaded() // Wait for data
      setGameMode('ai')
      initializeGame() // Now this is safe to call
    } catch (error) {
      console.error("Failed to quick start due to data loading error:", error)
    }
  }

  return (
    <div className="min-h-screen bg-slate-900 text-slate-100">
      <Hero bgSrc="/img/home-hero-01.jpg" overlay={28} contentPosition="center">
        <div className="text-center space-y-8 sm:space-y-12 max-w-4xl mx-auto">
          {/* Game Title */}
          <div className="space-y-4 sm:space-y-6">
            <h1 className="text-4xl sm:text-5xl md:text-6xl lg:text-7xl font-bold text-blue-400 hero-title leading-tight px-4">
              HRmageddon
            </h1>
            <p className="text-lg sm:text-xl md:text-2xl text-slate-200 max-w-2xl mx-auto leading-relaxed px-4">
              Wage cubicle warfare for control of the office floor in this tactical strategy game
            </p>
          </div>

          {/* Game Mode Selection */}
          <div className="space-y-4 sm:space-y-6 px-4">
            <h2 className="text-2xl sm:text-3xl font-semibold text-slate-200">Select Game Mode</h2>
            
            <div className="flex flex-col gap-4 sm:gap-6 justify-center">
              {/* Quick Start (for testing) */}
              <button
                onClick={handleQuickStart}
                className="px-6 sm:px-10 py-4 sm:py-6 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-xl transition-all duration-300 shadow-lg hover:shadow-xl transform hover:scale-105 border-2 border-green-500/30 min-h-[60px] sm:min-h-[80px]"
              >
                <div className="text-lg sm:text-2xl font-bold mb-1 sm:mb-2">Quick Start</div>
                <div className="text-xs sm:text-sm opacity-90">Skip Draft & Test Game</div>
              </button>

              {/* Player vs AI */}
              <button
                onClick={() => handleStartGame('ai')}
                className="px-6 sm:px-10 py-4 sm:py-6 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-xl transition-all duration-300 shadow-lg hover:shadow-xl transform hover:scale-105 border-2 border-blue-500/30 min-h-[60px] sm:min-h-[80px]"
              >
                <div className="text-lg sm:text-2xl font-bold mb-1 sm:mb-2">Player vs AI</div>
                <div className="text-xs sm:text-sm opacity-90">Single Player Experience</div>
              </button>

              {/* Player vs Player (Disabled) */}
              <button
                disabled
                className="px-6 sm:px-10 py-4 sm:py-6 bg-slate-600 text-slate-400 font-semibold rounded-xl cursor-not-allowed opacity-50 border-2 border-slate-500/30 min-h-[60px] sm:min-h-[80px]"
              >
                <div className="text-lg sm:text-2xl font-bold mb-1 sm:mb-2">Player vs Player</div>
                <div className="text-xs sm:text-sm">Multiplayer (Coming Soon)</div>
              </button>

              {/* Test Mode */}
              <button
                onClick={() => useGameStore.getState().enterTestMode()}
                className="px-6 sm:px-10 py-4 sm:py-6 bg-purple-600 hover:bg-purple-700 text-white font-semibold rounded-xl transition-all duration-300 shadow-lg hover:shadow-xl transform hover:scale-105 border-2 border-purple-500/30 min-h-[60px] sm:min-h-[80px]"
              >
                <div className="text-lg sm:text-2xl font-bold mb-1 sm:mb-2">ðM-^_§ª Test Mode</div>
                <div className="text-xs sm:text-sm">Debug Tile Sizing System</div>
              </button>
            </div>
          </div>

          {/* Game Info & How It Works */}
          <div className="space-y-4 px-4">
            <div className="text-sm text-slate-400 space-y-3 bg-slate-800/50 backdrop-blur-modern rounded-xl p-4 border border-slate-700/30">
              <p className="font-medium">Phase 1 Prototype - Core Game Engine</p>
              <p>Turn-based tactical combat with office-themed units</p>
            </div>

            {/* How It Works Button */}
            <div className="flex justify-center">
              <button
                onClick={() => setShowHowItWorks(true)}
                className="px-8 py-4 bg-slate-700 hover:bg-slate-600 text-slate-200 font-semibold rounded-xl transition-all duration-300 shadow-lg hover:shadow-xl border-2 border-slate-600/30 min-h-[56px]"
              >
                <div className="text-lg font-semibold">ðM-^_M-^SM-^V How It Works</div>
                <div className="text-sm opacity-90">Learn the game rules & controls</div>
              </button>
            </div>
          </div>
        </div>
      </Hero>
      
      {/* How It Works Modal */}
      <HowItWorksModal 
        isOpen={showHowItWorks} 
        onClose={() => setShowHowItWorks(false)} 
      />
    </div>
  )
}

===== ./src/lib/config.ts =====
// client/src/lib/config.ts
const API_URL = import.meta.env.VITE_API_URL ?? "http://localhost:4001";
const SOCKET_URL = import.meta.env.VITE_SOCKET_URL ?? "ws://localhost:4001";

export const config = { API_URL, SOCKET_URL };

